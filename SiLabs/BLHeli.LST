MACRO ASSEMBLER BLHELI                                      09/01/16 09:39:38 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.18.15.328
OBJECT MODULE PLACED IN OUTPUT\HTIRC_HUMMINGBIRD_30A_PRO_REV14_75.OBJ
ASSEMBLER INVOKED BY: SET(BESCNO=95) OBJECT(OUTPUT\HTIRC_HUMMINGBIRD_30A_PRO_REV14_75.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ;
                         4     ; BLHeli program for controlling brushless motors in helicopters and multirotors
                         5     ;
                         6     ; Copyright 2011, 2012 Steffen Skaug
                         7     ; This program is distributed under the terms of the GNU General Public License
                         8     ;
                         9     ; This file is part of BLHeli.
                        10     ;
                        11     ; BLHeli is free software: you can redistribute it and/or modify
                        12     ; it under the terms of the GNU General Public License as published by
                        13     ; the Free Software Foundation, either version 3 of the License, or
                        14     ; (at your option) any later version.
                        15     ;
                        16     ; BLHeli is distributed in the hope that it will be useful,
                        17     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        18     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        19     ; GNU General Public License for more details.
                        20     ;
                        21     ; You should have received a copy of the GNU General Public License
                        22     ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                        23     ;
                        24     ;**** **** **** **** ****
                        25     ;
                        26     ; The software was initially designed for use with Eflite mCP X, but is now adapted to copters/planes in general
                        27     ;
                        28     ; The software was inspired by and started from from Bernard Konze's BLMC: http://home.versanet.de/~bkonze/blc_6a/blc_6a.htm
                        29     ; And also Simon Kirby's TGY: https://github.com/sim-/tgy
                        30     ;
                        31     ; This file is best viewed with tab width set to 5
                        32     ;
                        33     ; The input signal can be positive 1kHz, 2kHz, 4kHz, 8kHz or 12kHz PWM (e.g. taken from the "resistor tap" on mCPx)
                        34     ; And the input signal can be PPM (1-2ms) or OneShot125 (125-250us) at rates up to several hundred Hz.
                        35     ; The code autodetects the various input modes/frequencies
                        36     ; The code can also be programmed to accept inverted input signal.
                        37     ;
                        38     ; The first lines of the software must be modified according to the chosen environment:
                        39     ; Uncomment the selected ESC and main/tail/multi mode
                        40     ; BESCNO EQU "ESC"_"mode" 						
                        41     ; 
                        42     ;**** **** **** **** ****
                        43     ; Revision history:
                        44     ; - Rev1.0: Initial revision based upon BLHeli for AVR controllers
                        45     ; - Rev2.0: Changed "Eeprom" initialization, layout and defaults
                        46     ;           Various changes and improvements to comparator reading. Now using timer1 for time from pwm on/off
                        47     ;           Beeps are made louder
                        48     ;           Added programmable low voltage limit
                        49     ;           Added programmable damped tail mode (only for 1S ESCs)
                        50     ;           Added programmable motor rotation direction
                        51     ; - Rev2.1: (minor changes by 4712)
                        52     ;		  Added Disable TX Programming by PC Setup Application 
                        53     ;		  therfore changed EEPROM_LAYOUT_REVISION = 8					
                        54     ;		  Added Vdd Monitor as reset source when writing to "EEProm"
                        55     ;		  Changed for use of batch file to assemble, link and make hex files	
                        56     ; - Rev2.2: (minor changes by 4712)
                        57     ;           Added Disable Throttle Re-Arming every motor start by PC Setup Application 
                        58     ; - Rev2.3: (minor changes by 4712)
                        59     ;           Added bugfixed (2x CLR C before j(n)c operations)thx Steffen!			
                        60     ; - Rev2.4: Revisions 2.1 to 2.3 integrated
                        61     ; - Rev3.0: Added PPM (1050us-1866us) as accepted input signal
                        62     ;           Added startup rpm as a programming parameter
                        63     ;           Added startup acceleration as a programming parameter
                        64     ;           Added option for using voltage measurements to compensate motor power
                        65     ;           Added governor target by setup as a governor mode option
                        66     ;           Governor is kept active regardless of rpm
                        67     ;           Smooth governor spoolup/down in arm and setup modes
                        68     ;           Increased governor P and I gain programming ranges
                        69     ;           Increased and changed low voltage limit programming range
                        70     ;           Disabled tx programming entry for all but the first arming sequence after power on
                        71     ;           Made it possible to skip parameters in tx programming by setting throttle midstick
                        72     ;           Made it default not to rearm for every restart
                        73     ; - Rev3.1: Fixed bug that prevented chosen parameter to be set in tx programming
                        74     ; - Rev3.2: ...also updated the EEPROM revision parameter
                        75     ; - Rev3.3: Fixed negative number bug in voltage compensation
                        76     ;           Fixed bug in startup power calculation for non-default power
                        77     ;           Prevented possibility for voltage compensation fighting low voltage limiting
                        78     ;           Applied overall spoolup control to ensure soft spoolup in any mode
                        79     ;           Added a delay of 3 seconds from initiation of main motor stop until new startup is allowed
                        80     ;           Reduced beep power to reduce power consumption for very strong motors/ESCs
                        81     ; - Rev3.4: Fixed bug that prevented full power in governor arm and setup modes
                        82     ;           Increased NFETON_DELAY for XP_7A and XP_12A to allow for more powerful fets
                        83     ;           Increased initial spoolup power, and linked to startup power
                        84     ; - Rev4.0: Fixed bug that made tail tx program beeps very weak
                        85     ;           Added thermal protection feature
                        86     ;           Governor P and I gain ranges are extended up to 8.0x gain
                        87     ;           Startup sequence is aborted upon zero throttle
                        88     ;           Avoided voltage compensation function induced latency for tail when voltage compensation is not enabled
                        89     ;           Improved input signal frequency detection robustness
                        90     ; - Rev4.1: Increased thermal protection temperature limits
                        91     ; - Rev5.0: Added multi(copter) operating mode. TAIL define changed to MODE with three modes: MAIN, TAIL and MULTI
                        92     ;           Added programmable commutation timing
                        93     ;           Added a damped light mode that has less damping, but that can be used with all escs
                        94     ;           Added programmable damping force
                        95     ;           Added thermal protection for startup too
                        96     ;           Added wait beeps when waiting more than 30 sec for throttle above zero (after having been armed)
                        97     ;           Modified tail idling to provide option for very low speeds
                        98     ;           Changed PPM range to 1150-1830us
                        99     ;           Arming sequence is dropped for PPM input, unless it is governor arm mode
                       100     ;           Loss of input signal will immediately stop the motor for PPM input
                       101     ;           Bug corrected in Turnigy Plush 6A voltage measurement setup
                       102     ;           FET switching delays are set for original fets. Stronger/doubled/tripled etc fets may require faster pfet off switching
                       103     ;           Miscellaneous other changes
                       104     ; - Rev6.0: Reverted comparator reading routine to rev5.0 equivalent, in order to avoid tail motor stops
                       105     ;           Added governor range programmability
                       106     ;           Implemented startup retry sequence with varying startup power for multi mode
                       107     ;           In damped light mode, damping is now applied to the active nfet phase for fully damped capable ESCs
                       108     ; - Rev6.1: Added input signal qualification criteria for PPM, to avoid triggering on noise spikes (fix for plush hardware)
                       109     ;           Changed main and multi mode stop criteria. Will now be in run mode, even if RC pulse input is zero
                       110     ;           Fixed bug in commutation that caused rough running in damped light mode
                       111     ;           Miscellaneous other changes
                       112     ; - Rev7.0  Added direct startup mode programmability
                       113     ;           Added throttle calibration. Min>=1000us and Max<=2000us. Difference must be >520us, otherwise max is shifted so that difference=520us
                       114     ;           Added programmable throttle change rate
                       115     ;           Added programmable beep strength, beacon strength and beacon delay
                       116     ;           Reduced power step to full power significantly
                       117     ;           Miscellaneous other changes
                       118     ; - Rev8.0  Added a 2 second delay after power up, to wait for receiver initialization
                       119     ;           Added a programming option for disabling low voltage limit, and made it default for MULTI
                       120     ;           Added programable demag compensation, using the concept of SimonK
                       121     ;           Improved robustness against noisy input signal
                       122     ;           Refined direct startup
                       123     ;           Removed voltage compensation
                       124     ;           Miscellaneous other changes
                       125     ; - Rev9.0  Increased programming range for startup power, and made its default ESC dependent
                       126     ;           Made default startup method ESC dependent
                       127     ;           Even more smooth and gentle spoolup for MAIN, to suit larger helis
                       128     ;           Improved transition from stepped startup to run
                       129     ;           Refined direct startup
                       130     ; - Rev9.1  Fixed bug that changed FW revision after throttle calibration or TX programming
                       131     ; - Rev9.2  Altered timing of throttle calibration in order to work with MultiWii calibration firmware
                       132     ;           Reduced main spoolup time to around 5 seconds
                       133     ;           Changed default beacon delay to 3 minutes
                       134     ; - Rev9.3  Fixed bug in Plush 60/80A temperature reading, that caused failure in operation above 4S
                       135     ;           Corrected temperature limit for HiModel cool 22/33/41A, RCTimer 6A, Skywalker 20/40A, Turnigy AE45A, Plush 40/60/80A. Limit was previously set too high
                       136     ; - Rev9.4  Improved timing for increased maximum rpm limit
                       137     ; - Rev10.0 Added closed loop mode for multi
                       138     ;           Added high/low BEC voltage option (for the ESCs where HW supports it)
                       139     ;           Added method of resetting all programmed parameter values to defaults by TX programming
                       140     ;           Added Turnigy K-force 40A and Turnigy K-force 120A HV ESCs
                       141     ;           Enabled fully damped mode for several ESCs
                       142     ;           Extended startup power range downwards to enable very smooth start for large heli main motors
                       143     ;           Extended damping force with a highest setting
                       144     ;           Corrected temperature limits for F310 chips (Plush 40A and AE 45A)
                       145     ;           Implemented temperature reading average in order to avoid problems with ADC noise on Skywalkers
                       146     ;           Increased switching delays for XP 7A fast, in order to avoid cross conduction of N and P fets
                       147     ;           Miscellaneous other changes
                       148     ; - Rev10.1 Relaxed RC signal jitter requirement during frequency measurement
                       149     ;           Corrected bug that prevented using governor low
                       150     ;           Enabled vdd monitor always, in order to reduce likelihood of accidental overwriting of adjustments
                       151     ;           Fixed bug that caused stop for PPM input above 2048us, and moved upper accepted limit to 2160us
                       152     ; - Rev10.2 Corrected temperature limit for AE20-30/XP7-25, where limit was too high
                       153     ;           Corrected temperature limit for 120HV, where limit was too low
                       154     ;           Fixed bug that caused AE20/25/30A not to run in reverse
                       155     ; - Rev10.3 Removed vdd monitor for 1S capable ESCs, in order to avoid brownouts/resets
                       156     ;           Made auto bailout spoolup for main more smooth
                       157     ; - Rev10.4 Ensured that main spoolup and governor activation will always be smooth, regardless of throttle input
                       158     ;           Added capability to operate on 12kHz input signal too
                       159     ; - Rev11.0 Fixed bug of programming default values for governor in MULTI mode
                       160     ;           Disabled interrupts explicitly some places, to avoid possibilities for unintentional fet switching
                       161     ;           Changed interrupt disable strategy, to always allow pwm interrupts, to avoid noise when running at low rpms
                       162     ;           Added governor middle range for MAIN mode
                       163     ;           Added bidirectional mode for TAIL and MULTI mode with PPM input
                       164     ;           Changed and improved demag compensation
                       165     ;           Miscellaneous other changes
                       166     ; - Rev11.1 Fixed bug of slow acceleration response for MAIN mode running without governor
                       167     ;           Fixed bug with PWM input, where throttle remains high even when zeroing throttle (seen on V922 tail)
                       168     ;           Fixed bug in bidirectional operation, where direction change could cause reset
                       169     ;           Improved autorotation bailout for MAIN
                       170     ;           Reduced min speed back to 1220 erpm
                       171     ;           Misc code cleanups
                       172     ; - Rev11.2 Fixed throttle calibration bug
                       173     ;           Added high side driver precharge for all-nfet ESCs
                       174     ;           Optimized timing in general and for demag compensation in particular
                       175     ;           Auto bailout functionality modified
                       176     ;           Governor is deactivated for throttle inputs below 10%
                       177     ;           Increased beacon delay times
                       178     ; - Rev12.0 Added programmable main spoolup time
                       179     ;           Added programmable temperature protection enable
                       180     ;           Bidirectional mode stop/start improved. Motor is now stopped before starting
                       181     ;           Power is limited for very low rpms (when BEMF is low), in order to avoid sync loss 
                       182     ;           Damped light mode is made more smooth and quiet, particularly at low and high rpms
                       183     ;           Comparator signal qualification scheme is changed
                       184     ;           Demag compensation scheme is significantly changed
                       185     ;           Increased jitter tolerance for PPM frequency measurement
                       186     ;           Fully damped mode removed, and damped light only supported on damped capable ESCs
                       187     ;           Default tail mode changed to damped light
                       188     ;           Miscellaneous other changes
                       189     ; - Rev12.1 Fixed bug in tail code
                       190     ;           Improved startup for Atmel
                       191     ;           Added support for multiple high BEC voltages
                       192     ;           Added support for RPM output
                       193     ; - Rev12.2 Improved running smoothness, particularly for damped light
                       194     ;           Avoiding lockup at full throttle when input signal is noisy
                       195     ;           Avoiding detection of 1-wire programming signal as valid throttle signal
                       196     ; - Rev13.0 Removed stepped start
                       197     ;           Removed throttle change rate and damping force parameters
                       198     ;           Added support for OneShot125
                       199     ;           Improved commutation timing accuracy
                       200     ; - Rev13.1 Removed startup ramp for MULTI
                       201     ;           Improved startup for some odd ESCs
                       202     ; - Rev13.2 Still tweaking startup to make it more reliable and faster for all ESC/motor combos
                       203     ;           Increased deadband for bidirectional operation
                       204     ;           Relaxed signal detection criteria
                       205     ;           Added support for running 48MHz capable SiLabs MCUs at 48MHz
                       206     ;           Added bootlader to SiLabs code
                       207     ;           Miscellaneous other changes
                       208     ; - Rev14.0 Improved running at high timing
                       209     ;           Improved running at high RPMs and increased max RPM limit
                       210     ;           Avoid being locked in bootloader (implemented in Suite 13202)
                       211     ;           Improved reliability of 3D (bidirectional) mode and startup
                       212     ;           Smoother running and greatly reduced step to full power in damped light mode
                       213     ;           Removed low voltage limiting for MULTI
                       214     ;           Added pwm dither parameter
                       215     ;           Added setting for enable/disable of low RPM power protection
                       216     ;           Added setting for enable/disable of PWM input
                       217     ;           Better AFW and damping for some ESCs (that have a slow high side driver)
                       218     ;           Miscellaneous other changes
                       219     ; - Rev14.1 Fixed max throttle calibration bug (for non-oneshot)
                       220     ;           Fixed some closed loop mode bugs
                       221     ;           Relaxed signal jitter requirement for looptimes below 1000
                       222     ;           Added skipping of damping fet switching near max power, for improved high end throttle linearity, using the concept of SimonK
                       223     ;           Improved sync hold at high rpms
                       224     ; - Rev14.2 Added stalled motor shutoff after about 10 seconds (for tail and multi code with PPM input)
                       225     ;           Greatly increased maximum rpm limit, and added rpm limiting at 250k erpm (48MHz MCUs at 400k erpm)
                       226     ;           Improved bidirectional operation
                       227     ; - Rev14.3 Moved reset vector to be just before the settings segment, in order to better recover from partially failed flashing operation
                       228     ;           Added 100ms intialization delay for the Graupner Ultra 20A ESC
                       229     ;           Shortened stall detect time to about 5sec, and prevented going into tx programming after a stall
                       230     ;           Optimizations of software timing and running reliability
                       231     ; - Rev14.4 Improved startup, particularly for larger motors
                       232     ;           Improved running at very high rpms
                       233     ;           Made damped light default for MULTI on ESCs that support it
                       234     ;           Miscellaneous other changes
                       235     ; - Rev14.5 Longer between beacon beeps (to reduce motor heating), and now again beeping on two motor phases
                       236     ;           Implemented programmable brake on zero throttle
                       237     ;           Implemented hardware reload of commutation timers, to reduce sensitivity to interrupt activity on high rpms
                       238     ;           Implemented support for EN/PWM style fet drivers
                       239     ;           Slightly modified throttle calibration
                       240     ;           Improved startup, particularly for small motors
                       241     ;           Improved smoothness
                       242     ; - Rev14.6 Fixed bug that caused tail motor not to stop
                       243     ;           Fixed bug that caused brake not to work for low side pwm ESCs
                       244     ;           Fixed bug where noisy input signal could cause loss of sync
                       245     ;           Increased fet deadtime a bit for the LB20A and the LB20A pro
                       246     ;           Made low rpm power limiting programmable through the startup power parameter
                       247     ; - Rev14.7 Beeps can be turned off by programming beep strength to 1
                       248     ;           Throttle cal difference is checked to be above required minimum before storing. Throttle cal max is not stored until successful min throttle cal
                       249     ;           In order to have a good code for fixed wing planes, that has low voltage limiting, a main code spoolup time setting of 0 is made fast
                       250     ;           Improved protection of bootloader and generally reduced risk of flash corruption
                       251     ;           Some small changes for improved sync hold
                       252     ;	-Rev14.75 Modified input signal accept Multishot protocol
                       253     ;						Changed Defaults to more acceptable/appropriate values	
                       254     ;						Added music routine and changed startup tone to "Imperial March"
                       255     ;
                       256     ;**** **** **** **** ****
                       257     ; Up to 8K Bytes of In-System Self-Programmable Flash
                       258     ; Up to 768 Bytes Internal SRAM
                       259     ;
                       260     ;**** **** **** **** ****
                       261     ; Master clock is internal 24MHz oscillator (or 48MHz, for which the times below are halved)
                       262     ; Timer 0 (167/500ns counts) always counts up and is used for
                       263     ; - PWM generation
                       264     ; Timer 2 (500ns counts) always counts up and is used for
                       265     ; - RC pulse timeout/skip counts and commutation times
                       266     ; Timer 3 (500ns counts) always counts up and is used for
                       267     ; - Commutation timeouts
                       268     ; PCA0 (500ns counts) always counts up and is used for
                       269     ; - RC pulse measurement
                       270     ;
                       271     ;**** **** **** **** ****
                       272     ; Interrupt handling
                       273     ; The C8051 does not disable interrupts when entering an interrupt routine.
                       274     ; Also some interrupt flags need to be cleared by software
                       275     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                       276     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                       277     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                       278     ;
                       279     ;**** **** **** **** ****
                       280     ; Motor control:
                       281     ; - Brushless motor control with 6 states for each electrical 360 degrees
                       282     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                       283     ; - Timing advance in this implementation is set to 15deg nominally
                       284     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                       285     ; Motor sequence starting from zero crossing:
                       286     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                       287     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                       288     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                       289     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                       290     ;
                       291     ; Motor startup:
                       292     ; There is a startup phase and an initial run phase, before normal bemf commutation run begins.
                       293     ;
                       294     ;**** **** **** **** ****
                       295     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0001                 296     XP_3A_MAIN 					EQU 1
  0002                 297     XP_3A_TAIL 					EQU 2
  0003                 298     XP_3A_MULTI 					EQU 3
  0004                 299     XP_7A_MAIN 					EQU 4
  0005                 300     XP_7A_TAIL 					EQU 5
  0006                 301     XP_7A_MULTI 					EQU 6
  0007                 302     XP_7A_FAST_MAIN 				EQU 7
  0008                 303     XP_7A_FAST_TAIL 				EQU 8
  0009                 304     XP_7A_FAST_MULTI 				EQU 9
  000A                 305     XP_12A_MAIN 					EQU 10
  000B                 306     XP_12A_TAIL 					EQU 11
  000C                 307     XP_12A_MULTI 					EQU 12
  000D                 308     XP_18A_MAIN 					EQU 13
  000E                 309     XP_18A_TAIL 					EQU 14
  000F                 310     XP_18A_MULTI 					EQU 15
  0010                 311     XP_25A_MAIN 					EQU 16
  0011                 312     XP_25A_TAIL 					EQU 17
  0012                 313     XP_25A_MULTI 					EQU 18
  0013                 314     XP_35A_SW_MAIN 				EQU 19
  0014                 315     XP_35A_SW_TAIL 				EQU 20
  0015                 316     XP_35A_SW_MULTI 				EQU 21
  0016                 317     DP_3A_MAIN 					EQU 22
  0017                 318     DP_3A_TAIL  					EQU 23
  0018                 319     DP_3A_MULTI  					EQU 24
  0019                 320     SUPERMICRO_3P5A_MAIN 			EQU 25
  001A                 321     SUPERMICRO_3P5A_TAIL 			EQU 26   
  001B                 322     SUPERMICRO_3P5A_MULTI 			EQU 27   
  001C                 323     TURNIGY_PLUSH_6A_MAIN 			EQU 28
  001D                 324     TURNIGY_PLUSH_6A_TAIL 			EQU 29   
  001E                 325     TURNIGY_PLUSH_6A_MULTI 			EQU 30   
  001F                 326     TURNIGY_PLUSH_10A_MAIN 			EQU 31
  0020                 327     TURNIGY_PLUSH_10A_TAIL 			EQU 32   
  0021                 328     TURNIGY_PLUSH_10A_MULTI 			EQU 33   
  0022                 329     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                 330     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                 331     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  0025                 332     TURNIGY_PLUSH_18A_MAIN 			EQU 37
  0026                 333     TURNIGY_PLUSH_18A_TAIL 			EQU 38   
  0027                 334     TURNIGY_PLUSH_18A_MULTI 			EQU 39   
  0028                 335     TURNIGY_PLUSH_25A_MAIN 			EQU 40
  0029                 336     TURNIGY_PLUSH_25A_TAIL 			EQU 41   
  002A                 337     TURNIGY_PLUSH_25A_MULTI 			EQU 42   
  002B                 338     TURNIGY_PLUSH_30A_MAIN 			EQU 43
  002C                 339     TURNIGY_PLUSH_30A_TAIL 			EQU 44   
  002D                 340     TURNIGY_PLUSH_30A_MULTI 			EQU 45   
  002E                 341     TURNIGY_PLUSH_40A_MAIN 			EQU 46
  002F                 342     TURNIGY_PLUSH_40A_TAIL 			EQU 47   
  0030                 343     TURNIGY_PLUSH_40A_MULTI 			EQU 48   
  0031                 344     TURNIGY_PLUSH_60A_MAIN 			EQU 49
  0032                 345     TURNIGY_PLUSH_60A_TAIL 			EQU 50   
  0033                 346     TURNIGY_PLUSH_60A_MULTI 			EQU 51   
  0034                 347     TURNIGY_PLUSH_80A_MAIN 			EQU 52
  0035                 348     TURNIGY_PLUSH_80A_TAIL 			EQU 53   
  0036                 349     TURNIGY_PLUSH_80A_MULTI 			EQU 54   
  0037                 350     TURNIGY_PLUSH_NFET_18A_MAIN 		EQU 55
  0038                 351     TURNIGY_PLUSH_NFET_18A_TAIL 		EQU 56   
  0039                 352     TURNIGY_PLUSH_NFET_18A_MULTI 		EQU 57   
  003A                 353     TURNIGY_PLUSH_NFET_25A_MAIN 		EQU 58
  003B                 354     TURNIGY_PLUSH_NFET_25A_TAIL 		EQU 59   
  003C                 355     TURNIGY_PLUSH_NFET_25A_MULTI 		EQU 60   
  003D                 356     TURNIGY_PLUSH_NFET_30A_MAIN 		EQU 61
  003E                 357     TURNIGY_PLUSH_NFET_30A_TAIL 		EQU 62   
  003F                 358     TURNIGY_PLUSH_NFET_30A_MULTI 		EQU 63   
  0040                 359     TURNIGY_AE_20A_MAIN 			EQU 64
  0041                 360     TURNIGY_AE_20A_TAIL 			EQU 65   
  0042                 361     TURNIGY_AE_20A_MULTI 			EQU 66   
  0043                 362     TURNIGY_AE_25A_MAIN 			EQU 67
  0044                 363     TURNIGY_AE_25A_TAIL 			EQU 68   
  0045                 364     TURNIGY_AE_25A_MULTI 			EQU 69   
  0046                 365     TURNIGY_AE_30A_MAIN 			EQU 70
  0047                 366     TURNIGY_AE_30A_TAIL 			EQU 71   
  0048                 367     TURNIGY_AE_30A_MULTI 			EQU 72   
  0049                 368     TURNIGY_AE_45A_MAIN 			EQU 73
  004A                 369     TURNIGY_AE_45A_TAIL 			EQU 74   
  004B                 370     TURNIGY_AE_45A_MULTI 			EQU 75   
  004C                 371     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                 372     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                 373     TURNIGY_KFORCE_40A_MULTI 		EQU 78   
  004F                 374     TURNIGY_KFORCE_70A_HV_MAIN 		EQU 79   
  0050                 375     TURNIGY_KFORCE_70A_HV_TAIL 		EQU 80   
  0051                 376     TURNIGY_KFORCE_70A_HV_MULTI 		EQU 81   
  0052                 377     TURNIGY_KFORCE_120A_HV_MAIN 		EQU 82   
  0053                 378     TURNIGY_KFORCE_120A_HV_TAIL 		EQU 83   
  0054                 379     TURNIGY_KFORCE_120A_HV_MULTI 		EQU 84   
  0055                 380     TURNIGY_KFORCE_120A_HV_V2_MAIN	EQU 85   
  0056                 381     TURNIGY_KFORCE_120A_HV_V2_TAIL 	EQU 86   
  0057                 382     TURNIGY_KFORCE_120A_HV_V2_MULTI 	EQU 87   
  0058                 383     SKYWALKER_20A_MAIN 				EQU 88
  0059                 384     SKYWALKER_20A_TAIL 				EQU 89   
  005A                 385     SKYWALKER_20A_MULTI 			EQU 90   
  005B                 386     SKYWALKER_40A_MAIN 				EQU 91
  005C                 387     SKYWALKER_40A_TAIL 				EQU 92   
  005D                 388     SKYWALKER_40A_MULTI 			EQU 93   
  005E                 389     HIMODEL_COOL_22A_MAIN 			EQU 94
  005F                 390     HIMODEL_COOL_22A_TAIL 			EQU 95   
  0060                 391     HIMODEL_COOL_22A_MULTI 			EQU 96   
  0061                 392     HIMODEL_COOL_33A_MAIN 			EQU 97
  0062                 393     HIMODEL_COOL_33A_TAIL 			EQU 98   
  0063                 394     HIMODEL_COOL_33A_MULTI 			EQU 99  
  0064                 395     HIMODEL_COOL_41A_MAIN 			EQU 100
  0065                 396     HIMODEL_COOL_41A_TAIL 			EQU 101  
  0066                 397     HIMODEL_COOL_41A_MULTI 			EQU 102  
  0067                 398     RCTIMER_6A_MAIN 				EQU 103   
  0068                 399     RCTIMER_6A_TAIL 				EQU 104  
  0069                 400     RCTIMER_6A_MULTI 				EQU 105  
  006A                 401     ALIGN_RCE_BL15X_MAIN			EQU 106   
  006B                 402     ALIGN_RCE_BL15X_TAIL 			EQU 107  
  006C                 403     ALIGN_RCE_BL15X_MULTI 			EQU 108  
  006D                 404     ALIGN_RCE_BL15P_MAIN			EQU 109  
  006E                 405     ALIGN_RCE_BL15P_TAIL 			EQU 110  
  006F                 406     ALIGN_RCE_BL15P_MULTI 			EQU 111  
  0070                 407     ALIGN_RCE_BL35X_MAIN			EQU 112  
  0071                 408     ALIGN_RCE_BL35X_TAIL 			EQU 113  
  0072                 409     ALIGN_RCE_BL35X_MULTI 			EQU 114  
  0073                 410     ALIGN_RCE_BL35P_MAIN			EQU 115   
  0074                 411     ALIGN_RCE_BL35P_TAIL 			EQU 116  
  0075                 412     ALIGN_RCE_BL35P_MULTI 			EQU 117  
  0076                 413     GAUI_GE_183_18A_MAIN			EQU 118   
  0077                 414     GAUI_GE_183_18A_TAIL 			EQU 119  
  0078                 415     GAUI_GE_183_18A_MULTI 			EQU 120  
  0079                 416     H_KING_10A_MAIN				EQU 121   
  007A                 417     H_KING_10A_TAIL 				EQU 122  
  007B                 418     H_KING_10A_MULTI 				EQU 123  
  007C                 419     H_KING_20A_MAIN				EQU 124   
  007D                 420     H_KING_20A_TAIL 				EQU 125  
  007E                 421     H_KING_20A_MULTI 				EQU 126  
  007F                 422     H_KING_35A_MAIN				EQU 127   
  0080                 423     H_KING_35A_TAIL 				EQU 128 
  0081                 424     H_KING_35A_MULTI 				EQU 129  
  0082                 425     H_KING_50A_MAIN				EQU 130   
  0083                 426     H_KING_50A_TAIL 				EQU 131  
  0084                 427     H_KING_50A_MULTI 				EQU 132  
  0085                 428     POLARIS_THUNDER_12A_MAIN			EQU 133   
  0086                 429     POLARIS_THUNDER_12A_TAIL 		EQU 134  
  0087                 430     POLARIS_THUNDER_12A_MULTI 		EQU 135  
  0088                 431     POLARIS_THUNDER_20A_MAIN			EQU 136   
  0089                 432     POLARIS_THUNDER_20A_TAIL 		EQU 137  
  008A                 433     POLARIS_THUNDER_20A_MULTI 		EQU 138  
  008B                 434     POLARIS_THUNDER_30A_MAIN			EQU 139   
  008C                 435     POLARIS_THUNDER_30A_TAIL 		EQU 140  
  008D                 436     POLARIS_THUNDER_30A_MULTI 		EQU 141  
  008E                 437     POLARIS_THUNDER_40A_MAIN			EQU 142   
  008F                 438     POLARIS_THUNDER_40A_TAIL 		EQU 143  
  0090                 439     POLARIS_THUNDER_40A_MULTI 		EQU 144  
  0091                 440     POLARIS_THUNDER_60A_MAIN			EQU 145   
  0092                 441     POLARIS_THUNDER_60A_TAIL 		EQU 146  
  0093                 442     POLARIS_THUNDER_60A_MULTI 		EQU 147  
  0094                 443     POLARIS_THUNDER_80A_MAIN			EQU 148   
  0095                 444     POLARIS_THUNDER_80A_TAIL 		EQU 149  
  0096                 445     POLARIS_THUNDER_80A_MULTI 		EQU 150  
  0097                 446     POLARIS_THUNDER_100A_MAIN		EQU 151   
  0098                 447     POLARIS_THUNDER_100A_TAIL 		EQU 152  
  0099                 448     POLARIS_THUNDER_100A_MULTI 		EQU 153  
  009A                 449     PLATINUM_PRO_30A_MAIN			EQU 154   
  009B                 450     PLATINUM_PRO_30A_TAIL 			EQU 155  
  009C                 451     PLATINUM_PRO_30A_MULTI 			EQU 156  
  009D                 452     PLATINUM_PRO_150A_MAIN			EQU 157   
  009E                 453     PLATINUM_PRO_150A_TAIL 			EQU 158  
  009F                 454     PLATINUM_PRO_150A_MULTI 			EQU 159  
  00A0                 455     PLATINUM_50AV3_MAIN				EQU 160   
  00A1                 456     PLATINUM_50AV3_TAIL 			EQU 161  
  00A2                 457     PLATINUM_50AV3_MULTI 			EQU 162  
  00A3                 458     EAZY_3AV2_MAIN					EQU 163   
  00A4                 459     EAZY_3AV2_TAIL 				EQU 164  
  00A5                 460     EAZY_3AV2_MULTI 				EQU 165  
  00A6                 461     TAROT_30A_MAIN					EQU 166   
  00A7                 462     TAROT_30A_TAIL 				EQU 167  
  00A8                 463     TAROT_30A_MULTI 				EQU 168  
  00A9                 464     SKYIII_30A_MAIN				EQU 169   
  00AA                 465     SKYIII_30A_TAIL 				EQU 170  
  00AB                 466     SKYIII_30A_MULTI 				EQU 171  
  00AC                 467     EMAX_20A_MAIN					EQU 172   
  00AD                 468     EMAX_20A_TAIL 					EQU 173  
  00AE                 469     EMAX_20A_MULTI 				EQU 174  
  00AF                 470     EMAX_40A_MAIN					EQU 175   
  00B0                 471     EMAX_40A_TAIL 					EQU 176  
  00B1                 472     EMAX_40A_MULTI 				EQU 177  
  00B2                 473     EMAX_NANO_20A_MAIN				EQU 178   
  00B3                 474     EMAX_NANO_20A_TAIL 				EQU 179  
  00B4                 475     EMAX_NANO_20A_MULTI 			EQU 180  
  00B5                 476     EMAX_LIGHTNING_20A_MAIN			EQU 181   
  00B6                 477     EMAX_LIGHTNING_20A_TAIL 			EQU 182  
  00B7                 478     EMAX_LIGHTNING_20A_MULTI 		EQU 183  
  00B8                 479     XROTOR_10A_MAIN				EQU 184   
  00B9                 480     XROTOR_10A_TAIL 				EQU 185  
  00BA                 481     XROTOR_10A_MULTI 				EQU 186  
  00BB                 482     XROTOR_20A_MAIN				EQU 187   
  00BC                 483     XROTOR_20A_TAIL 				EQU 188  
  00BD                 484     XROTOR_20A_MULTI 				EQU 189  
  00BE                 485     XROTOR_40A_MAIN				EQU 190   
  00BF                 486     XROTOR_40A_TAIL 				EQU 191  
  00C0                 487     XROTOR_40A_MULTI 				EQU 192  
  00C1                 488     MDRX62H_MAIN					EQU 193   
  00C2                 489     MDRX62H_TAIL 					EQU 194  
  00C3                 490     MDRX62H_MULTI 					EQU 195  
  00C4                 491     ROTORGEEKS_20A_MAIN				EQU 196   
  00C5                 492     ROTORGEEKS_20A_TAIL 			EQU 197  
  00C6                 493     ROTORGEEKS_20A_MULTI 			EQU 198  
  00C7                 494     ROTORGEEKS_20A_PLUS_MAIN			EQU 199   
  00C8                 495     ROTORGEEKS_20A_PLUS_TAIL 		EQU 200  
  00C9                 496     ROTORGEEKS_20A_PLUS_MULTI 		EQU 201  
  00CA                 497     FLYCOLOR_FAIRY_6A_MAIN			EQU 202   
  00CB                 498     FLYCOLOR_FAIRY_6A_TAIL 			EQU 203  
  00CC                 499     FLYCOLOR_FAIRY_6A_MULTI 			EQU 204  
  00CD                 500     FLYCOLOR_FAIRY_30A_MAIN			EQU 205   
  00CE                 501     FLYCOLOR_FAIRY_30A_TAIL 			EQU 206  
  00CF                 502     FLYCOLOR_FAIRY_30A_MULTI 		EQU 207  
  00D0                 503     FLYCOLOR_FAIRY_V2_30A_MAIN		EQU 208
  00D1                 504     FLYCOLOR_FAIRY_V2_30A_TAIL 		EQU 209  
  00D2                 505     FLYCOLOR_FAIRY_V2_30A_MULTI 		EQU 210 
  00D3                 506     FLYCOLOR_RAPTOR_20A_MAIN			EQU 211   
  00D4                 507     FLYCOLOR_RAPTOR_20A_TAIL 		EQU 212  
  00D5                 508     FLYCOLOR_RAPTOR_20A_MULTI 		EQU 213  
  00D6                 509     FLYCOLOR_RAPTOR_390_20A_MAIN		EQU 214
  00D7                 510     FLYCOLOR_RAPTOR_390_20A_TAIL 		EQU 215  
  00D8                 511     FLYCOLOR_RAPTOR_390_20A_MULTI 	EQU 216  
  00D9                 512     FVT_LITTLEBEE_12A_MAIN			EQU 217  
  00DA                 513     FVT_LITTLEBEE_12A_TAIL			EQU 218  
  00DB                 514     FVT_LITTLEBEE_12A_MULTI			EQU 219  
  00DC                 515     FVT_LITTLEBEE_20A_MAIN			EQU 220  
  00DD                 516     FVT_LITTLEBEE_20A_TAIL			EQU 221  
  00DE                 517     FVT_LITTLEBEE_20A_MULTI			EQU 222  
  00DF                 518     FVT_LITTLEBEE_20A_PRO_MAIN		EQU 223  
  00E0                 519     FVT_LITTLEBEE_20A_PRO_TAIL		EQU 224  
  00E1                 520     FVT_LITTLEBEE_20A_PRO_MULTI		EQU 225  
  00E2                 521     FVT_LITTLEBEE_30A_MAIN			EQU 226  
  00E3                 522     FVT_LITTLEBEE_30A_TAIL			EQU 227  
  00E4                 523     FVT_LITTLEBEE_30A_MULTI			EQU 228  
  00E5                 524     GRAUPNER_ULTRA_20A_MAIN			EQU 229  
  00E6                 525     GRAUPNER_ULTRA_20A_TAIL			EQU 230  
  00E7                 526     GRAUPNER_ULTRA_20A_MULTI			EQU 231  
  00E8                 527     F85_3A_MAIN					EQU 232  
  00E9                 528     F85_3A_TAIL					EQU 233  
  00EA                 529     F85_3A_MULTI					EQU 234  
  00EB                 530     ZTW_SPIDER_PRO_20A_MAIN			EQU 235  
  00EC                 531     ZTW_SPIDER_PRO_20A_TAIL			EQU 236  
  00ED                 532     ZTW_SPIDER_PRO_20A_MULTI			EQU 237  
  00EE                 533     ZTW_SPIDER_PRO_20A_PREMIUM_MAIN	EQU 238  
  00EF                 534     ZTW_SPIDER_PRO_20A_PREMIUM_TAIL	EQU 239  
  00F0                 535     ZTW_SPIDER_PRO_20A_PREMIUM_MULTI	EQU 240  
  00F1                 536     ZTW_SPIDER_PRO_20A_HV_MAIN		EQU 241  
  00F2                 537     ZTW_SPIDER_PRO_20A_HV_TAIL		EQU 242  
  00F3                 538     ZTW_SPIDER_PRO_20A_HV_MULTI		EQU 243  
  00F4                 539     ZTW_SPIDER_PRO_30A_HV_MAIN		EQU 244  
  00F5                 540     ZTW_SPIDER_PRO_30A_HV_TAIL		EQU 245  
  00F6                 541     ZTW_SPIDER_PRO_30A_HV_MULTI		EQU 246  
  00F7                 542     DYS_XM20A_MAIN					EQU 247  
  00F8                 543     DYS_XM20A_TAIL					EQU 248  
  00F9                 544     DYS_XM20A_MULTI				EQU 249  
  00FA                 545     OVERSKY_MR_20A_MAIN				EQU 250  
  00FB                 546     OVERSKY_MR_20A_TAIL				EQU 251  
  00FC                 547     OVERSKY_MR_20A_MULTI			EQU 252  
  00FD                 548     OVERSKY_MR_20A_PRO_MAIN			EQU 253  
  00FE                 549     OVERSKY_MR_20A_PRO_TAIL			EQU 254  
  00FF                 550     OVERSKY_MR_20A_PRO_MULTI			EQU 255  
  0100                 551     TBS_CUBE_12A_MAIN				EQU 256 
  0101                 552     TBS_CUBE_12A_TAIL				EQU 257  
  0102                 553     TBS_CUBE_12A_MULTI				EQU 258  
  0103                 554     DALRC_XR20A_MAIN				EQU 259  
  0104                 555     DALRC_XR20A_TAIL				EQU 260  
  0105                 556     DALRC_XR20A_MULTI				EQU 261  
  0106                 557     AIKON_BOLTLITE_30A_MAIN			EQU 262  
  0107                 558     AIKON_BOLTLITE_30A_TAIL			EQU 263  
  0108                 559     AIKON_BOLTLITE_30A_MULTI			EQU 264
  0109                 560     ALIGN_MR25_15A_MAIN				EQU 265   
  010A                 561     ALIGN_MR25_15A_TAIL 			EQU 266  
  010B                 562     ALIGN_MR25_15A_MULTI 			EQU 267   
  010C                 563     SERVOKING_MONSTER_30A_MAIN		EQU 268   
  010D                 564     SERVOKING_MONSTER_30A_TAIL 		EQU 269  
  010E                 565     SERVOKING_MONSTER_30A_MULTI 		EQU 270   
  010F                 566     SERVOKING_MONSTER_30A_PRO_MAIN	EQU 271   
  0110                 567     SERVOKING_MONSTER_30A_PRO_TAIL	EQU 272  
  0111                 568     SERVOKING_MONSTER_30A_PRO_MULTI	EQU 273   
  0112                 569     SERVOKING_MONSTER_80A_MAIN		EQU 274   
  0113                 570     SERVOKING_MONSTER_80A_TAIL 		EQU 275  
  0114                 571     SERVOKING_MONSTER_80A_MULTI 		EQU 276   
  0115                 572     HTIRC_HUMMINGBIRD_12A_MAIN		EQU 277   
  0116                 573     HTIRC_HUMMINGBIRD_12A_TAIL 		EQU 278  
  0117                 574     HTIRC_HUMMINGBIRD_12A_MULTI 		EQU 279   
  0118                 575     HTIRC_HUMMINGBIRD_20A_MAIN		EQU 280   
  0119                 576     HTIRC_HUMMINGBIRD_20A_TAIL 		EQU 281  
  011A                 577     HTIRC_HUMMINGBIRD_20A_MULTI 		EQU 282   
  011B                 578     HTIRC_HUMMINGBIRD_30A_PRO_MAIN	EQU 283   
  011C                 579     HTIRC_HUMMINGBIRD_30A_PRO_TAIL	EQU 284  
  011D                 580     HTIRC_HUMMINGBIRD_30A_PRO_MULTI	EQU 285   
                       581       
                       582     
                       583     
                       584     ;**** **** **** **** ****
                       585     ; Select the ESC and mode to use (or unselect all for use with external batch compile file)
                       586     ;BESCNO EQU XP_3A_Main 
                       587     ;BESCNO EQU XP_3A_Tail
                       588     ;BESCNO EQU XP_3A_Multi
                       589     ;BESCNO EQU XP_7A_Main
                       590     ;BESCNO EQU XP_7A_Tail
                       591     ;BESCNO EQU XP_7A_Multi 	
                       592     ;BESCNO EQU XP_7A_Fast_Main
                       593     ;BESCNO EQU XP_7A_Fast_Tail
                       594     ;BESCNO EQU XP_7A_Fast_Multi
                       595     ;BESCNO EQU XP_12A_Main
                       596     ;BESCNO EQU XP_12A_Tail 
                       597     ;BESCNO EQU XP_12A_Multi
                       598     ;BESCNO EQU XP_18A_Main 
                       599     ;BESCNO EQU XP_18A_Tail 
                       600     ;BESCNO EQU XP_18A_Multi
                       601     ;BESCNO EQU XP_25A_Main 
                       602     ;BESCNO EQU XP_25A_Tail 
                       603     ;BESCNO EQU XP_25A_Multi
                       604     ;BESCNO EQU XP_35A_SW_Main
                       605     ;BESCNO EQU XP_35A_SW_Tail 
                       606     ;BESCNO EQU XP_35A_SW_Multi
                       607     ;BESCNO EQU DP_3A_Main 						
                       608     ;BESCNO EQU DP_3A_Tail 
                       609     ;BESCNO EQU DP_3A_Multi 
                       610     ;BESCNO EQU Supermicro_3p5A_Main
                       611     ;BESCNO EQU Supermicro_3p5A_Tail 
                       612     ;BESCNO EQU Supermicro_3p5A_Multi
                       613     ;BESCNO EQU Turnigy_Plush_6A_Main 
                       614     ;BESCNO EQU Turnigy_Plush_6A_Tail 
                       615     ;BESCNO EQU Turnigy_Plush_6A_Multi
                       616     ;BESCNO EQU Turnigy_Plush_10A_Main 
                       617     ;BESCNO EQU Turnigy_Plush_10A_Tail 
                       618     ;BESCNO EQU Turnigy_Plush_10A_Multi
                       619     ;BESCNO EQU Turnigy_Plush_12A_Main 
                       620     ;BESCNO EQU Turnigy_Plush_12A_Tail 
                       621     ;BESCNO EQU Turnigy_Plush_12A_Multi 
                       622     ;BESCNO EQU Turnigy_Plush_18A_Main 
                       623     ;BESCNO EQU Turnigy_Plush_18A_Tail 
                       624     ;BESCNO EQU Turnigy_Plush_18A_Multi
                       625     ;BESCNO EQU Turnigy_Plush_25A_Main 
                       626     ;BESCNO EQU Turnigy_Plush_25A_Tail
                       627     ;BESCNO EQU Turnigy_Plush_25A_Multi
                       628     ;BESCNO EQU Turnigy_Plush_30A_Main 
                       629     ;BESCNO EQU Turnigy_Plush_30A_Tail 
                       630     ;BESCNO EQU Turnigy_Plush_30A_Multi
                       631     ;BESCNO EQU Turnigy_Plush_40A_Main 
                       632     ;BESCNO EQU Turnigy_Plush_40A_Tail 
                       633     ;BESCNO EQU Turnigy_Plush_40A_Multi 
                       634     ;BESCNO EQU Turnigy_Plush_60A_Main
                       635     ;BESCNO EQU Turnigy_Plush_60A_Tail 
                       636     ;BESCNO EQU Turnigy_Plush_60A_Multi
                       637     ;BESCNO EQU Turnigy_Plush_80A_Main
                       638     ;BESCNO EQU Turnigy_Plush_80A_Tail 
                       639     ;BESCNO EQU Turnigy_Plush_80A_Multi
                       640     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Main
                       641     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Tail 
                       642     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Multi 
                       643     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Main 
                       644     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Tail
                       645     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Multi
                       646     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Main  
                       647     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Tail 
                       648     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Multi
                       649     ;BESCNO EQU Turnigy_AE_20A_Main 
                       650     ;BESCNO EQU Turnigy_AE_20A_Tail 
                       651     ;BESCNO EQU Turnigy_AE_20A_Multi
                       652     ;BESCNO EQU Turnigy_AE_25A_Main 
                       653     ;BESCNO EQU Turnigy_AE_25A_Tail 
                       654     ;BESCNO EQU Turnigy_AE_25A_Multi
                       655     ;BESCNO EQU Turnigy_AE_30A_Main 
                       656     ;BESCNO EQU Turnigy_AE_30A_Tail 
                       657     ;BESCNO EQU Turnigy_AE_30A_Multi
                       658     ;BESCNO EQU Turnigy_AE_45A_Main
                       659     ;BESCNO EQU Turnigy_AE_45A_Tail 
                       660     ;BESCNO EQU Turnigy_AE_45A_Multi
                       661     ;BESCNO EQU Turnigy_KForce_40A_Main
                       662     ;BESCNO EQU Turnigy_KForce_40A_Tail 
                       663     ;BESCNO EQU Turnigy_KForce_40A_Multi 
                       664     ;BESCNO EQU Turnigy_KForce_70A_HV_Main
                       665     ;BESCNO EQU Turnigy_KForce_70A_HV_Tail 
                       666     ;BESCNO EQU Turnigy_KForce_70A_HV_Multi
                       667     ;BESCNO EQU Turnigy_KForce_120A_HV_Main
                       668     ;BESCNO EQU Turnigy_KForce_120A_HV_Tail 
                       669     ;BESCNO EQU Turnigy_KForce_120A_HV_Multi
                       670     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Main
                       671     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Tail 
                       672     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Multi
                       673     ;BESCNO EQU Skywalker_20A_Main
                       674     ;BESCNO EQU Skywalker_20A_Tail
                       675     ;BESCNO EQU Skywalker_20A_Multi 
                       676     ;BESCNO EQU Skywalker_40A_Main 
                       677     ;BESCNO EQU Skywalker_40A_Tail 
                       678     ;BESCNO EQU Skywalker_40A_Multi
                       679     ;BESCNO EQU HiModel_Cool_22A_Main
                       680     ;BESCNO EQU HiModel_Cool_22A_Tail
                       681     ;BESCNO EQU HiModel_Cool_22A_Multi
                       682     ;BESCNO EQU HiModel_Cool_33A_Main
                       683     ;BESCNO EQU HiModel_Cool_33A_Tail
                       684     ;BESCNO EQU HiModel_Cool_33A_Multi
                       685     ;BESCNO EQU HiModel_Cool_41A_Main
                       686     ;BESCNO EQU HiModel_Cool_41A_Tail
                       687     ;BESCNO EQU HiModel_Cool_41A_Multi
                       688     ;BESCNO EQU RCTimer_6A_Main
                       689     ;BESCNO EQU RCTimer_6A_Tail
                       690     ;BESCNO EQU RCTimer_6A_Multi
                       691     ;BESCNO EQU Align_RCE_BL15X_Main
                       692     ;BESCNO EQU Align_RCE_BL15X_Tail
                       693     ;BESCNO EQU Align_RCE_BL15X_Multi
                       694     ;BESCNO EQU Align_RCE_BL15P_Main
                       695     ;BESCNO EQU Align_RCE_BL15P_Tail
                       696     ;BESCNO EQU Align_RCE_BL15P_Multi 
                       697     ;BESCNO EQU Align_RCE_BL35X_Main 
                       698     ;BESCNO EQU Align_RCE_BL35X_Tail
                       699     ;BESCNO EQU Align_RCE_BL35X_Multi
                       700     ;BESCNO EQU Align_RCE_BL35P_Main
                       701     ;BESCNO EQU Align_RCE_BL35P_Tail
                       702     ;BESCNO EQU Align_RCE_BL35P_Multi
                       703     ;BESCNO EQU Gaui_GE_183_18A_Main
                       704     ;BESCNO EQU Gaui_GE_183_18A_Tail
                       705     ;BESCNO EQU Gaui_GE_183_18A_Multi
                       706     ;BESCNO EQU H_King_10A_Main 
                       707     ;BESCNO EQU H_King_10A_Tail 
                       708     ;BESCNO EQU H_King_10A_Multi
                       709     ;BESCNO EQU H_King_20A_Main
                       710     ;BESCNO EQU H_King_20A_Tail
                       711     ;BESCNO EQU H_King_20A_Multi
                       712     ;BESCNO EQU H_King_35A_Main
                       713     ;BESCNO EQU H_King_35A_Tail
                       714     ;BESCNO EQU H_King_35A_Multi
                       715     ;BESCNO EQU H_King_50A_Main
                       716     ;BESCNO EQU H_King_50A_Tail
                       717     ;BESCNO EQU H_King_50A_Multi
                       718     ;BESCNO EQU Polaris_Thunder_12A_Main
                       719     ;BESCNO EQU Polaris_Thunder_12A_Tail
                       720     ;BESCNO EQU Polaris_Thunder_12A_Multi
                       721     ;BESCNO EQU Polaris_Thunder_20A_Main
                       722     ;BESCNO EQU Polaris_Thunder_20A_Tail
                       723     ;BESCNO EQU Polaris_Thunder_20A_Multi
                       724     ;BESCNO EQU Polaris_Thunder_30A_Main
                       725     ;BESCNO EQU Polaris_Thunder_30A_Tail
                       726     ;BESCNO EQU Polaris_Thunder_30A_Multi
                       727     ;BESCNO EQU Polaris_Thunder_40A_Main
                       728     ;BESCNO EQU Polaris_Thunder_40A_Tail
                       729     ;BESCNO EQU Polaris_Thunder_40A_Multi
                       730     ;BESCNO EQU Polaris_Thunder_60A_Main
                       731     ;BESCNO EQU Polaris_Thunder_60A_Tail
                       732     ;BESCNO EQU Polaris_Thunder_60A_Multi
                       733     ;BESCNO EQU Polaris_Thunder_80A_Main
                       734     ;BESCNO EQU Polaris_Thunder_80A_Tail
                       735     ;BESCNO EQU Polaris_Thunder_80A_Multi
                       736     ;BESCNO EQU Polaris_Thunder_100A_Main
                       737     ;BESCNO EQU Polaris_Thunder_100A_Tail
                       738     ;BESCNO EQU Polaris_Thunder_100A_Multi
                       739     ;BESCNO EQU Platinum_Pro_30A_Main
                       740     ;BESCNO EQU Platinum_Pro_30A_Tail
                       741     ;BESCNO EQU Platinum_Pro_30A_Multi 
                       742     ;BESCNO EQU Platinum_Pro_150A_Main
                       743     ;BESCNO EQU Platinum_Pro_150A_Tail
                       744     ;BESCNO EQU Platinum_Pro_150A_Multi
                       745     ;BESCNO EQU Platinum_50Av3_Main
                       746     ;BESCNO EQU Platinum_50Av3_Tail
                       747     ;BESCNO EQU Platinum_50Av3_Multi 
                       748     ;BESCNO EQU EAZY_3Av2_Main
                       749     ;BESCNO EQU EAZY_3Av2_Tail
                       750     ;BESCNO EQU EAZY_3Av2_Multi
                       751     ;BESCNO EQU Tarot_30A_Main
                       752     ;BESCNO EQU Tarot_30A_Tail
                       753     ;BESCNO EQU Tarot_30A_Multi
                       754     ;BESCNO EQU SkyIII_30A_Main
                       755     ;BESCNO EQU SkyIII_30A_Tail
                       756     ;BESCNO EQU SkyIII_30A_Multi
                       757     ;BESCNO EQU EMAX_20A_Main
                       758     ;BESCNO EQU EMAX_20A_Tail
                       759     ;BESCNO EQU EMAX_20A_Multi 
                       760     ;BESCNO EQU EMAX_40A_Main
                       761     ;BESCNO EQU EMAX_40A_Tail
                       762     ;BESCNO EQU EMAX_40A_Multi 
                       763     ;BESCNO EQU EMAX_Nano_20A_Main
                       764     ;BESCNO EQU EMAX_Nano_20A_Tail
                       765     ;BESCNO EQU EMAX_Nano_20A_Multi 
                       766     ;BESCNO EQU EMAX_Lightning_20A_Main
                       767     ;BESCNO EQU EMAX_Lightning_20A_Tail
                       768     ;BESCNO EQU EMAX_Lightning_20A_Multi 
                       769     ;BESCNO EQU XRotor_10A_Main 
                       770     ;BESCNO EQU XRotor_10A_Tail
                       771     ;BESCNO EQU XRotor_10A_Multi 
                       772     ;BESCNO EQU XRotor_20A_Main
                       773     ;BESCNO EQU XRotor_20A_Tail
                       774     ;BESCNO EQU XRotor_20A_Multi 
                       775     ;BESCNO EQU XRotor_40A_Main
                       776     ;BESCNO EQU XRotor_40A_Tail
                       777     ;BESCNO EQU XRotor_40A_Multi 
                       778     ;BESCNO EQU MDRX62H_Main
                       779     ;BESCNO EQU MDRX62H_Tail
                       780     ;BESCNO EQU MDRX62H_Multi 
                       781     ;BESCNO EQU RotorGeeks_20A_Main
                       782     ;BESCNO EQU RotorGeeks_20A_Tail
                       783     ;BESCNO EQU RotorGeeks_20A_Multi
                       784     ;BESCNO EQU RotorGeeks_20A_Plus_Main
                       785     ;BESCNO EQU RotorGeeks_20A_Plus_Tail
                       786     ;BESCNO EQU RotorGeeks_20A_Plus_Multi
                       787     ;BESCNO EQU Flycolor_Fairy_6A_Main
                       788     ;BESCNO EQU Flycolor_Fairy_6A_Tail
                       789     ;BESCNO EQU Flycolor_Fairy_6A_Multi
                       790     ;BESCNO EQU Flycolor_Fairy_30A_Main
                       791     ;BESCNO EQU Flycolor_Fairy_30A_Tail
                       792     ;BESCNO EQU Flycolor_Fairy_30A_Multi
                       793     ;BESCNO EQU Flycolor_Fairy_V2_30A_Main
                       794     ;BESCNO EQU Flycolor_Fairy_V2_30A_Tail
                       795     ;BESCNO EQU Flycolor_Fairy_V2_30A_Multi 
                       796     ;BESCNO EQU Flycolor_Raptor_20A_Main
                       797     ;BESCNO EQU Flycolor_Raptor_20A_Tail
                       798     ;BESCNO EQU Flycolor_Raptor_20A_Multi 
                       799     ;BESCNO EQU Flycolor_Raptor_390_20A_Main
                       800     ;BESCNO EQU Flycolor_Raptor_390_20A_Tail
                       801     ;BESCNO EQU Flycolor_Raptor_390_20A_Multi
                       802     ;BESCNO EQU FVT_Littlebee_12A_Main
                       803     ;BESCNO EQU FVT_Littlebee_12A_Tail
                       804     ;BESCNO EQU FVT_Littlebee_12A_Multi
                       805     ;BESCNO EQU FVT_Littlebee_20A_Main
                       806     ;BESCNO EQU FVT_Littlebee_20A_Tail
                       807     ;BESCNO EQU FVT_Littlebee_20A_Multi 
                       808     ;BESCNO EQU FVT_Littlebee_20A_Pro_Main
                       809     ;BESCNO EQU FVT_Littlebee_20A_Pro_Tail
                       810     ;BESCNO EQU FVT_Littlebee_20A_Pro_Multi 
                       811     ;BESCNO EQU FVT_Littlebee_30A_Main
                       812     ;BESCNO EQU FVT_Littlebee_30A_Tail
                       813     ;BESCNO EQU FVT_Littlebee_30A_Multi 
                       814     ;BESCNO EQU Graupner_Ultra_20A_Main
                       815     ;BESCNO EQU Graupner_Ultra_20A_Tail
                       816     ;BESCNO EQU Graupner_Ultra_20A_Multi 
                       817     ;BESCNO EQU F85_3A_Main
                       818     ;BESCNO EQU F85_3A_Tail
                       819     ;BESCNO EQU F85_3A_Multi
                       820     ;BESCNO EQU ZTW_Spider_Pro_20A_Main
                       821     ;BESCNO EQU ZTW_Spider_Pro_20A_Tail
                       822     ;BESCNO EQU ZTW_Spider_Pro_20A_Multi 
                       823     ;BESCNO EQU ZTW_Spider_Pro_20A_Premium_Main
                       824     ;BESCNO EQU ZTW_Spider_Pro_20A_Premium_Tail
                       825     ;BESCNO EQU ZTW_Spider_Pro_20A_Premium_Multi
                       826     ;BESCNO EQU ZTW_Spider_Pro_20A_HV_Main
                       827     ;BESCNO EQU ZTW_Spider_Pro_20A_HV_Tail
                       828     ;BESCNO EQU ZTW_Spider_Pro_20A_HV_Multi 
                       829     ;BESCNO EQU ZTW_Spider_Pro_30A_HV_Main
                       830     ;BESCNO EQU ZTW_Spider_Pro_30A_HV_Tail
                       831     ;BESCNO EQU ZTW_Spider_Pro_30A_HV_Multi 
                       832     ;BESCNO EQU DYS_XM20A_Main
                       833     ;BESCNO EQU DYS_XM20A_Tail
                       834     ;BESCNO EQU DYS_XM20A_Multi
                       835     ;BESCNO EQU Oversky_MR_20A_Main
                       836     ;BESCNO EQU Oversky_MR_20A_Tail
                       837     ;BESCNO EQU Oversky_MR_20A_Multi 
                       838     ;BESCNO EQU Oversky_MR_20A_Pro_Main
                       839     ;BESCNO EQU Oversky_MR_20A_Pro_Tail
                       840     ;BESCNO EQU Oversky_MR_20A_Pro_Multi
                       841     ;BESCNO EQU TBS_Cube_12A_Main	 
                       842     ;BESCNO EQU TBS_Cube_12A_Tail	  
                       843     ;BESCNO EQU TBS_Cube_12A_Multi 
                       844     ;BESCNO EQU DALRC_XR20A_Main	 
                       845     ;BESCNO EQU DALRC_XR20A_Tail	  
                       846     ;BESCNO EQU DALRC_XR20A_Multi 	 
                       847     ;BESCNO EQU AIKON_Boltlite_30A_Main	 
                       848     ;BESCNO EQU AIKON_Boltlite_30A_Tail	  
                       849     ;BESCNO EQU AIKON_Boltlite_30A_Multi 
                       850     ;BESCNO EQU Align_MR25_15A_Main	 
                       851     ;BESCNO EQU Align_MR25_15A_Tail	  
                       852     ;BESCNO EQU Align_MR25_15A_Multi
                       853     ;BESCNO EQU Servoking_Monster_30A_Main	 
                       854     ;BESCNO EQU Servoking_Monster_30A_Tail	  
                       855     ;BESCNO EQU Servoking_Monster_30A_Multi 
                       856     ;BESCNO EQU Servoking_Monster_30A_Pro_Main	 
                       857     ;BESCNO EQU Servoking_Monster_30A_Pro_Tail	  
                       858     ;BESCNO EQU Servoking_Monster_30A_Pro_Multi 
                       859     ;BESCNO EQU Servoking_Monster_80A_Main	 
                       860     ;BESCNO EQU Servoking_Monster_80A_Tail	  
                       861     ;BESCNO EQU Servoking_Monster_80A_Multi 
                       862     ;BESCNO EQU HTIRC_Hummingbird_12A_Main	 
                       863     ;BESCNO EQU HTIRC_Hummingbird_12A_Tail 	 
                       864     ;BESCNO EQU HTIRC_Hummingbird_12A_Multi  
                       865     ;BESCNO EQU HTIRC_Hummingbird_20A_Main	 
                       866     ;BESCNO EQU HTIRC_Hummingbird_20A_Tail 	 
                       867     ;BESCNO EQU HTIRC_Hummingbird_20A_Multi  
                       868     ;BESCNO EQU HTIRC_Hummingbird_30A_Pro_Main	 
                       869     ;BESCNO EQU HTIRC_Hummingbird_30A_Pro_Tail 	 
                       870     ;BESCNO EQU HTIRC_Hummingbird_30A_Pro_Multi  
                       871     
                       872     
                       873     ;**** **** **** **** ****
                       874     ; ESC selection statements
                       875     IF BESCNO == XP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       879     
                       880     IF BESCNO == XP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       884     
                       885     IF BESCNO == XP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       889     
                       890     IF BESCNO == XP_7A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       894     
                       895     IF BESCNO == XP_7A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       899     
                       900     IF BESCNO == XP_7A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       904     
                       905     IF BESCNO == XP_7A_FAST_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       909     
                       910     IF BESCNO == XP_7A_FAST_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       914     
                       915     IF BESCNO == XP_7A_FAST_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       919     
                       920     IF BESCNO == XP_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       924     
                       925     IF BESCNO == XP_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       929     
                       930     IF BESCNO == XP_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       934     
                       935     IF BESCNO == XP_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       939     
                       940     IF BESCNO == XP_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       944     
                       945     IF BESCNO == XP_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       949     
                       950     IF BESCNO == XP_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       954     
                       955     IF BESCNO == XP_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       959     
                       960     IF BESCNO == XP_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       964     
                       965     IF BESCNO == XP_35A_SW_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       969     
                       970     IF BESCNO == XP_35A_SW_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       974     
                       975     IF BESCNO == XP_35A_SW_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       979     
                       980     IF BESCNO == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       984     
                       985     IF BESCNO == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       989     
                       990     IF BESCNO == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       994     
                       995     IF BESCNO == SUPERMICRO_3P5A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       999     
                      1000     IF BESCNO == SUPERMICRO_3P5A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                      1004     
                      1005     IF BESCNO == SUPERMICRO_3P5A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                      1009     
                      1010     IF BESCNO == TURNIGY_PLUSH_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                      1014     
                      1015     IF BESCNO == TURNIGY_PLUSH_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                      1019     
                      1020     IF BESCNO == TURNIGY_PLUSH_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                      1024     
                      1025     IF BESCNO == TURNIGY_PLUSH_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                      1029     
                      1030     IF BESCNO == TURNIGY_PLUSH_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                      1034     
                      1035     IF BESCNO == TURNIGY_PLUSH_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                      1039     
                      1040     IF BESCNO == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                      1044     
                      1045     IF BESCNO == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                      1049     
                      1050     IF BESCNO == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                      1054     
                      1055     IF BESCNO == TURNIGY_PLUSH_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                      1059     
                      1060     IF BESCNO == TURNIGY_PLUSH_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                      1064     
                      1065     IF BESCNO == TURNIGY_PLUSH_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                      1069     
                      1070     IF BESCNO == TURNIGY_PLUSH_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                      1074     
                      1075     IF BESCNO == TURNIGY_PLUSH_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                      1079     
                      1080     IF BESCNO == TURNIGY_PLUSH_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                      1084     
                      1085     IF BESCNO == TURNIGY_PLUSH_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                      1089     
                      1090     IF BESCNO == TURNIGY_PLUSH_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                      1094     
                      1095     IF BESCNO == TURNIGY_PLUSH_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                      1099     
                      1100     IF BESCNO == TURNIGY_PLUSH_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                      1104     
                      1105     IF BESCNO == TURNIGY_PLUSH_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                      1109     
                      1110     IF BESCNO == TURNIGY_PLUSH_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                      1114     
                      1115     IF BESCNO == TURNIGY_PLUSH_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                      1119     
                      1120     IF BESCNO == TURNIGY_PLUSH_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                      1124     
                      1125     IF BESCNO == TURNIGY_PLUSH_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                      1129     
                      1130     IF BESCNO == TURNIGY_PLUSH_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                      1134     
                      1135     IF BESCNO == TURNIGY_PLUSH_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                      1139     
                      1140     IF BESCNO == TURNIGY_PLUSH_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                      1144     
                      1145     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                      1149     
                      1150     IF BESCNO == TURNIGY_PLUSH_NFET_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                      1154     
                      1155     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                      1159     
                      1160     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1164     
                      1165     IF BESCNO == TURNIGY_PLUSH_NFET_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1169     
                      1170     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1174     
                      1175     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1179     
                      1180     IF BESCNO == TURNIGY_PLUSH_NFET_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1184     
                      1185     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1189     
                      1190     IF BESCNO == TURNIGY_AE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1194     
                      1195     IF BESCNO == TURNIGY_AE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1199     
                      1200     IF BESCNO == TURNIGY_AE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1204     
                      1205     IF BESCNO == TURNIGY_AE_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1209     
                      1210     IF BESCNO == TURNIGY_AE_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1214     
                      1215     IF BESCNO == TURNIGY_AE_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1219     
                      1220     IF BESCNO == TURNIGY_AE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1224     
                      1225     IF BESCNO == TURNIGY_AE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1229     
                      1230     IF BESCNO == TURNIGY_AE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1234     
                      1235     IF BESCNO == TURNIGY_AE_45A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1239     
                      1240     IF BESCNO == TURNIGY_AE_45A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1244     
                      1245     IF BESCNO == TURNIGY_AE_45A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1249     
                      1250     IF BESCNO == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1254     
                      1255     IF BESCNO == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1259     
                      1260     IF BESCNO == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1264     
                      1265     IF BESCNO == TURNIGY_KFORCE_70A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1269     
                      1270     IF BESCNO == TURNIGY_KFORCE_70A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1274     
                      1275     IF BESCNO == TURNIGY_KFORCE_70A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1279     
                      1280     IF BESCNO == TURNIGY_KFORCE_120A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1284     
                      1285     IF BESCNO == TURNIGY_KFORCE_120A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1289     
                      1290     IF BESCNO == TURNIGY_KFORCE_120A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1294     
                      1295     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1299     
                      1300     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1304     
                      1305     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1309     
                      1310     IF BESCNO == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1314     
                      1315     IF BESCNO == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1319     
                      1320     IF BESCNO == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1324     
                      1325     IF BESCNO == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1329     
                      1330     IF BESCNO == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1334     
                      1335     IF BESCNO == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1339     
                      1340     IF BESCNO == HIMODEL_COOL_22A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1344     
                      1345     IF BESCNO == HIMODEL_COOL_22A_TAIL
  0001                1346     MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                      1347     $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                      1834     ENDIF
                      1835     
                      1836     IF BESCNO == HIMODEL_COOL_22A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1840     
                      1841     IF BESCNO == HIMODEL_COOL_33A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1845     
                      1846     IF BESCNO == HIMODEL_COOL_33A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1850     
                      1851     IF BESCNO == HIMODEL_COOL_33A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1855     
                      1856     IF BESCNO == HIMODEL_COOL_41A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1860     
                      1861     IF BESCNO == HIMODEL_COOL_41A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1865     
                      1866     IF BESCNO == HIMODEL_COOL_41A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1870     
                      1871     IF BESCNO == RCTIMER_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1875     
                      1876     IF BESCNO == RCTIMER_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1880     
                      1881     IF BESCNO == RCTIMER_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1885     
                      1886     IF BESCNO == ALIGN_RCE_BL15X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1890     
                      1891     IF BESCNO == ALIGN_RCE_BL15X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1895     
                      1896     IF BESCNO == ALIGN_RCE_BL15X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1900     
                      1901     IF BESCNO == ALIGN_RCE_BL15P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1905     
                      1906     IF BESCNO == ALIGN_RCE_BL15P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1910     
                      1911     IF BESCNO == ALIGN_RCE_BL15P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1915     
                      1916     IF BESCNO == ALIGN_RCE_BL35X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1920     
                      1921     IF BESCNO == ALIGN_RCE_BL35X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1925     
                      1926     IF BESCNO == ALIGN_RCE_BL35X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1930     
                      1931     IF BESCNO == ALIGN_RCE_BL35P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1935     
                      1936     IF BESCNO == ALIGN_RCE_BL35P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1940     
                      1941     IF BESCNO == ALIGN_RCE_BL35P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1945     
                      1946     IF BESCNO == GAUI_GE_183_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1950     
                      1951     IF BESCNO == GAUI_GE_183_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1955     
                      1956     IF BESCNO == GAUI_GE_183_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1960     
                      1961     IF BESCNO == H_KING_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1965     
                      1966     IF BESCNO == H_KING_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1970     
                      1971     IF BESCNO == H_KING_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1975     
                      1976     IF BESCNO == H_KING_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1980     
                      1981     IF BESCNO == H_KING_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1985     
                      1986     IF BESCNO == H_KING_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1990     
                      1991     IF BESCNO == H_KING_35A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1995     
                      1996     IF BESCNO == H_KING_35A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      2000     
                      2001     IF BESCNO == H_KING_35A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      2005     
                      2006     IF BESCNO == H_KING_50A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      2010     
                      2011     IF BESCNO == H_KING_50A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      2015     
                      2016     IF BESCNO == H_KING_50A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      2020     
                      2021     IF BESCNO == POLARIS_THUNDER_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      2025     
                      2026     IF BESCNO == POLARIS_THUNDER_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      2030     
                      2031     IF BESCNO == POLARIS_THUNDER_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      2035     
                      2036     IF BESCNO == POLARIS_THUNDER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      2040     
                      2041     IF BESCNO == POLARIS_THUNDER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      2045     
                      2046     IF BESCNO == POLARIS_THUNDER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      2050     
                      2051     IF BESCNO == POLARIS_THUNDER_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      2055     
                      2056     IF BESCNO == POLARIS_THUNDER_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      2060     
                      2061     IF BESCNO == POLARIS_THUNDER_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      2065     
                      2066     IF BESCNO == POLARIS_THUNDER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      2070     
                      2071     IF BESCNO == POLARIS_THUNDER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      2075     
                      2076     IF BESCNO == POLARIS_THUNDER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      2080     
                      2081     IF BESCNO == POLARIS_THUNDER_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      2085     
                      2086     IF BESCNO == POLARIS_THUNDER_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      2090     
                      2091     IF BESCNO == POLARIS_THUNDER_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      2095     
                      2096     IF BESCNO == POLARIS_THUNDER_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      2100     
                      2101     IF BESCNO == POLARIS_THUNDER_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      2105     
                      2106     IF BESCNO == POLARIS_THUNDER_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      2110     
                      2111     IF BESCNO == POLARIS_THUNDER_100A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      2115     
                      2116     IF BESCNO == POLARIS_THUNDER_100A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      2120     
                      2121     IF BESCNO == POLARIS_THUNDER_100A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      2125     
                      2126     IF BESCNO == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      2130     
                      2131     IF BESCNO == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      2135     
                      2136     IF BESCNO == PLATINUM_PRO_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      2140     
                      2141     IF BESCNO == PLATINUM_PRO_150A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      2145     
                      2146     IF BESCNO == PLATINUM_PRO_150A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      2150     
                      2151     IF BESCNO == PLATINUM_PRO_150A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      2155     
                      2156     IF BESCNO == PLATINUM_50AV3_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      2160     
                      2161     IF BESCNO == PLATINUM_50AV3_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      2165     
                      2166     IF BESCNO == PLATINUM_50AV3_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      2170     
                      2171     IF BESCNO == EAZY_3AV2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      2175     
                      2176     IF BESCNO == EAZY_3AV2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      2180     
                      2181     IF BESCNO == EAZY_3AV2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      2185     
                      2186     IF BESCNO == TAROT_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      2190     
                      2191     IF BESCNO == TAROT_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      2195     
                      2196     IF BESCNO == TAROT_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      2200     
                      2201     IF BESCNO == SKYIII_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      2205     
                      2206     IF BESCNO == SKYIII_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      2210     
                      2211     IF BESCNO == SKYIII_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      2215     
                      2216     IF BESCNO == EMAX_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      2220     
                      2221     IF BESCNO == EMAX_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      2225     
                      2226     IF BESCNO == EMAX_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      2230     
                      2231     IF BESCNO == EMAX_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      2235     
                      2236     IF BESCNO == EMAX_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      2240     
                      2241     IF BESCNO == EMAX_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      2245     
                      2246     IF BESCNO == EMAX_NANO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      2250     
                      2251     IF BESCNO == EMAX_NANO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      2255     
                      2256     IF BESCNO == EMAX_NANO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      2260     
                      2261     IF BESCNO == EMAX_LIGHTNING_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_LIGHTNING_20A.INC)	; Select EMAX Lightning 20A pinout
                               ENDIF
                      2265     
                      2266     IF BESCNO == EMAX_LIGHTNING_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_LIGHTNING_20A.INC)	; Select EMAX Lightning 20A pinout
                               ENDIF
                      2270     
                      2271     IF BESCNO == EMAX_LIGHTNING_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_LIGHTNING_20A.INC)	; Select EMAX Lightning 20A pinout
                               ENDIF
                      2275     
                      2276     IF BESCNO == XROTOR_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      2280     
                      2281     IF BESCNO == XROTOR_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      2285     
                      2286     IF BESCNO == XROTOR_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      2290     
                      2291     IF BESCNO == XROTOR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      2295     
                      2296     IF BESCNO == XROTOR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      2300     
                      2301     IF BESCNO == XROTOR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      2305     
                      2306     IF BESCNO == XROTOR_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      2310     
                      2311     IF BESCNO == XROTOR_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      2315     
                      2316     IF BESCNO == XROTOR_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      2320     
                      2321     IF BESCNO == MDRX62H_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2325     
                      2326     IF BESCNO == MDRX62H_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2330     
                      2331     IF BESCNO == MDRX62H_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2335     
                      2336     IF BESCNO == ROTORGEEKS_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2340     
                      2341     IF BESCNO == ROTORGEEKS_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2345     
                      2346     IF BESCNO == ROTORGEEKS_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2350     
                      2351     IF BESCNO == ROTORGEEKS_20A_PLUS_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ROTORGEEKS_20A_PLUS.INC)	; Select RotorGeeks 20A Plus pinout
                               ENDIF
                      2355     
                      2356     IF BESCNO == ROTORGEEKS_20A_PLUS_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ROTORGEEKS_20A_PLUS.INC)	; Select RotorGeeks 20A Plus pinout
                               ENDIF
                      2360     
                      2361     IF BESCNO == ROTORGEEKS_20A_PLUS_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ROTORGEEKS_20A_PLUS.INC)	; Select RotorGeeks 20A Plus pinout
                               ENDIF
                      2365     
                      2366     IF BESCNO == FLYCOLOR_FAIRY_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2370     
                      2371     IF BESCNO == FLYCOLOR_FAIRY_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2375     
                      2376     IF BESCNO == FLYCOLOR_FAIRY_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2380     
                      2381     IF BESCNO == FLYCOLOR_FAIRY_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2385     
                      2386     IF BESCNO == FLYCOLOR_FAIRY_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2390     
                      2391     IF BESCNO == FLYCOLOR_FAIRY_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2395     
                      2396     IF BESCNO == FLYCOLOR_FAIRY_V2_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_V2_30A.INC)	; Select Flycolor Fairy V2 30A pinout
                               ENDIF
                      2400     
                      2401     IF BESCNO == FLYCOLOR_FAIRY_V2_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_V2_30A.INC)	; Select Flycolor Fairy V2 30A pinout
                               ENDIF
                      2405     
                      2406     IF BESCNO == FLYCOLOR_FAIRY_V2_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_V2_30A.INC)	; Select Flycolor Fairy V2 30A pinout
                               ENDIF
                      2410     
                      2411     IF BESCNO == FLYCOLOR_RAPTOR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_RAPTOR_20A.INC)	; Select Flycolor Raptor 20A pinout
                               ENDIF
                      2415     
                      2416     IF BESCNO == FLYCOLOR_RAPTOR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_RAPTOR_20A.INC)	; Select Flycolor Raptor 20A pinout
                               ENDIF
                      2420     
                      2421     IF BESCNO == FLYCOLOR_RAPTOR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_RAPTOR_20A.INC)	; Select Flycolor Raptor 20A pinout
                               ENDIF
                      2425     
                      2426     IF BESCNO == FLYCOLOR_RAPTOR_390_20A_MAIN
                               MODE 	EQU 	0					; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_RAPTOR_390_20A.INC)	; Select Flycolor Raptor 390 20A pinout
                               ENDIF
                      2430     
                      2431     IF BESCNO == FLYCOLOR_RAPTOR_390_20A_TAIL
                               MODE 	EQU 	1					; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_RAPTOR_390_20A.INC)	; Select Flycolor Raptor 390 20A pinout
                               ENDIF
                      2435     
                      2436     IF BESCNO == FLYCOLOR_RAPTOR_390_20A_MULTI
                               MODE 	EQU 	2					; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_RAPTOR_390_20A.INC)	; Select Flycolor Raptor 390 20A pinout
                               ENDIF
                      2440     
                      2441     IF BESCNO == FVT_LITTLEBEE_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_12A.INC)	; Select Favourite Littlebee 12A pinout
                               ENDIF
                      2445     
                      2446     IF BESCNO == FVT_LITTLEBEE_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_12A.INC)	; Select Favourite Littlebee 12A pinout
                               ENDIF
                      2450     
                      2451     IF BESCNO == FVT_LITTLEBEE_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_12A.INC)	; Select Favourite Littlebee 12A pinout
                               ENDIF
                      2455     
                      2456     IF BESCNO == FVT_LITTLEBEE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2460     
                      2461     IF BESCNO == FVT_LITTLEBEE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2465     
                      2466     IF BESCNO == FVT_LITTLEBEE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2470     
                      2471     IF BESCNO == FVT_LITTLEBEE_20A_PRO_MAIN
                               MODE 	EQU 	0					; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_20A_PRO.INC)	; Select Favourite Littlebee 20A Pro pinout
                               ENDIF
                      2475     
                      2476     IF BESCNO == FVT_LITTLEBEE_20A_PRO_TAIL
                               MODE 	EQU 	1					; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_20A_PRO.INC)	; Select Favourite Littlebee 20A Pro pinout
                               ENDIF
                      2480     
                      2481     IF BESCNO == FVT_LITTLEBEE_20A_PRO_MULTI
                               MODE 	EQU 	2					; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_20A_PRO.INC)	; Select Favourite Littlebee 20A Pro pinout
                               ENDIF
                      2485     
                      2486     IF BESCNO == FVT_LITTLEBEE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2490     
                      2491     IF BESCNO == FVT_LITTLEBEE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2495     
                      2496     IF BESCNO == FVT_LITTLEBEE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2500     
                      2501     IF BESCNO == GRAUPNER_ULTRA_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2505     
                      2506     IF BESCNO == GRAUPNER_ULTRA_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2510     
                      2511     IF BESCNO == GRAUPNER_ULTRA_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2515     
                      2516     IF BESCNO == F85_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2520     
                      2521     IF BESCNO == F85_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2525     
                      2526     IF BESCNO == F85_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2530     
                      2531     IF BESCNO == ZTW_SPIDER_PRO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2535     
                      2536     IF BESCNO == ZTW_SPIDER_PRO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2540     
                      2541     IF BESCNO == ZTW_SPIDER_PRO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2545     
                      2546     IF BESCNO == ZTW_SPIDER_PRO_20A_PREMIUM_MAIN
                               MODE 	EQU 	0						; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_PREMIUM.INC)	; Select ZTW Spider Pro 20A Premium pinout
                               ENDIF
                      2550     
                      2551     IF BESCNO == ZTW_SPIDER_PRO_20A_PREMIUM_TAIL
                               MODE 	EQU 	1						; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_PREMIUM.INC)	; Select ZTW Spider Pro 20A Premium pinout
                               ENDIF
                      2555     
                      2556     IF BESCNO == ZTW_SPIDER_PRO_20A_PREMIUM_MULTI
                               MODE 	EQU 	2						; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_PREMIUM.INC)	; Select ZTW Spider Pro 20A Premium pinout
                               ENDIF
                      2560     
                      2561     IF BESCNO == ZTW_SPIDER_PRO_20A_HV_MAIN
                               MODE 	EQU 	0					; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_HV.INC)	; Select ZTW Spider Pro 20A HV pinout
                               ENDIF
                      2565     
                      2566     IF BESCNO == ZTW_SPIDER_PRO_20A_HV_TAIL
                               MODE 	EQU 	1					; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_HV.INC)	; Select ZTW Spider Pro 20A HV pinout
                               ENDIF
                      2570     
                      2571     IF BESCNO == ZTW_SPIDER_PRO_20A_HV_MULTI
                               MODE 	EQU 	2					; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_HV.INC)	; Select ZTW Spider Pro 20A HV pinout
                               ENDIF
                      2575     
                      2576     IF BESCNO == ZTW_SPIDER_PRO_30A_HV_MAIN
                               MODE 	EQU 	0					; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_30A_HV.INC)	; Select ZTW Spider Pro 30A HV pinout
                               ENDIF
                      2580     
                      2581     IF BESCNO == ZTW_SPIDER_PRO_30A_HV_TAIL
                               MODE 	EQU 	1					; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_30A_HV.INC)	; Select ZTW Spider Pro 30A HV pinout
                               ENDIF
                      2585     
                      2586     IF BESCNO == ZTW_SPIDER_PRO_30A_HV_MULTI
                               MODE 	EQU 	2					; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_30A_HV.INC)	; Select ZTW Spider Pro 30A HV pinout
                               ENDIF
                      2590     
                      2591     IF BESCNO == DYS_XM20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DYS_XM20A.INC)			; Select DYS XM20A pinout
                               ENDIF
                      2595     
                      2596     IF BESCNO == DYS_XM20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DYS_XM20A.INC)			; Select DYS XM20A pinout
                               ENDIF
                      2600     
                      2601     IF BESCNO == DYS_XM20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DYS_XM20A.INC)			; Select DYS XM20A pinout
                               ENDIF
                      2605     
                      2606     IF BESCNO == OVERSKY_MR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (OVERSKY_MR_20A.INC)		; Select Oversky MR-20A pinout
                               ENDIF
                      2610     
                      2611     IF BESCNO == OVERSKY_MR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (OVERSKY_MR_20A.INC)		; Select Oversky MR-20A pinout
                               ENDIF
                      2615     
                      2616     IF BESCNO == OVERSKY_MR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (OVERSKY_MR_20A.INC)		; Select Oversky MR-20A pinout
                               ENDIF
                      2620     
                      2621     IF BESCNO == OVERSKY_MR_20A_PRO_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (OVERSKY_MR_20A_PRO.INC)	; Select Oversky MR-20A Pro pinout
                               ENDIF
                      2625     
                      2626     IF BESCNO == OVERSKY_MR_20A_PRO_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (OVERSKY_MR_20A_PRO.INC)	; Select Oversky MR-20A Pro pinout
                               ENDIF
                      2630     
                      2631     IF BESCNO == OVERSKY_MR_20A_PRO_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (OVERSKY_MR_20A_PRO.INC)	; Select Oversky MR-20A Pro pinout
                               ENDIF
                      2635     
                      2636     IF BESCNO == TBS_CUBE_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TBS_CUBE_12A.INC)		; Select TBS Cube 12A pinout
                               ENDIF
                      2640     
                      2641     IF BESCNO == TBS_CUBE_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TBS_CUBE_12A.INC)		; Select TBS Cube 12A pinout
                               ENDIF
                      2645     
                      2646     IF BESCNO == TBS_CUBE_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TBS_CUBE_12A.INC)		; Select TBS Cube 12A pinout
                               ENDIF
                      2650     
                      2651     IF BESCNO == DALRC_XR20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DALRC_XR20A.INC)		; Select DALRC 20A pinout
                               ENDIF
                      2655     
                      2656     IF BESCNO == DALRC_XR20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DALRC_XR20A.INC)		; Select DALRC 20A pinout
                               ENDIF
                      2660     
                      2661     IF BESCNO == DALRC_XR20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DALRC_XR20A.INC)		; Select DALRC 20A pinout
                               ENDIF
                      2665     
                      2666     IF BESCNO == AIKON_BOLTLITE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (AIKON_BOLTLITE_30A.INC)	; Select AIKON_Boltlite 30A pinout
                               ENDIF
                      2670     
                      2671     IF BESCNO == AIKON_BOLTLITE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (AIKON_BOLTLITE_30A.INC)	; Select AIKON_Boltlite 30A pinout
                               ENDIF
                      2675     
                      2676     IF BESCNO == AIKON_BOLTLITE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (AIKON_BOLTLITE_30A.INC)	; Select AIKON_Boltlite 30A pinout
                               ENDIF
                      2680     
                      2681     IF BESCNO == ALIGN_MR25_15A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_MR25_15A.INC)		; Select Align MR25 15A pinout
                               ENDIF
                      2685     
                      2686     IF BESCNO == ALIGN_MR25_15A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_MR25_15A.INC)		; Select Align MR25 15A pinout
                               ENDIF
                      2690     
                      2691     IF BESCNO == ALIGN_MR25_15A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_MR25_15A.INC)		; Select Align MR25 15A pinout
                               ENDIF
                      2695     
                      2696     IF BESCNO == SERVOKING_MONSTER_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SERVOKING_MONSTER_30A.INC)	; Select Servoking Monster 30A pinout
                               ENDIF
                      2700     
                      2701     IF BESCNO == SERVOKING_MONSTER_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SERVOKING_MONSTER_30A.INC)	; Select Servoking Monster 30A pinout
                               ENDIF
                      2705     
                      2706     IF BESCNO == SERVOKING_MONSTER_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SERVOKING_MONSTER_30A.INC)	; Select Servoking Monster 30A pinout
                               ENDIF
                      2710     
                      2711     IF BESCNO == SERVOKING_MONSTER_30A_PRO_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SERVOKING_MONSTER_30A_PRO.INC)	; Select Servoking Monster 30A Pro pinout
                               ENDIF
                      2715     
                      2716     IF BESCNO == SERVOKING_MONSTER_30A_PRO_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SERVOKING_MONSTER_30A_PRO.INC)	; Select Servoking Monster 30A Pro pinout
                               ENDIF
                      2720     
                      2721     IF BESCNO == SERVOKING_MONSTER_30A_PRO_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SERVOKING_MONSTER_30A_PRO.INC)	; Select Servoking Monster 30A Pro pinout
                               ENDIF
                      2725     
                      2726     IF BESCNO == SERVOKING_MONSTER_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SERVOKING_MONSTER_80A.INC)	; Select Servoking Monster 80A pinout
                               ENDIF
                      2730     
                      2731     IF BESCNO == SERVOKING_MONSTER_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SERVOKING_MONSTER_80A.INC)	; Select Servoking Monster 80A pinout
                               ENDIF
                      2735     
                      2736     IF BESCNO == SERVOKING_MONSTER_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SERVOKING_MONSTER_80A.INC)	; Select Servoking Monster 80A pinout
                               ENDIF
                      2740     
                      2741     IF BESCNO == HTIRC_HUMMINGBIRD_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_12A.INC)	; Select HTIRC Hummingbird 12A pinout
                               ENDIF
                      2745     
                      2746     IF BESCNO == HTIRC_HUMMINGBIRD_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_12A.INC)	; Select HTIRC Hummingbird 12A pinout
                               ENDIF
                      2750     
                      2751     IF BESCNO == HTIRC_HUMMINGBIRD_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HTIRC_HUMMINGBIRD_12A.INC)	; Select HTIRC Hummingbird 12A pinout
                               ENDIF
                      2755     
                      2756     IF BESCNO == HTIRC_HUMMINGBIRD_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_20A.INC)	; Select HTIRC Hummingbird 20A pinout
                               ENDIF
                      2760     
                      2761     IF BESCNO == HTIRC_HUMMINGBIRD_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_20A.INC)	; Select HTIRC Hummingbird 20A pinout
                               ENDIF
                      2765     
                      2766     IF BESCNO == HTIRC_HUMMINGBIRD_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HTIRC_HUMMINGBIRD_20A.INC)	; Select HTIRC Hummingbird 20A pinout
                               ENDIF
                      2770     
                      2771     IF BESCNO == HTIRC_HUMMINGBIRD_30A_PRO_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_30A_PRO.INC)	; Select HTIRC Hummingbird 30A Pro pinout
                               ENDIF
                      2775     
                      2776     IF BESCNO == HTIRC_HUMMINGBIRD_30A_PRO_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_30A_PRO.INC)	; Select HTIRC Hummingbird 30A Pro pinout
                               ENDIF
                      2780     
                      2781     IF BESCNO == HTIRC_HUMMINGBIRD_30A_PRO_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HTIRC_HUMMINGBIRD_30A_PRO.INC)	; Select HTIRC Hummingbird 30A Pro pinout
                               ENDIF
                      2785     
                      2786     
                      2787     
                      2788     ;**** **** **** **** ****
                      2789     ; TX programming defaults
                      2790     ;
                      2791     ; Parameter dependencies:
                      2792     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                      2793     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                      2794     ;
                      2795     ; MAIN
  0007                2796     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                2797     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                2798     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                2799     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                2800     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                2801     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2802     IF DAMPED_MODE_ENABLE == 1
                               DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
                               ELSE
  0002                2805     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low	
                      2806     ENDIF
  0001                2807     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2808     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                2809     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                2810     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                2811     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                2812     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                2813     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                2814     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                      2815     
                      2816     ; TAIL
  0003                2817     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                2818     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                2819     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2820     IF DAMPED_MODE_ENABLE == 1
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low 		3=DampedLight 
                               ELSE
  0001                2823     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		
                      2824     ENDIF
  0001                2825     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2826     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2827     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                2828     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                2829     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                2830     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2831     DEFAULT_PGM_TAIL_PWM_DITHER		EQU 3 	; 1=Off		2=3			3=7			4=15			5=31
                      2832     
                      2833     ; MULTI
  0009                2834     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                2835     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                2836     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                2837     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0003                2838     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2839     IF DAMPED_MODE_ENABLE == 1
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low 		3=DampedLight 
                               ELSE
  0001                2842     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low
                      2843     ENDIF
  0003                2844     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 3 	; 1=Disabled	2=Low		3=High
  0001                2845     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2846     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0050                2847     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 80	; Beep strength
  0050                2848     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 80	; Beacon strength
  0004                2849     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2850     DEFAULT_PGM_MULTI_PWM_DITHER		EQU 3 	; 1=Off		2=3			3=7			4=15			5=31
                      2851     
                      2852     ; COMMON
  0001                2853     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 1 	; 1=Enabled 	0=Disabled
  000A                2854     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 10	; 4*10+1000=1040
  00F0                2855     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 240	; 4*240+1000=1960
  007D                2856     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 125	; 4*125+1000=1500 (used in bidirectional mode)
  0000                2857     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0=Low		1+= High or higher	
  0001                2858     DEFAULT_PGM_ENABLE_TEMP_PROT	 	EQU 1 	; 1=Enabled 	0=Disabled
  0001                2859     DEFAULT_PGM_ENABLE_POWER_PROT 	EQU 1 	; 1=Enabled 	0=Disabled
  0000                2860     DEFAULT_PGM_ENABLE_PWM_INPUT	 	EQU 0 	; 1=Enabled 	0=Disabled
  0001                2861     DEFAULT_PGM_BRAKE_ON_STOP	 	EQU 1 	; 1=Enabled 	0=Disabled
                      2862     
                      2863     ;**** **** **** **** ****
                      2864     ; Constant definitions for main
                      2865     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2884     ; Constant definitions for tail
                      2885     IF MODE == 1
                      2886     
  0001                2887     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
  000A                2888     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                2889     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                2890     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                2891     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                2892     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                2893     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                2894     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  0082                2895     RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                      2896     
  0032                2897     PWM_START			EQU	50 	; PWM used as max power during start
                      2898     
  0001                2899     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                      2900     
  0008                2901     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                      2902     
                      2903     ENDIF
                      2904     ; Constant definitions for multi
                      2905     IF MODE == 2
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2924     
                      2925     ;**** **** **** **** ****
                      2926     ; Temporary register definitions
  REG                 2927     TEMP1		EQU	R0
  REG                 2928     TEMP2		EQU	R1
  REG                 2929     TEMP3		EQU	R2
  REG                 2930     TEMP4		EQU	R3
  REG                 2931     TEMP5		EQU	R4
  REG                 2932     TEMP6		EQU	R5
  REG                 2933     TEMP7		EQU	R6
  REG                 2934     TEMP8		EQU	R7
                      2935     
                      2936     ;**** **** **** **** ****
                      2937     ; Register definitions
------                2938     DSEG AT 20H					; Variables segment 
                      2939     
0020                  2940     BIT_ACCESS: 				DS	1		; MUST BE AT THIS ADDRESS. Variable at bit accessible address (for non interrupt routines)
0021                  2941     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                      2942     
0022                  2943     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                  2944     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                  2945     CURRENT_PWM: 				DS	1		; Current pwm
0025                  2946     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited
0026                  2947     CURRENT_PWM_LIM_DITH: 		DS	1		; Current pwm that is limited and dithered (applied to the motor output)
0027                  2948     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0028                  2949     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0029                  2950     RCP_OUTSIDE_RANGE_CNT: 		DS	1		; RC pulse outside range counter (incrementing) 
002A                  2951     RCP_TIMEOUT_CNTD: 			DS	1		; RC pulse timeout counter (decrementing) 
002B                  2952     RCP_SKIP_CNTD: 				DS	1		; RC pulse skip counter (decrementing) 
                      2953     
002C                  2954     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                2955     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                2956     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                2957     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                2958     PWM_TIMER0_OVERFLOW			EQU	3		; Set for 48MHz MCUs when PWM timer 0 overflows
  0004                2959     DEMAG_DETECTED				EQU 	4		; Set when excessive demag time is detected
  0005                2960     DEMAG_CUT_POWER			EQU 	5		; Set when demag compensation cuts power
  0006                2961     HIGH_RPM					EQU 	6		; Set when motor rpm is high (Comm_Period4x_H less than 2)
                      2962     ;						EQU 	7	
                      2963     
002D                  2964     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                2965     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                2966     STARTUP_PHASE				EQU 	1		; Set when in startup phase
  0002                2967     INITIAL_RUN_PHASE			EQU	2		; Set when in initial run phase, before synchronized run is achieved
  0003                2968     MOTOR_STARTED				EQU 	3		; Set when motor is started
  0004                2969     DIR_CHANGE_BRAKE			EQU 	4		; Set when braking before direction change
  0005                2970     COMP_TIMED_OUT				EQU 	5		; Set when comparator reading timed out
  0006                2971     GOV_ACTIVE				EQU 	6		; Set when governor is active (enabled when speed is above minimum)
  0007                2972     SKIP_DAMP_ON				EQU 	7 		; Set when turning damping fet on is skipped
                      2973     
002E                  2974     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                2975     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                2976     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                2977     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode
  0003                2978     PGM_PWM_HIGH_FREQ			EQU	3		; Progremmed pwm high frequency
  0004                2979     RCP_PPM					EQU 	4		; RC pulse ppm type input (set also when oneshot is set)
  0005                2980     RCP_PPM_ONESHOT125			EQU 	5		; RC pulse ppm type input is OneShot125
  0006                2981     RCP_DIR_REV				EQU 	6		; RC pulse direction in bidirectional mode
                      2982     ;						EQU 	7	
                      2983     
002F                  2984     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                2985     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                2986     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                2987     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                2988     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                2989     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                2990     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                2991     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                2992     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                      2993     
                      2994     
                      2995     ;**** **** **** **** ****
                      2996     ; RAM definitions
------                2997     DSEG AT 30H						; Ram data segment, direct addressing
                      2998     
0030                  2999     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                      3000     
0031                  3001     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                  3002     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                      3003     
0033                  3004     STARTUP_CNT: 				DS	1		; Startup phase commutations counter (incrementing)
0034                  3005     STARTUP_ZC_TIMEOUT_CNTD: 		DS	1		; Startup zero cross timeout counter (decrementing)
0035                  3006     INITIAL_RUN_ROT_CNTD: 		DS	1		; Initial run rotations counter (decrementing)
0036                  3007     STALL_CNT: 				DS	1		; Counts start/run attempts that resulted in stall. Reset upon a proper stop
0037                  3008     DEMAG_DETECTED_METRIC: 		DS	1		; Metric used to gauge demag event frequency
0038                  3009     DEMAG_PWR_OFF_THRESH: 		DS	1		; Metric threshold above which power is cut
0039                  3010     LOW_RPM_PWR_SLOPE: 			DS	1		; Sets the slope of power increase for low rpms
                      3011     
003A                  3012     TIMER2_X: 					DS	1		; Timer 2 extended byte
003B                  3013     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003C                  3014     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003D                  3015     PREV_COMM_X: 				DS	1		; Previous commutation timer3 timestamp (ext byte)
003E                  3016     PREV_PREV_COMM_L: 			DS	1		; Pre-previous commutation timer3 timestamp (lo byte)
003F                  3017     PREV_PREV_COMM_H: 			DS	1		; Pre-previous commutation timer3 timestamp (hi byte)
0040                  3018     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
0041                  3019     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
0042                  3020     COMM_PHASE: 				DS	1		; Current commutation phase
0043                  3021     COMPARATOR_READ_CNT:  		DS	1		; Number of comparator reads done
                      3022     
0044                  3023     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0045                  3024     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0046                  3025     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0047                  3026     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0048                  3027     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0049                  3028     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
004A                  3029     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
004B                  3030     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
004C                  3031     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
                      3032     
004D                  3033     WT_ADV_START_L: 			DS	1		; Timer3 start point for commutation advance timing (lo byte)
004E                  3034     WT_ADV_START_H: 			DS	1		; Timer3 start point for commutation advance timing (hi byte)
004F                  3035     WT_ZC_SCAN_START_L: 			DS	1		; Timer3 start point from commutation to zero cross scan (lo byte)
0050                  3036     WT_ZC_SCAN_START_H: 			DS	1		; Timer3 start point from commutation to zero cross scan (hi byte)
0051                  3037     WT_ZC_TOUT_START_L: 			DS	1		; Timer3 start point for zero cross scan timeout (lo byte)
0052                  3038     WT_ZC_TOUT_START_H: 			DS	1		; Timer3 start point for zero cross scan timeout (hi byte)
0053                  3039     WT_COMM_START_L: 			DS	1		; Timer3 start point from zero cross to commutation (lo byte)
0054                  3040     WT_COMM_START_H: 			DS	1		; Timer3 start point from zero cross to commutation (hi byte)
                      3041     
0055                  3042     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0056                  3043     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0057                  3044     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0058                  3045     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0059                  3046     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
005A                  3047     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
005B                  3048     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
005C                  3049     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005D                  3050     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005E                  3051     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005F                  3052     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
0060                  3053     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                      3054     
0061                  3055     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
0062                  3056     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup
0063                  3057     PWM_LIMIT_BY_RPM: 			DS	1		; Maximum allowed pwm for low or high rpms
0064                  3058     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0065                  3059     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0066                  3060     PWM_DITHER_DECODED: 			DS	1		; Decoded pwm dither value
0067                  3061     PWM_DITHER_EXCESS_POWER: 		DS	1		; Excess power (above max) from pwm dither
0068                  3062     RANDOM: 					DS	1		; Random number from LFSR 
                      3063     
0069                  3064     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
006A                  3065     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
006B                  3066     MAIN_SPOOLUP_TIME_3X: 		DS	1		; Main spoolup time x3
006C                  3067     MAIN_SPOOLUP_TIME_10X: 		DS	1		; Main spoolup time x10
006D                  3068     MAIN_SPOOLUP_TIME_15X: 		DS	1		; Main spoolup time x15
                      3069     
006E                  3070     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006F                  3071     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
0070                  3072     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                      3073     
0071                  3074     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                      3075     
0072                  3076     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
0073                  3077     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                      3078     
0074                  3079     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0075                  3080     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0076                  3081     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                      3082     
0077                  3083     SKIP_T2_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 interrupt shall be ignored 
0078                  3084     SKIP_T2H_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 high interrupt shall be ignored 
0079                  3085     TIMER0_OVERFLOW_VALUE: 		DS	1		; Remaining timer 0 wait time used with 48MHz MCUs
007A                  3086     CLOCK_SET_AT_48MHZ: 			DS	1		; Variable set if 48MHz MCUs run at 48MHz
007B                  3087     DAMPINGFET: 				DS	1		; Port position of fet used for damping
                      3088     
007C                  3089     FLASH_KEY_1: 				DS	1		; Flash key one
007D                  3090     FLASH_KEY_2: 				DS	1		; Flash key two
                      3091     
                      3092     ; Indirect addressing data segment. The variables below must be in this sequence
------                3093     ISEG AT 080H					
0080                  3094     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  3095     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  3096     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  3097     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  3098     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  3099     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  3100     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  3101     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  3102     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  3103     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  3104     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  3105     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  3106     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  3107     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  3108     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  3109     _PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm (unused - place holder)
0090                  3110     _PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration (unused - place holder)
0091                  3111     _PGM_VOLT_COMP: 			DS	1		; Place holder
0092                  3112     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  3113     _PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force (unused - place holder)
0094                  3114     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  3115     _PGM_STARTUP_METHOD: 		DS	1		; Programmed startup method (unused - place holder)
0096                  3116     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  3117     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  3118     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  3119     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  3120     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  3121     _PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate (unused - place holder)
009C                  3122     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  3123     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  3124     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
009F                  3125     PGM_MAIN_SPOOLUP_TIME: 		DS	1		; Programmed main spoolup time
00A0                  3126     PGM_ENABLE_TEMP_PROT: 		DS	1		; Programmed temperature protection enable
00A1                  3127     PGM_ENABLE_POWER_PROT: 		DS	1		; Programmed low rpm power protection enable
00A2                  3128     PGM_ENABLE_PWM_INPUT: 		DS	1		; Programmed PWM input signal enable
00A3                  3129     PGM_PWM_DITHER: 			DS	1		; Programmed output PWM dither
00A4                  3130     PGM_BRAKE_ON_STOP: 			DS	1		; Programmed braking when throttle is zero
                      3131     
                      3132     ; The sequence of the variables below is no longer of importance
00A5                  3133     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A6                  3134     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A7                  3135     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
                      3136     
                      3137     
                      3138     ; Indirect addressing data segment
------                3139     ISEG AT 0D0H					
00D0                  3140     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      3141     
                      3142     
                      3143     ;**** **** **** **** ****
------                3144     CSEG AT 1A00H            ; "Eeprom" segment
  000E                3145     EEPROM_FW_MAIN_REVISION		EQU	14		; Main revision of the firmware
  004B                3146     EEPROM_FW_SUB_REVISION		EQU	75		; Sub revision of the firmware
  0015                3147     EEPROM_LAYOUT_REVISION		EQU	21		; Revision of the EEPROM layout
                      3148     
1A00    0E            3149     EEP_FW_MAIN_REVISION:  DB 14 
1A01    4B            3150     EEP_FW_SUB_REVISION:  DB 75 
1A02    15            3151     EEP_LAYOUT_REVISION:  DB 21 
                      3152     
                      3153     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH	
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH	
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH						
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH	
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH	
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							
                               EEP_PGM_MAIN_SPOOLUP_TIME:	DB	DEFAULT_PGM_MAIN_SPOOLUP_TIME		; EEPROM copy of programmed main spoolup time
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               _EEP_PGM_PWM_DITHER:		DB	0FFH	
                               EEP_PGM_BRAKE_ON_STOP:		DB	DEFAULT_PGM_BRAKE_ON_STOP		; EEPROM copy of programmed braking when throttle is zero
                               ENDIF 
                      3192     
                      3193     IF MODE == 1
1A03    FF            3194     _EEP_PGM_GOV_P_GAIN: 		DB	0FFH							
1A04    FF            3195     _EEP_PGM_GOV_I_GAIN: 		DB	0FFH							
1A05    FF            3196     _EEP_PGM_GOV_MODE: 			DB 	0FFH							
1A06    FF            3197     _EEP_PGM_LOW_VOLTAGE_LIM: 	DB	0FFH							
1A07    03            3198     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    04            3199     EEP_PGM_MOTOR_IDLE:  DB 4 
1A09    0A            3200     EEP_PGM_STARTUP_PWR:  DB 10 
1A0A    01            3201     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            3202     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            3203     EEP_PGM_INPUT_POL:  DB 1 
1A0D    5A            3204     EEP_INITIALIZED_L: 			DB	05AH							; EEPROM initialized signature low byte
1A0E    A5            3205     EEP_INITIALIZED_H: 			DB	0A5H							; EEPROM initialized signature high byte
1A0F    01            3206     EEP_ENABLE_TX_PROGRAM:  DB 1 
1A10    FF            3207     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            3208     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    FF            3209     _EEP_PGM_STARTUP_RPM: 		DB	0FFH
1A13    FF            3210     _EEP_PGM_STARTUP_ACCEL: 		DB	0FFH
1A14    FF            3211     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            3212     EEP_PGM_COMM_TIMING:  DB 3 
1A16    FF            3213     _EEP_PGM_DAMPING_FORCE: 		DB	0FFH
1A17    FF            3214     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    FF            3215     _EEP_PGM_STARTUP_METHOD: 		DB	0FFH
1A19    0A            3216     EEP_PGM_PPM_MIN_THROTTLE:  DB 10 
1A1A    F0            3217     EEP_PGM_PPM_MAX_THROTTLE:  DB 240 
1A1B    FA            3218     EEP_PGM_BEEP_STRENGTH:  DB 250 
1A1C    FA            3219     EEP_PGM_BEACON_STRENGTH:  DB 250 
1A1D    04            3220     EEP_PGM_BEACON_DELAY:  DB 4 
1A1E    FF            3221     _EEP_PGM_THROTTLE_RATE: 		DB	0FFH
1A1F    01            3222     EEP_PGM_DEMAG_COMP:  DB 1 
1A20    00            3223     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7D            3224     EEP_PGM_PPM_CENTER_THROTTLE:  DB 125 
1A22    FF            3225     _EEP_PGM_MAIN_SPOOLUP_TIME: 	DB	0FFH
1A23    01            3226     EEP_PGM_TEMP_PROT_ENABLE:  DB 1 
1A24    01            3227     EEP_PGM_ENABLE_POWER_PROT:  DB 1 
1A25    00            3228     EEP_PGM_ENABLE_PWM_INPUT:  DB 0 
1A26    03            3229     EEP_PGM_PWM_DITHER:  DB 3 
1A27    01            3230     EEP_PGM_BRAKE_ON_STOP:  DB 1 
                      3231     ENDIF
                      3232     
                      3233     IF MODE == 2
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MULTI_P_GAIN			; EEPROM copy of programmed closed loop P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MULTI_I_GAIN			; EEPROM copy of programmed closed loop I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MULTI_GOVERNOR_MODE	; EEPROM copy of programmed closed loop mode
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_MULTI_GAIN			; EEPROM copy of programmed tail gain
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MULTI_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MULTI_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MULTI_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MULTI_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	055H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0AAH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MULTI_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MULTI_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MULTI_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MULTI_BEACON_DELAY	; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MULTI_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               _EEP_PGM_MAIN_SPOOLUP_TIME:	DB	0FFH
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               EEP_PGM_PWM_DITHER:			DB	DEFAULT_PGM_MULTI_PWM_DITHER		; EEPROM copy of programmed output PWM dither
                               EEP_PGM_BRAKE_ON_STOP:		DB	DEFAULT_PGM_BRAKE_ON_STOP		; EEPROM copy of programmed braking when throttle is zero
                               ENDIF
                      3272     
1A28    FF            3273     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      3274     
------                3275     CSEG AT 1A60H
1A60    20202020      3276     EEP_NAME: 					DB	"                "				; Name tag (16 Bytes)
1A64    20202020
1A68    20202020
1A6C    20202020
                      3277     
                      3278     ;**** **** **** **** ****
                      3279     		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                3279+1   CSEG AT 0  ; CODE SEGMENT START
0000    0219FD        3279+1   JMP RESET 
------                3279+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200A8        3279+1   JMP T0_INT 
------                3279+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    020154        3279+1   JMP T2_INT 
------                3279+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    0202D4        3279+1   JMP PCA_INT 
------                3279+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    0202C1        3279+1   JMP T3_INT 
------                3280     CSEG AT 80H			; Code segment after interrupt vectors 
                      3281     
                      3282     ;**** **** **** **** ****
                      3283     
                      3284     ; Table definitions
0080    02030406      3285     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    0406080C      3286     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
0091    10182030
0095    406080A0
0099    C0
009A    0003070F      3287     PWM_DITHER_TABLE:   		DB 	00H, 03H, 07H, 0FH, 1FH
009E    1F
                      3288     IF MODE == 0
                                 IF DAMPED_MODE_ENABLE == 1
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 3, 3, 2, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 2, 3, 2, 2
                                 ENDIF
                               ENDIF
                      3296     IF MODE == 1
                      3297       IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 3, 5, 3, 3, 2
                                 ENDIF
                      3300       IF DAMPED_MODE_ENABLE == 0
009F    05050D05      3301     TX_PGM_PARAMS_TAIL:   	DB 	5, 5, 13, 5, 2, 5, 3, 3, 2
00A3    02050303
00A7    02
                      3302       ENDIF
                      3303     ENDIF
                      3304     IF MODE == 2
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 13, 5, 3, 5, 3, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF 
                               ENDIF
                      3312     
                      3313     
                      3314     
                      3315     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3316     ;
                      3317     ; Timer0 interrupt routine
                      3318     ;
                      3319     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      3320     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      3321     ;
                      3322     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3323     T0_INT: 	; Used for pwm control
00A8    C2AF          3324     	CLR 	EA			; Disable all interrupts
                      3325     IF MCU_48MHZ == 1
                               	; Check overflow flag
                               	JNB	FLAGS0.PWM_TIMER0_OVERFLOW, T0_INT_START; Execute this interrupt
                               
                               	CLR	FLAGS0.PWM_TIMER0_OVERFLOW
                               	MOV	TL0, TIMER0_OVERFLOW_VALUE	; Set timer 
                               	SETB	EA			; Enable all interrupts
                               	RETI
                               
                               T0_INT_START:
                               ENDIF
00AA    C0D0          3336     	PUSH	PSW			; Preserve registers through interrupt
00AC    C0E0          3337     	PUSH	ACC		
                      3338     	; Check if pwm is on
00AE    206214        3339     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      3340     
                      3341     	; Pwm on cycle
00B1    E525          3342     	MOV	A, CURRENT_PWM_LIMITED
00B3    6009          3343     	JZ	T0_INT_PWM_ON_RET
                      3344     
00B5    E4            3345     	CLR	A					
00B6    73            3346     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      3347     
                      3348     T0_INT_PWM_ON_EXIT: 
                      3349     	; Set timer for coming on cycle length
00B7    E525          3350     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
00B9    F4            3351     	CPL	A						; cpl is 255-x
                      3352     IF MCU_48MHZ == 0
00BA    F58A          3353     	MOV	TL0, A					; Write start point for timer
                      3354     ELSE
                               	CLR	C
                               	RLC	A
                               	JC	T0_INT_PWM_ON_SET_TIMER
                               
                               	MOV	TL0, #0
                               	SETB	FLAGS0.PWM_TIMER0_OVERFLOW
                               	MOV	TIMER0_OVERFLOW_VALUE, A
                               	AJMP	T0_INT_PWM_ON_TIMER_SET
                               
                               T0_INT_PWM_ON_SET_TIMER:
                               	MOV	TL0, A
                               T0_INT_PWM_ON_TIMER_SET:
                               ENDIF
                      3368     	; Set other variables
00BC    D262          3369     SETB FLAGS0 . 2 
                      3370     T0_INT_PWM_ON_RET: 
                      3371     	; Exit interrupt
00BE    D0E0          3372     	POP	ACC			; Restore preserved registers
00C0    D0D0          3373     	POP	PSW
00C2    D2AF          3374     	SETB	EA			; Enable all interrupts
00C4    32            3375     	RETI
                      3376     
                      3377     
                      3378     	; Pwm off cycle
                      3379     T0_INT_PWM_OFF: 
                      3380     IF MCU_48MHZ == 0
00C5    85268A        3381     	MOV	TL0, CURRENT_PWM_LIM_DITH	; Load new timer setting
                      3382     ELSE
                               	CLR	C
                               	MOV	A, CURRENT_PWM_LIM_DITH
                               	RLC	A
                               	JC	T0_INT_PWM_OFF_SET_TIMER 
                               
                               	MOV	TL0, #0
                               	SETB	FLAGS0.PWM_TIMER0_OVERFLOW
                               	MOV	TIMER0_OVERFLOW_VALUE, A
                               	AJMP	T0_INT_PWM_OFF_TIMER_SET
                               
                               T0_INT_PWM_OFF_SET_TIMER:
                               	MOV	TL0, A
                               T0_INT_PWM_OFF_TIMER_SET:
                               ENDIF
                      3397     	; Clear pwm on flag
00C8    C262          3398     CLR FLAGS0 . 2 
                      3399     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00CA    E526          3400     	MOV	A, CURRENT_PWM_LIM_DITH		; Load current pwm
00CC    F4            3401     	CPL	A						; Full pwm?
00CD    6029          3402     	JZ	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      3403     
                      3404     IF DAMPED_MODE_ENABLE == 1
                               	; Do not execute pwm off when stopped
                               	JNB	FLAGS1.MOTOR_SPINNING, T0_INT_PWM_OFF_EXIT
                               
                               	; If damped operation, set pFETs on in pwm_off
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED, T0_INT_PWM_OFF_DAMPED	; Damped operation?
                               ENDIF
                      3411     
                      3412     T0_INT_PWM_OFF_EXIT_NFETS_OFF: 	
                      3413     	; Separate exit commands here for minimum delay
                      3414     IF NFETON_DELAY == 0
                               	EN_OFF			; For EN/PWM style drivers. Uses accumulator
                               ENDIF
00CF    D0E0          3417     	POP	ACC			; Restore preserved registers
00D1    D0D0          3418     	POP	PSW
                      3419     IF NFETON_DELAY NE 0
                      3420     	ALL_NFETS_OFF 		; Switch off all nfets
00D3    C294          3420+1   CLR P1 . 4 
00D5    C292          3420+1   CLR P1 . 2 
00D7    C290          3420+1   CLR P1 . 0 
                      3421     ENDIF
00D9    D2AF          3422     	SETB	EA			; Enable all interrupts
00DB    32            3423     	RETI
                      3424     
                      3425     T0_INT_PWM_OFF_DAMPED: 
                      3426     IF PFETON_DELAY < 128
                      3427     IF PFETON_DELAY NE 0
                      3428     	ALL_NFETS_OFF 				; Switch off all nfets
00DC    C294          3428+1   CLR P1 . 4 
00DE    C292          3428+1   CLR P1 . 2 
00E0    C290          3428+1   CLR P1 . 0 
                      3429     ELSE
                               	EN_OFF
                               ENDIF
00E2    206F0C        3432     JB FLAGS1 . 7 , T0_INT_PWM_OFF_DAMP_DONE 
00E5    206509        3433     JB FLAGS0 . 5 , T0_INT_PWM_OFF_DAMP_DONE 
                      3434     IF PFETON_DELAY NE 0
00E8    7405          3435     MOV A , # 5 
00EA    D5E0FD        3436     	DJNZ	ACC, $	
                      3437     ENDIF
                      3438     	DAMPING_FET_ON
00ED    E57B          3438+1   MOV A , DAMPINGFET 
00EF    4290          3438+1   ORL P1 , A 
                      3439     T0_INT_PWM_OFF_DAMP_DONE: 
                      3440     ENDIF
                      3441     IF PFETON_DELAY >= 128			; "Negative", 1's complement
                               	JB	FLAGS1.SKIP_DAMP_ON, T0_INT_PWM_OFF_DAMP_DONE
                               	JB	FLAGS0.DEMAG_CUT_POWER, T0_INT_PWM_OFF_DAMP_DONE 
                               	DAMPING_FET_ON				; Damping fet on
                               	MOV	A, #PFETON_DELAY
                               	CPL	A
                               	DJNZ	ACC, $	
                               T0_INT_PWM_OFF_DAMP_DONE:
                               	ALL_NFETS_OFF 				; Switch off all nfets
                               ENDIF
                      3451     T0_INT_PWM_OFF_EXIT: 	
00F1    D0E0          3452     	POP	ACC			; Restore preserved registers
00F3    D0D0          3453     	POP	PSW
00F5    D2AF          3454     	SETB	EA			; Enable all interrupts
00F7    32            3455     	RETI
                      3456     
                      3457     T0_INT_PWM_OFF_FULLPOWER_EXIT:  
00F8    758A00        3458     	MOV	TL0, #0		; Set long time till next interrupt
                      3459     IF MCU_48MHZ == 1
                               	SETB	FLAGS0.PWM_TIMER0_OVERFLOW
                               	MOV	TIMER0_OVERFLOW_VALUE, #0
                               ENDIF
00FB    C28D          3463     	CLR	TF0			; Clear interrupt flag
00FD    D262          3464     SETB FLAGS0 . 2 
00FF    01F1          3465     	AJMP	T0_INT_PWM_OFF_EXIT
                      3466     
                      3467     
                      3468     PWM_NOFET: 	; Dummy pwm on cycle
0101    01B7          3469     	AJMP	T0_INT_PWM_ON_EXIT
                      3470     
                      3471     PWM_AFET: 		; Pwm on cycle afet on
0103    306805        3472     JNB FLAGS1 . 0 , PWM_AFET_EXIT 
0106    206502        3473     JB FLAGS0 . 5 , PWM_AFET_EXIT 
                      3474     	ANFET_ON	
0109    D294          3474+1   SETB P1 . 4 
                      3475     PWM_AFET_EXIT: 
010B    01B7          3476     	AJMP	T0_INT_PWM_ON_EXIT
                      3477     
                      3478     PWM_BFET: 		; Pwm on cycle bfet on
010D    306805        3479     JNB FLAGS1 . 0 , PWM_BFET_EXIT 
0110    206502        3480     JB FLAGS0 . 5 , PWM_BFET_EXIT 
                      3481     	BNFET_ON
0113    D292          3481+1   SETB P1 . 2 
                      3482     PWM_BFET_EXIT: 
0115    01B7          3483     	AJMP	T0_INT_PWM_ON_EXIT
                      3484     
                      3485     PWM_CFET: 		; Pwm on cycle cfet on
0117    306805        3486     JNB FLAGS1 . 0 , PWM_CFET_EXIT 
011A    206502        3487     JB FLAGS0 . 5 , PWM_CFET_EXIT 
                      3488     	CNFET_ON
011D    D290          3488+1   SETB P1 . 0 
                      3489     PWM_CFET_EXIT: 
011F    01B7          3490     	AJMP	T0_INT_PWM_ON_EXIT
                      3491     
                      3492     PWM_AFET_DAMPED: 	
                      3493     IF NFETON_DELAY NE 0
                      3494     	APFET_OFF
0121    C295          3494+1   CLR P1 . 5 
                      3495     ENDIF
0123    30680A        3496     JNB FLAGS1 . 0 , PWM_AFET_DAMPED_EXIT 
0126    206507        3497     JB FLAGS0 . 5 , PWM_AFET_DAMPED_EXIT 
                      3498     IF NFETON_DELAY NE 0
0129    7428          3499     MOV A , # 40 
012B    D5E0FD        3500     	DJNZ ACC,	$
                      3501     ENDIF
                      3502     PWM_AFET_DAMPED_DONE: 
                      3503     	ANFET_ON								; Switch nFET
012E    D294          3503+1   SETB P1 . 4 
                      3504     PWM_AFET_DAMPED_EXIT: 
0130    01B7          3505     	AJMP	T0_INT_PWM_ON_EXIT
                      3506     
                      3507     PWM_BFET_DAMPED: 
                      3508     IF NFETON_DELAY NE 0
                      3509     	BPFET_OFF
0132    C293          3509+1   CLR P1 . 3 
                      3510     ENDIF
0134    30680A        3511     JNB FLAGS1 . 0 , PWM_BFET_DAMPED_EXIT 
0137    206507        3512     JB FLAGS0 . 5 , PWM_BFET_DAMPED_EXIT 
                      3513     IF NFETON_DELAY NE 0
013A    7428          3514     MOV A , # 40 
013C    D5E0FD        3515     	DJNZ ACC,	$
                      3516     ENDIF
                      3517     PWM_BFET_DAMPED_DONE: 
                      3518     	BNFET_ON								; Switch nFET
013F    D292          3518+1   SETB P1 . 2 
                      3519     PWM_BFET_DAMPED_EXIT: 
0141    01B7          3520     	AJMP	T0_INT_PWM_ON_EXIT
                      3521     
                      3522     PWM_CFET_DAMPED: 	
                      3523     IF NFETON_DELAY NE 0
                      3524     	CPFET_OFF
0143    C291          3524+1   CLR P1 . 1 
                      3525     ENDIF
0145    30680A        3526     JNB FLAGS1 . 0 , PWM_CFET_DAMPED_EXIT 
0148    206507        3527     JB FLAGS0 . 5 , PWM_CFET_DAMPED_EXIT 
                      3528     IF NFETON_DELAY NE 0
014B    7428          3529     MOV A , # 40 
014D    D5E0FD        3530     	DJNZ ACC,	$
                      3531     ENDIF
                      3532     PWM_CFET_DAMPED_DONE: 
                      3533     	CNFET_ON								; Switch nFET
0150    D290          3533+1   SETB P1 . 0 
                      3534     PWM_CFET_DAMPED_EXIT:  
0152    01B7          3535     	AJMP	T0_INT_PWM_ON_EXIT
                      3536     
                      3537     
                      3538     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3539     ;
                      3540     ; Timer2 interrupt routine
                      3541     ;
                      3542     ; No assumptions
                      3543     ;
                      3544     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3545     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
0154    C2AF          3546     	CLR	EA
0156    C2AD          3547     	CLR	ET2			; Disable timer2 interrupts
0158    53E6EF        3548     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
015B    C0D0          3549     	PUSH	PSW			; Preserve registers through interrupt
015D    C0E0          3550     	PUSH	ACC
015F    D2D3          3551     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0161    D2AF          3552     	SETB	EA
                      3553     IF MCU_48MHZ == 1
                               	MOV	A, CLOCK_SET_AT_48MHZ
                               	JZ 	T2_INT_START
                               
                               	; Check skip variable
                               	MOV	A, SKIP_T2_INT
                               	JZ	T2_INT_START				; Execute this interrupt
                               
                               	MOV	SKIP_T2_INT, #0
                               	AJMP	T2_INT_EXIT
                               
                               T2_INT_START:
                               	MOV	SKIP_T2_INT, #1			; Skip next interrupt
                               ENDIF
                      3567     	; Clear low byte interrupt flag
0163    C2CE          3568     	CLR	TF2L						; Clear interrupt flag
                      3569     	; Check RC pulse timeout counter
0165    E52A          3570     	MOV	A, RCP_TIMEOUT_CNTD			; RC pulse timeout count zero?
0167    6007          3571     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      3572     
                      3573     	; Decrement timeout counter (if PWM)
0169    207449        3574     JB FLAGS2 . 4 , T2_INT_SKIP_START 
                      3575     
016C    152A          3576     	DEC	RCP_TIMEOUT_CNTD			; No - decrement
016E    21B5          3577     	AJMP	T2_INT_SKIP_START
                      3578     
                      3579     T2_INT_PULSES_ABSENT: 
                      3580     	; Timeout counter has reached zero, pulses are absent
0170    7800          3581     MOV R0 , # 0 
0172    7900          3582     MOV R1 , # 0 
0174    20742E        3583     JB FLAGS2 . 4 , T2_INT_PULSES_ABSENT_NO_MAX 
                      3584     
                      3585     	READ_RCP_INT 					; Look at value of Rcp_In
0177    E580          3585+1   MOV A , P0 
0179    307E01        3585+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
017C    F4            3585+1   CPL A  ; YES - INVERT
017D    30E402        3586     JNB ACC . 4 , ( $+5 ) 
0180    78FF          3587     MOV R0 , # 255 
                      3588     	RCP_INT_FIRST 					; Set interrupt trig to first again
0182    53DACF        3588+1   ANL PCA0CPM0 , # 0CFH 
0185    207E03        3588+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0188    43DA20        3588+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
018B    307E03        3588+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
018E    43DA10        3588+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3589     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0191    C2D8          3589+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0193    C271          3590     CLR FLAGS2 . 1 
                      3591     	READ_RCP_INT 					; Look once more at value of Rcp_In
0195    E580          3591+1   MOV A , P0 
0197    307E01        3591+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
019A    F4            3591+1   CPL A  ; YES - INVERT
019B    30E402        3592     JNB ACC . 4 , ( $+5 ) 
019E    79FF          3593     MOV R1 , # 255 
01A0    C3            3594     	CLR	C
01A1    E8            3595     MOV A , R0 
01A2    99            3596     SUBB A , R1 
01A3    70CB          3597     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      3598     
                      3599     T2_INT_PULSES_ABSENT_NO_MAX: 
01A5    306103        3600     JNB FLAGS0 . 1 , ( $+6 ) 
                      3601     
01A8    752A18        3602     MOV RCP_TIMEOUT_CNTD , # 24 
                      3603     
01AB    207403        3604     JB FLAGS2 . 4 , T2_INT_PPM_TIMEOUT_SET 
                      3605     
01AE    752A18        3606     MOV RCP_TIMEOUT_CNTD , # 24 
                      3607     
                      3608     T2_INT_PPM_TIMEOUT_SET: 
01B1    885C          3609     MOV NEW_RCP , R0 
01B3    D270          3610     SETB FLAGS2 . 0 
                      3611     
                      3612     T2_INT_SKIP_START: 
01B5    20740D        3613     JB FLAGS2 . 4 , T2_INT_RCP_UPDATE_START 
                      3614     
                      3615     	; Check RC pulse skip counter
01B8    E52B          3616     	MOV	A, RCP_SKIP_CNTD			
01BA    6004          3617     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      3618     	
                      3619     	; Decrement skip counter (only if edge counter is zero)
01BC    152B          3620     	DEC	RCP_SKIP_CNTD				; Decrement
01BE    21C5          3621     	AJMP	T2_INT_RCP_UPDATE_START
                      3622     
                      3623     T2_INT_SKIP_END: 
                      3624     	; Skip counter has reached zero, start looking for RC pulses again
                      3625     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
01C0    43DA01        3625+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      3626     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
01C3    C2D8          3626+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3627     	
                      3628     T2_INT_RCP_UPDATE_START: 
                      3629     	; Process updated RC pulse
01C5    207002        3630     JB FLAGS2 . 0 , ( $+5 ) 
01C8    4138          3631     	AJMP	T2_INT_CURRENT_PWM_UPDATE	; No - update pwm limits and exit
                      3632     
01CA    A85C          3633     MOV R0 , NEW_RCP 
01CC    206102        3634     JB FLAGS0 . 1 , ( $+5 ) 
                      3635     
01CF    C270          3636     CLR FLAGS2 . 0 
                      3637     
                      3638     	; Use a gain of 1.0625x for pwm input if not governor mode
01D1    207431        3639     JB FLAGS2 . 4 , T2_INT_PWM_MIN_RUN 
                      3640     
                      3641     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ELSE
                      3644     
                      3645     IF MODE == 2	; Multi 
                               	MOV	TEMP2, #PGM_GOV_MODE		; Closed loop mode?
                               	CJNE	@TEMP2, #4, T2_INT_PWM_MIN_RUN; Yes - branch
                               ENDIF
                      3649     
                      3650     	; Limit the maximum value to avoid wrap when scaled to pwm range
01D4    C3            3651     	CLR	C
01D5    E8            3652     MOV A , R0 
01D6    94F0          3653     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
01D8    4003          3654     	JC	T2_INT_RCP_UPDATE_MULT
                      3655     
01DA    74F0          3656     	MOV	A, #240			; Set requested pwm to max
01DC    F8            3657     MOV R0 , A 
                      3658     
                      3659     T2_INT_RCP_UPDATE_MULT: 	
                      3660     	; Multiply by 1.0625 (optional adjustment gyro gain)
01DD    E8            3661     MOV A , R0 
01DE    C4            3662     	SWAP	A			; After this "0.0625"
01DF    540F          3663     	ANL	A, #0FH
01E1    28            3664     ADD A , R0 
01E2    F8            3665     MOV R0 , A 
                      3666     	; Adjust tail gain
01E3    7984          3667     MOV R1 , # PGM_MOTOR_GAIN 
01E5    B70302        3668     CJNE @ R1 , # 3 , ( $+5 ) 
01E8    4105          3669     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      3670     
01EA    C3            3671     	CLR	C
01EB    13            3672     	RRC	A			; After this "0.5"
01EC    C3            3673     	CLR	C
01ED    13            3674     	RRC	A			; After this "0.25"
01EE    8721          3675     MOV BIT_ACCESS_INT , @ R1 
01F0    200802        3676     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      3677     
01F3    C3            3678     	CLR	C
01F4    13            3679     	RRC	A			; After this "0.125"
                      3680     
                      3681     T2_INT_RCP_GAIN_CORR: 
01F5    200A06        3682     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      3683     
01F8    C3            3684     	CLR	C
01F9    C8            3685     XCH A , R0 
01FA    98            3686     SUBB A , R0 
01FB    F8            3687     MOV R0 , A 
01FC    4105          3688     	AJMP	T2_INT_PWM_MIN_RUN
                      3689     
                      3690     T2_INT_RCP_GAIN_POS: 
01FE    28            3691     ADD A , R0 
01FF    F8            3692     MOV R0 , A 
0200    5003          3693     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      3694     
0202    74FF          3695     	MOV	A, #0FFH					; Yes - limit
0204    F8            3696     MOV R0 , A 
                      3697     ENDIF
                      3698     
                      3699     T2_INT_PWM_MIN_RUN:  
                      3700     IF MODE == 1	; Tail - limit minimum pwm
                      3701     	; Limit minimum pwm
0205    C3            3702     	CLR	C
0206    E8            3703     MOV A , R0 
0207    9565          3704     	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
0209    5003          3705     	JNC	T2_INT_PWM_UPDATE			; No - branch
                      3706     
020B    E565          3707     	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
020D    F8            3708     MOV R0 , A 
                      3709     ENDIF
                      3710     
                      3711     T2_INT_PWM_UPDATE:  
                      3712     	; Update requested_pwm
020E    8822          3713     MOV REQUESTED_PWM , R0 
                      3714     IF MODE >= 1	; Tail or multi
                      3715     	; Boost pwm during direct start
0210    E52D          3716     	MOV	A, FLAGS1
0212    5406          3717     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0214    6022          3718     	JZ	T2_INT_CURRENT_PWM_UPDATE
                      3719     
0216    206B1F        3720     JB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      3721     
0219    E536          3722     	MOV	A, STALL_CNT				; Add an extra power boost for each attempt
021B    C3            3723     	CLR	C
021C    33            3724     	RLC	A
021D    C3            3725     	CLR	C
021E    33            3726     	RLC	A
021F    F8            3727     MOV R0 , A 
0220    E564          3728     	MOV	A, PWM_SPOOLUP_BEG			; Set 25% of max startup power as minimum power
0222    C3            3729     	CLR	C
0223    13            3730     	RRC	A
0224    C3            3731     	CLR	C
0225    13            3732     	RRC	A
0226    F9            3733     MOV R1 , A 
0227    C3            3734     	CLR	C
0228    9522          3735     	SUBB	A, REQUESTED_PWM
022A    4002          3736     	JC	($+4)
                      3737     
022C    8922          3738     MOV REQUESTED_PWM , R1 
                      3739     
022E    E8            3740     MOV A , R0 
022F    2522          3741     	ADD	A, REQUESTED_PWM			
0231    F522          3742     	MOV	REQUESTED_PWM, A
0233    5003          3743     	JNC	($+5)
                      3744     
0235    7522FF        3745     	MOV	REQUESTED_PWM, #0FFH
                      3746     
                      3747     ENDIF
                      3748     T2_INT_CURRENT_PWM_UPDATE:  
                      3749     IF MODE == 0 OR MODE == 2	; Main or multi
                               	MOV	TEMP1, #PGM_GOV_MODE		; Governor mode?
                               	CJNE	@TEMP1, #4, T2_INT_EXIT		; Yes - branch
                               ENDIF
                      3753     
0238    852224        3754     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      3755     IF MODE >= 1	; Tail or multi
                      3756     	; Set current_pwm_limited
023B    A824          3757     MOV R0 , CURRENT_PWM 
023D    C3            3758     	CLR	C
023E    E524          3759     	MOV	A, CURRENT_PWM				; Check against limit
0240    9561          3760     	SUBB	A, PWM_LIMIT
0242    4002          3761     	JC	($+4)					; If current pwm below limit - branch
                      3762     
0244    A861          3763     MOV R0 , PWM_LIMIT 
                      3764     
                      3765     IF MODE == 2	; Multi
                               	; Limit pwm for low rpms
                               	CLR	C
                               	MOV	A, TEMP1					; Check against limit
                               	SUBB	A, PWM_LIMIT_BY_RPM
                               	JC	($+4)					; If current pwm below limit - branch
                               
                               	MOV	TEMP1, PWM_LIMIT_BY_RPM		; Limit pwm
                               
                               ENDIF
0246    8825          3775     MOV CURRENT_PWM_LIMITED , R0 
                      3776     	; Dither
0248    E566          3777     	MOV	A, PWM_DITHER_DECODED		; Load pwm dither
024A    7002          3778     	JNZ	($+4)					; If active - branch
024C    417C          3779     	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                      3780     
024E    C3            3781     	CLR	C
024F    E8            3782     MOV A , R0 
0250    AA66          3783     MOV R2 , PWM_DITHER_DECODED 
0252    9A            3784     SUBB A , R2 
0253    5003          3785     	JNC	T2_INT_CURRENT_PWM_FULL_DITHER; If pwm more than dither value, then do full dither
                      3786     
0255    E8            3787     MOV A , R0 
0256    FA            3788     MOV R2 , A 
0257    E4            3789     	CLR	A						; Set pwm minus dither
                      3790     
                      3791     T2_INT_CURRENT_PWM_FULL_DITHER: 
0258    F9            3792     MOV R1 , A 
0259    EA            3793     MOV A , R2 
025A    C3            3794     	CLR	C
025B    33            3795     	RLC	A						; Shift left once
025C    FB            3796     MOV R3 , A 
025D    E568          3797     	MOV	A, RANDOM					; Load random number
025F    F4            3798     	CPL	A						; Invert to create proper DC bias in random code
0260    5B            3799     ANL A , R3 
0261    29            3800     ADD A , R1 
0262    400D          3801     	JC	T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER	; If dither cause power above max - branch and increase excess 
                      3802     
0264    2567          3803     	ADD	A, PWM_DITHER_EXCESS_POWER	; Add excess power from previous cycles
0266    F8            3804     MOV R0 , A 
0267    E567          3805     	MOV	A, PWM_DITHER_EXCESS_POWER	; Decrement excess power
0269    6002          3806     	JZ	($+4)
026B    1567          3807     	DEC	PWM_DITHER_EXCESS_POWER
026D    400B          3808     	JC	T2_INT_CURRENT_PWM_DITHER_MAX_POWER; If dither cause power above max - branch
                      3809     
026F    417C          3810     	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                      3811     
                      3812     T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER: 
0271    0A            3813     INC R2 
0272    C3            3814     	CLR	C
0273    E567          3815     	MOV	A, PWM_DITHER_EXCESS_POWER
0275    9A            3816     SUBB A , R2 
0276    5002          3817     	JNC	($+4)
0278    0567          3818     	INC	PWM_DITHER_EXCESS_POWER
                      3819     
                      3820     T2_INT_CURRENT_PWM_DITHER_MAX_POWER: 
027A    78FF          3821     MOV R0 , # 255 
                      3822     
                      3823     T2_INT_CURRENT_PWM_NO_DITHER: 
027C    8826          3824     MOV CURRENT_PWM_LIM_DITH , R0 
                      3825     IF DAMPED_MODE_ENABLE == 1
                               	; Skip damping fet switching for high throttle
                               	CLR	FLAGS1.SKIP_DAMP_ON
                               	CLR	C
                               	MOV	A, CURRENT_PWM_LIM_DITH
                               	SUBB	A, #248
                               	JC	T2_INT_EXIT
                               	SETB	FLAGS1.SKIP_DAMP_ON
                               ENDIF
                      3834     ENDIF
                      3835     T2_INT_EXIT: 	
                      3836     	; Check if high byte flag is set
027E    20CF0A        3837     	JB	TF2H, T2H_INT		
0281    D0E0          3838     	POP	ACC			; Restore preserved registers
0283    D0D0          3839     	POP	PSW
0285    43E610        3840     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0288    D2AD          3841     	SETB	ET2			; Enable timer2 interrupts
028A    32            3842     	RETI
                      3843     
                      3844     T2H_INT: 
                      3845     	; High byte interrupt (happens every 32ms)
028B    C2CF          3846     	CLR	TF2H					; Clear interrupt flag
028D    053A          3847     	INC	TIMER2_X
                      3848     IF MCU_48MHZ == 1
                               	MOV	A, CLOCK_SET_AT_48MHZ
                               	JZ 	T2H_INT_START
                               
                               	; Check skip variable
                               	MOV	A, SKIP_T2H_INT
                               	JZ	T2H_INT_START				; Execute this interrupt
                               
                               	MOV	SKIP_T2H_INT, #0
                               	AJMP	T2H_INT_EXIT
                               
                               T2H_INT_START:
                               	MOV	SKIP_T2H_INT, #1			; Skip next interrupt
                               ENDIF
028F    7801          3862     MOV R0 , # 1 
                      3863     	; Check RC pulse timeout counter (used here for PPM only)
0291    E52A          3864     	MOV	A, RCP_TIMEOUT_CNTD			; RC pulse timeout count zero?
0293    6005          3865     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      3866     
                      3867     	; Decrement timeout counter (if PPM)
0295    307402        3868     JNB FLAGS2 . 4 , T2H_INT_RCP_STOP_CHECK 
                      3869     
0298    152A          3870     	DEC	RCP_TIMEOUT_CNTD			; No flag set (PPM) - decrement
                      3871     
                      3872     T2H_INT_RCP_STOP_CHECK: 
                      3873     	; Check RC pulse against stop value
029A    C3            3874     	CLR	C
029B    E55C          3875     	MOV	A, NEW_RCP				; Load new pulse value
029D    9401          3876     SUBB A , # 1 
029F    4005          3877     	JC	T2H_INT_RCP_STOP
                      3878     
                      3879     	; RC pulse higher than stop value, reset stop counter
02A1    755F00        3880     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
02A4    41B7          3881     	AJMP	T2H_INT_RCP_GOV_PWM
                      3882     
                      3883     T2H_INT_RCP_STOP: 	
                      3884     	; RC pulse less than stop value
02A6    756000        3885     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
02A9    756900        3886     	MOV	SPOOLUP_LIMIT_CNT, #0
02AC    E55F          3887     	MOV	A, RCP_STOP_CNT			; Increment stop counter
02AE    2401          3888     	ADD	A, #1
02B0    F55F          3889     	MOV	RCP_STOP_CNT, A
02B2    5003          3890     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      3891     
02B4    755FFF        3892     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      3893     
                      3894     T2H_INT_RCP_GOV_PWM: 
                      3895     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	JNB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_GOV_BY_TX; If governor not active - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	JNB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_GOV_BY_TX; If governor not active - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #8						; Default fast increase for spoolup time of zero
                               	MOV	A, MAIN_SPOOLUP_TIME_3X
                               	JZ	T2H_INT_RCP_INC_LIMIT			; Jump for spoolup time of zero
                               
                               	MOV	TEMP1, #5						; Default fast increase
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_3X			; No spoolup until 3*N*32ms
                               
                               	JC	T2H_INT_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_10X			; Slow spoolup until "100"*N*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_15X			; Faster spoolup until "150"*N*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	JB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_INC_LIMIT	; If governor active - branch 
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, MAIN_SPOOLUP_TIME_3X	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_EXIT					; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      4025     T2H_INT_EXIT: 
02B7    D0E0          4026     	POP	ACC			; Restore preserved registers
02B9    D0D0          4027     	POP	PSW
02BB    43E610        4028     	ORL	EIE1, #10H	; Enable PCA0 interrupts
02BE    D2AD          4029     	SETB	ET2			; Enable timer2 interrupts
02C0    32            4030     	RETI
                      4031     
                      4032     
                      4033     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4034     ;
                      4035     ; Timer3 interrupt routine
                      4036     ;
                      4037     ; No assumptions
                      4038     ;
                      4039     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4040     T3_INT: 	; Used for commutation timing
02C1    C2AF          4041     	CLR 	EA				; Disable all interrupts
02C3    53E67F        4042     	ANL	EIE1, #7FH		; Disable timer3 interrupts
02C6    7592FA        4043     	MOV	TMR3RLL, #0FAH		; Set a short delay before next interrupt
02C9    7593FF        4044     	MOV	TMR3RLH, #0FFH
02CC    C260          4045     CLR FLAGS0 . 0 
02CE    759104        4046     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
02D1    D2AF          4047     	SETB	EA				; Enable all interrupts
02D3    32            4048     	RETI
                      4049     
                      4050     
                      4051     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4052     ;
                      4053     ; PCA interrupt routine
                      4054     ;
                      4055     ; No assumptions
                      4056     ;
                      4057     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4058     PCA_INT: 	; Used for RC pulse timing
02D4    C2AF          4059     	CLR	EA
02D6    53E6EF        4060     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
02D9    C2AD          4061     	CLR	ET2			; Disable timer2 interrupts
02DB    C0D0          4062     	PUSH	PSW			; Preserve registers through interrupt
02DD    C0E0          4063     	PUSH	ACC
02DF    C0F0          4064     	PUSH	B
02E1    D2D3          4065     	SETB	PSW.3		; Select register bank 1 for interrupt routines
02E3    D2AF          4066     	SETB	EA
                      4067     	; Get the PCA counter values
                      4068     	GET_RCP_CAPTURE_VALUES
02E5    A8FB          4068+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
02E7    A9FC          4068+1   MOV R1 , PCA0CPH0 
                      4069     	; Clear interrupt flag
                      4070     	RCP_CLEAR_INT_FLAG 				
02E9    C2D8          4070+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      4071     	; Check which edge it is
02EB    307102        4072     JNB FLAGS2 . 1 , ( $+5 ) 
02EE    613B          4073     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      4074     
                      4075     	RCP_INT_SECOND					; Yes - set second edge trig
02F0    53DACF        4075+1   ANL PCA0CPM0 , # 0CFH 
02F3    207E03        4075+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
02F6    43DA10        4075+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
02F9    307E03        4075+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
02FC    43DA20        4075+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
02FF    D271          4076     SETB FLAGS2 . 1 
                      4077     	; Read RC signal level
                      4078     	READ_RCP_INT			
0301    E580          4078+1   MOV A , P0 
0303    307E01        4078+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0306    F4            4078+1   CPL A  ; YES - INVERT
                      4079     	; Test RC signal level
0307    20E402        4080     JB ACC . 4 , ( $+5 ) 
030A    6112          4081     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      4082     
                      4083     	; RC pulse was high, store RC pulse start timestamp
030C    8827          4084     MOV RCP_PREV_EDGE_L , R0 
030E    8928          4085     MOV RCP_PREV_EDGE_H , R1 
0310    A160          4086     	AJMP	PCA_INT_EXIT				; Exit
                      4087     
                      4088     PCA_INT_FAIL_MINIMUM: 
                      4089     	; Prepare for next interrupt
                      4090     	RCP_INT_FIRST					; Set interrupt trig to first again
0312    53DACF        4090+1   ANL PCA0CPM0 , # 0CFH 
0315    207E03        4090+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0318    43DA20        4090+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
031B    307E03        4090+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
031E    43DA10        4090+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      4091     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0321    C2D8          4091+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0323    C271          4092     CLR FLAGS2 . 1 
0325    307402        4093     JNB FLAGS2 . 4 , ( $+5 ) 
                      4094     
0328    A14C          4095     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      4096     
032A    7800          4097     MOV R0 , # 0 
                      4098     	READ_RCP_INT 					; Test RC signal level again
032C    E580          4098+1   MOV A , P0 
032E    307E01        4098+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0331    F4            4098+1   CPL A  ; YES - INVERT
0332    30E402        4099     JNB ACC . 4 , ( $+5 ) 
                      4100     
0335    A14C          4101     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      4102     
0337    885C          4103     MOV NEW_RCP , R0 
0339    A134          4104     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      4105     
                      4106     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      4107     	; Prepare for next interrupt
                      4108     	RCP_INT_FIRST 					; Set first edge trig
033B    53DACF        4108+1   ANL PCA0CPM0 , # 0CFH 
033E    207E03        4108+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0341    43DA20        4108+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0344    307E03        4108+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0347    43DA10        4108+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
034A    C271          4109     CLR FLAGS2 . 1 
                      4110     	; Check if pwm frequency shall be measured
034C    206102        4111     JB FLAGS0 . 1 , ( $+5 ) 
034F    8114          4112     	AJMP	PCA_INT_FALL				; No - skip measurements
                      4113     
                      4114     	; Set second edge trig only during pwm frequency measurement
                      4115     	RCP_INT_SECOND 				; Set second edge trig
0351    53DACF        4115+1   ANL PCA0CPM0 , # 0CFH 
0354    207E03        4115+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0357    43DA10        4115+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
035A    307E03        4115+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
035D    43DA20        4115+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      4116     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0360    C2D8          4116+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0362    D271          4117     SETB FLAGS2 . 1 
                      4118     	; Store edge data to RAM
0364    8857          4119     MOV RCP_EDGE_L , R0 
0366    8958          4120     MOV RCP_EDGE_H , R1 
                      4121     	; Calculate pwm frequency
0368    C3            4122     	CLR	C
0369    E8            4123     MOV A , R0 
036A    9555          4124     	SUBB	A, RCP_PREPREV_EDGE_L	
036C    F8            4125     MOV R0 , A 
036D    E9            4126     MOV A , R1 
036E    9556          4127     	SUBB	A, RCP_PREPREV_EDGE_H
0370    F9            4128     MOV R1 , A 
0371    7B00          4129     MOV R3 , # 0 
0373    7E08          4130     MOV R6 , # 8 
0375    7A00          4131     MOV R2 , # 0 
                      4132     	; Check if pulse is too short
0377    C3            4133     	CLR	C
0378    E8            4134     MOV A , R0 
0379    948C          4135     	SUBB	A, #LOW(140)				; If pulse below 70us, not accepted
037B    E9            4136     MOV A , R1 
037C    9400          4137     	SUBB	A, #HIGH(140)
037E    5005          4138     	JNC	PCA_INT_CHECK_12KHZ
                      4139     
0380    755B00        4140     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0	; Set not accepted 
0383    8106          4141     	AJMP	PCA_INT_STORE_DATA
                      4142     
                      4143     PCA_INT_CHECK_12KHZ: 
0385    8821          4144     MOV BIT_ACCESS_INT , R0 
0387    78A2          4145     MOV R0 , # PGM_ENABLE_PWM_INPUT 
0389    E6            4146     MOV A , @ R0 
038A    A821          4147     MOV R0 , BIT_ACCESS_INT 
038C    6055          4148     	JZ	PCA_INT_RESTORE_EDGE		; If it is not - branch
                      4149     
                      4150     	; Check if pwm frequency is 12kHz
038E    C3            4151     	CLR	C
038F    E8            4152     MOV A , R0 
0390    94C8          4153     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
0392    E9            4154     MOV A , R1 
0393    9400          4155     	SUBB	A, #HIGH(200)
0395    5008          4156     	JNC	PCA_INT_CHECK_8KHZ
                      4157     
0397    E4            4158     	CLR	A
0398    D2E4          4159     SETB ACC . 4 
039A    FB            4160     MOV R3 , A 
039B    7A0A          4161     MOV R2 , # 10 
039D    61E1          4162     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      4163     
                      4164     PCA_INT_CHECK_8KHZ: 
                      4165     	; Check if pwm frequency is 8kHz
039F    C3            4166     	CLR	C
03A0    E8            4167     MOV A , R0 
03A1    9468          4168     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
03A3    E9            4169     MOV A , R1 
03A4    9401          4170     	SUBB	A, #HIGH(360)
03A6    5008          4171     	JNC	PCA_INT_CHECK_4KHZ
                      4172     
03A8    E4            4173     	CLR	A
03A9    D2E3          4174     SETB ACC . 3 
03AB    FB            4175     MOV R3 , A 
03AC    7A0F          4176     MOV R2 , # 15 
03AE    61E1          4177     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      4178     
                      4179     PCA_INT_CHECK_4KHZ: 
                      4180     	; Check if pwm frequency is 4kHz
03B0    C3            4181     	CLR	C
03B1    E8            4182     MOV A , R0 
03B2    94D0          4183     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
03B4    E9            4184     MOV A , R1 
03B5    9402          4185     	SUBB	A, #HIGH(720)
03B7    5008          4186     	JNC	PCA_INT_CHECK_2KHZ
                      4187     
03B9    E4            4188     	CLR	A
03BA    D2E2          4189     SETB ACC . 2 
03BC    FB            4190     MOV R3 , A 
03BD    7A1E          4191     MOV R2 , # 30 
03BF    61E1          4192     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      4193     
                      4194     PCA_INT_CHECK_2KHZ: 
                      4195     	; Check if pwm frequency is 2kHz
03C1    C3            4196     	CLR	C
03C2    E8            4197     MOV A , R0 
03C3    94A0          4198     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
03C5    E9            4199     MOV A , R1 
03C6    9405          4200     	SUBB	A, #HIGH(1440)
03C8    5008          4201     	JNC	PCA_INT_CHECK_1KHZ
                      4202     
03CA    E4            4203     	CLR	A
03CB    D2E1          4204     SETB ACC . 1 
03CD    FB            4205     MOV R3 , A 
03CE    7A3C          4206     MOV R2 , # 60 
03D0    61E1          4207     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      4208     
                      4209     PCA_INT_CHECK_1KHZ: 
                      4210     	; Check if pwm frequency is 1kHz
03D2    C3            4211     	CLR	C
03D3    E8            4212     MOV A , R0 
03D4    9498          4213     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
03D6    E9            4214     MOV A , R1 
03D7    9408          4215     	SUBB	A, #HIGH(2200)
03D9    5008          4216     	JNC	PCA_INT_RESTORE_EDGE
                      4217     
03DB    E4            4218     	CLR	A
03DC    D2E0          4219     SETB ACC . 0 
03DE    FB            4220     MOV R3 , A 
03DF    7A78          4221     MOV R2 , # 120 
                      4222     
                      4223     PCA_INT_RESTORE_EDGE_SET_MSB: 
03E1    7E00          4224     MOV R6 , # 0 
                      4225     PCA_INT_RESTORE_EDGE: 
                      4226     	; Calculate difference between this period and previous period
03E3    C3            4227     	CLR	C
03E4    E8            4228     MOV A , R0 
03E5    9559          4229     	SUBB	A, RCP_PREV_PERIOD_L
03E7    FC            4230     MOV R4 , A 
03E8    E9            4231     MOV A , R1 
03E9    955A          4232     	SUBB	A, RCP_PREV_PERIOD_H
03EB    FD            4233     MOV R5 , A 
                      4234     	; Make positive
03EC    30E70A        4235     	JNB	ACC.7, PCA_INT_CHECK_DIFF
03EF    EC            4236     MOV A , R4 
03F0    F4            4237     	CPL	A
03F1    2401          4238     	ADD	A, #1
03F3    FC            4239     MOV R4 , A 
03F4    ED            4240     MOV A , R5 
03F5    F4            4241     	CPL	A
03F6    3400          4242     	ADDC	A, #0
03F8    FD            4243     MOV R5 , A 
                      4244     
                      4245     PCA_INT_CHECK_DIFF: 
                      4246     	; Check difference
03F9    755B00        4247     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
03FC    C3            4248     	CLR	C
03FD    EC            4249     MOV A , R4 
03FE    9A            4250     SUBB A , R2 
03FF    ED            4251     MOV A , R5 
0400    9E            4252     SUBB A , R6 
0401    5003          4253     	JNC	PCA_INT_STORE_DATA
                      4254     
0403    755B01        4255     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      4256     
                      4257     PCA_INT_STORE_DATA: 
                      4258     	; Store previous period
0406    8859          4259     MOV RCP_PREV_PERIOD_L , R0 
0408    895A          4260     MOV RCP_PREV_PERIOD_H , R1 
                      4261     	; Store pre previous edge
040A    855755        4262     	MOV	RCP_PREPREV_EDGE_L, RCP_EDGE_L
040D    855856        4263     	MOV	RCP_PREPREV_EDGE_H, RCP_EDGE_H
0410    7802          4264     MOV R0 , # 2 
0412    A134          4265     	AJMP	PCA_INT_LIMITED
                      4266     
                      4267     PCA_INT_FALL: 
                      4268     	; RC pulse edge was second, calculate new pulse length
0414    C3            4269     	CLR	C
0415    E8            4270     MOV A , R0 
0416    9527          4271     	SUBB	A, RCP_PREV_EDGE_L	
0418    F8            4272     MOV R0 , A 
0419    E9            4273     MOV A , R1 
041A    9528          4274     	SUBB	A, RCP_PREV_EDGE_H
041C    F9            4275     MOV R1 , A 
                      4276     	
                      4277     	; Rescale our Multishot signal to a Oneshot125 Signal range		
                      4278     	
041D    C3            4279     	CLR	C						; clear carry flag		
041E    E9            4280     MOV A , R1 
041F    13            4281     	RRC	A						; rotate right through the carry flag		
0420    F9            4282     MOV R1 , A 
0421    E8            4283     MOV A , R0 
0422    13            4284     	RRC	A						; rotate right through the carry flag		
0423    F8            4285     MOV R0 , A 
                      4286     									;60-300; 61-306		
0424    C3            4287     	CLR	C						; clear carry flag		
0425    E8            4288     MOV A , R0 
0426    24B4          4289       ADD A,	#180    ;Add the second low-byte to the accumulator		
0428    FC            4290     MOV R4 , A 
0429    E9            4291     MOV A , R1 
042A    3400          4292       ADDC A,	#0     	;Add the second high-byte to the accumulator, plus carry.		
042C    FD            4293     MOV R5 , A 
                      4294     									;240 - 480		
042D    814E          4295     	AJMP	PCA_INT_FALL_CHECK_RANGE 	; consider this a valid MS signal - move to I_Temp5/6 		
                      4296     					
                      4297     	; End Multishot to Oneshot Signal Scaling		
                      4298     
                      4299     PCA_INT_FALL_NOT_ONESHOT: 
042F    E9            4300     MOV A , R1 
0430    C3            4301     	CLR	C
0431    13            4302     	RRC	A
0432    F9            4303     MOV R1 , A 
0433    E8            4304     MOV A , R0 
0434    13            4305     	RRC	A
0435    F8            4306     MOV R0 , A 
                      4307     
0436    307902        4308     JNB FLAGS3 . 1 , ( $+5 ) 
0439    A111          4309     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      4310     
043B    E9            4311     MOV A , R1 
043C    C3            4312     	CLR	C
043D    13            4313     	RRC	A
043E    F9            4314     MOV R1 , A 
043F    E8            4315     MOV A , R0 
0440    13            4316     	RRC	A
0441    F8            4317     MOV R0 , A 
                      4318     
0442    307802        4319     JNB FLAGS3 . 0 , ( $+5 ) 
0445    A111          4320     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      4321     
0447    E9            4322     MOV A , R1 
0448    C3            4323     	CLR	C
0449    13            4324     	RRC	A
044A    FD            4325     MOV R5 , A 
044B    E8            4326     MOV A , R0 
044C    13            4327     	RRC	A
044D    FC            4328     MOV R4 , A 
                      4329     PCA_INT_FALL_CHECK_RANGE: 
                      4330     	; Skip range limitation if pwm frequency measurement
044E    20612C        4331     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      4332     
                      4333     	; Check if 2160us or above (in order to ignore false pulses)
0451    C3            4334     	CLR	C
0452    EC            4335     MOV A , R4 
0453    9482          4336     	SUBB	A, #130						; Multishot Re-scale
0455    ED            4337     MOV A , R5 
0456    9402          4338     	SUBB A, #2
0458    4002          4339     	JC	($+4)						; No - proceed
                      4340     
045A    8165          4341     	AJMP	PCA_INT_PPM_OUTSIDE_RANGE		; Yes - ignore pulse
                      4342     
                      4343     PCA_INT_PPM_BELOW_FULL_RANGE: 
                      4344     	; Check if below 800us (in order to ignore false pulses)
045C    ED            4345     MOV A , R5 
045D    701E          4346     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      4347     
045F    C3            4348     	CLR	C
0460    EC            4349     MOV A , R4 
0461    94C8          4350     	SUBB	A, #200
0463    5018          4351     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      4352     
                      4353     PCA_INT_PPM_OUTSIDE_RANGE: 
0465    0529          4354     	INC	RCP_OUTSIDE_RANGE_CNT
0467    E529          4355     	MOV	A, RCP_OUTSIDE_RANGE_CNT
0469    7002          4356     	JNZ	($+4)
                      4357     
046B    1529          4358     	DEC	RCP_OUTSIDE_RANGE_CNT
                      4359     
046D    C3            4360     	CLR	C
046E    E529          4361     	MOV	A, RCP_OUTSIDE_RANGE_CNT
0470    940A          4362     	SUBB	A, #10						; Allow a given number of outside pulses
0472    5002          4363     	JNC	($+4)			
0474    A14C          4364     	AJMP	PCA_INT_SET_TIMEOUT				; If below limit - ignore pulse
                      4365     
0476    755C00        4366     	MOV	NEW_RCP, #0					; Set pulse length to zero
0479    D270          4367     SETB FLAGS2 . 0 
047B    A14C          4368     	AJMP	PCA_INT_SET_TIMEOUT			
                      4369     
                      4370     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      4371     	; Decrement outside range counter
047D    E529          4372     	MOV	A, RCP_OUTSIDE_RANGE_CNT
047F    6002          4373     	JZ	($+4)
                      4374     
0481    1529          4375     	DEC	RCP_OUTSIDE_RANGE_CNT
                      4376     
                      4377     	; Calculate "1000us" plus throttle minimum
                      4378     IF MODE >= 1	; Tail or multi
0483    7888          4379     MOV R0 , # PGM_DIRECTION 
0485    E6            4380     MOV A , @ R0 
0486    F9            4381     MOV R1 , A 
                      4382     ENDIF
0487    7400          4383     	MOV	A, #0						; Set 1000us as default minimum
0489    207F08        4384     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      4385     
048C    7896          4386     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      4387     IF MODE >= 1	; Tail or multi
048E    B90302        4388     CJNE R1 , # 3 , ( $+5 ) 
                      4389     
0491    789E          4390     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      4391     ENDIF
0493    E6            4392     MOV A , @ R0 
                      4393     
                      4394     PCA_INT_PPM_CALCULATE: 
0494    24FA          4395     	ADD	A, #250						; Add 1000us to minimum
0496    FE            4396     MOV R6 , A 
0497    E4            4397     	CLR	A
0498    3400          4398     	ADDC	A, #0
049A    FF            4399     MOV R7 , A 
                      4400     
049B    C3            4401     	CLR	C
049C    EC            4402     MOV A , R4 
049D    9E            4403     SUBB A , R6 
049E    FC            4404     MOV R4 , A 
049F    ED            4405     MOV A , R5 
04A0    9F            4406     SUBB A , R7 
04A1    FD            4407     MOV R5 , A 
                      4408     IF MODE >= 1	; Tail or multi
04A2    9208          4409     	MOV	BIT_ACCESS_INT.0, C
04A4    B90310        4410     CJNE R1 , # 3 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4411     
04A7    A208          4412     	MOV	C, BIT_ACCESS_INT.0
04A9    5007          4413     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      4414     
                      4415     PCA_INT_PPM_BIDIR_REV: 
04AB    207609        4416     JB FLAGS2 . 6 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4417     
04AE    D276          4418     SETB FLAGS2 . 6 
04B0    81B7          4419     	AJMP	PCA_INT_PPM_BIDIR_DIR_SET
                      4420     
                      4421     PCA_INT_PPM_BIDIR_FWD: 
04B2    307602        4422     JNB FLAGS2 . 6 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4423     
04B5    C276          4424     CLR FLAGS2 . 6 
                      4425     
                      4426     PCA_INT_PPM_BIDIR_DIR_SET: 
04B7    A208          4427     	MOV	C, BIT_ACCESS_INT.0
                      4428     ENDIF
04B9    5016          4429     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      4430     
                      4431     IF MODE >= 1	; Tail or multi
04BB    B9030D        4432     CJNE R1 , # 3 , PCA_INT_PPM_UNIDIR_NEG 
                      4433     
04BE    EC            4434     MOV A , R4 
04BF    F4            4435     	CPL	A
04C0    2401          4436     	ADD	A, #1
04C2    FC            4437     MOV R4 , A 
04C3    ED            4438     MOV A , R5 
04C4    F4            4439     	CPL	A
04C5    3400          4440     	ADDC	A, #0
04C7    FD            4441     MOV R5 , A 
04C8    0204D1        4442     	JMP	PCA_INT_PPM_NEG_CHECKED
                      4443     
                      4444     PCA_INT_PPM_UNIDIR_NEG: 
                      4445     ENDIF
04CB    7800          4446     MOV R0 , # 0 
04CD    7900          4447     MOV R1 , # 0 
04CF    A118          4448     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4449     
                      4450     PCA_INT_PPM_NEG_CHECKED: 
                      4451     IF MODE >= 1	; Tail or multi
04D1    B90315        4452     CJNE R1 , # 3 , PCA_INT_PPM_BIDIR_DONE 
                      4453     
04D4    EC            4454     MOV A , R4 
04D5    33            4455     	RLC	A
04D6    FC            4456     MOV R4 , A 
04D7    ED            4457     MOV A , R5 
04D8    33            4458     	RLC	A
04D9    FD            4459     MOV R5 , A 
04DA    C3            4460     	CLR	C							; Subtract deadband
04DB    EC            4461     MOV A , R4 
04DC    940A          4462     	SUBB	A, #10		
04DE    FC            4463     MOV R4 , A 
04DF    ED            4464     MOV A , R5 
04E0    9400          4465     	SUBB	A, #0
04E2    FD            4466     MOV R5 , A 
04E3    5004          4467     	JNC	PCA_INT_PPM_BIDIR_DONE
                      4468     
04E5    7C00          4469     MOV R4 , # 0 
04E7    7D00          4470     MOV R5 , # 0 
                      4471     
                      4472     PCA_INT_PPM_BIDIR_DONE: 
                      4473     ENDIF
04E9    C3            4474     	CLR	C							; Check that RC pulse is within legal range (max 255)
04EA    EC            4475     MOV A , R4 
04EB    94FF          4476     SUBB A , # 255 
04ED    ED            4477     MOV A , R5 
04EE    9400          4478     	SUBB	A, #0
04F0    4006          4479     	JC	PCA_INT_PPM_MAX_CHECKED
                      4480     
04F2    78FF          4481     MOV R0 , # 255 
04F4    7900          4482     MOV R1 , # 0 
04F6    A118          4483     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4484     
                      4485     PCA_INT_PPM_MAX_CHECKED: 
04F8    EC            4486     MOV A , R4 
04F9    8572F0        4487     	MOV	B, PPM_THROTTLE_GAIN
04FC    A4            4488     	MUL	AB
04FD    C5F0          4489     	XCH	A, B
04FF    A2F7          4490     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0501    33            4491     	RLC	A
0502    F8            4492     MOV R0 , A 
0503    7900          4493     MOV R1 , # 0 
0505    4003          4494     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      4495     	
0507    020534        4496     	JMP	PCA_INT_LIMITED			
                      4497     
                      4498     PCA_INT_PPM_LIMIT_AFTER_MULT: 
050A    78FF          4499     MOV R0 , # 255 
050C    7900          4500     MOV R1 , # 0 
050E    020534        4501     	JMP	PCA_INT_LIMITED			
                      4502     
                      4503     PCA_INT_PWM_DIVIDE: 
0511    E9            4504     MOV A , R1 
0512    C3            4505     	CLR	C
0513    13            4506     	RRC	A
0514    F9            4507     MOV R1 , A 
0515    E8            4508     MOV A , R0 
0516    13            4509     	RRC	A
0517    F8            4510     MOV R0 , A 
                      4511     
                      4512     PCA_INT_PWM_DIVIDE_DONE: 
0518    307C0E        4513     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
051B    E9            4514     MOV A , R1 
051C    6002          4515     	JZ	($+4)
                      4516     
051E    78FF          4517     MOV R0 , # 255 
                      4518     
0520    C3            4519     	CLR	C
0521    E8            4520     MOV A , R0 
0522    13            4521     	RRC	A
0523    38            4522     ADDC A , R0 
0524    F8            4523     MOV R0 , A 
0525    E4            4524     	CLR	A
0526    3400          4525     	ADDC	A, #0
0528    F9            4526     MOV R1 , A 
                      4527     
                      4528     PCA_INT_CHECK_LEGAL_RANGE: 
                      4529     	; Check that RC pulse is within legal range
0529    C3            4530     	CLR	C
052A    E8            4531     MOV A , R0 
052B    94FF          4532     SUBB A , # 255 
052D    E9            4533     MOV A , R1 
052E    9400          4534     	SUBB	A, #0
0530    4002          4535     	JC	PCA_INT_LIMITED
                      4536     
0532    78FF          4537     MOV R0 , # 255 
                      4538     
                      4539     PCA_INT_LIMITED: 
                      4540     	; RC pulse value accepted
0534    885C          4541     MOV NEW_RCP , R0 
0536    D270          4542     SETB FLAGS2 . 0 
0538    206102        4543     JB FLAGS0 . 1 , ( $+5 ) 
                      4544     
053B    A14C          4545     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      4546     
053D    741F          4547     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
053F    F4            4548     	CPL	A
0540    552F          4549     	ANL	A, FLAGS3					; Clear all pwm frequency flags
0542    4B            4550     ORL A , R3 
0543    F52F          4551     	MOV	FLAGS3, A
0545    C274          4552     CLR FLAGS2 . 4 
0547    EB            4553     MOV A , R3 
0548    7002          4554     	JNZ	PCA_INT_SET_TIMEOUT
                      4555     
054A    D274          4556     SETB FLAGS2 . 4 
                      4557     
                      4558     PCA_INT_SET_TIMEOUT: 
054C    752A18        4559     MOV RCP_TIMEOUT_CNTD , # 24 
054F    307403        4560     JNB FLAGS2 . 4 , PCA_INT_PPM_TIMEOUT_SET 
                      4561     
0552    752A0A        4562     MOV RCP_TIMEOUT_CNTD , # 10 
                      4563     
                      4564     PCA_INT_PPM_TIMEOUT_SET: 
0555    306102        4565     JNB FLAGS0 . 1 , ( $+5 ) 
                      4566     
0558    A160          4567     	AJMP PCA_INT_EXIT				; Yes - exit
                      4568     
055A    207403        4569     JB FLAGS2 . 4 , PCA_INT_EXIT 
                      4570     
                      4571     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
055D    53DAFE        4571+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      4572     
                      4573     PCA_INT_EXIT: 	; Exit interrupt routine	
0560    207403        4574     JB FLAGS2 . 4 , ( $+6 ) 
                      4575     
0563    752B06        4576     MOV RCP_SKIP_CNTD , # 6 
                      4577     
0566    D0F0          4578     	POP	B			; Restore preserved registers
0568    D0E0          4579     	POP	ACC			
056A    D0D0          4580     	POP	PSW
056C    D2AD          4581     	SETB	ET2			; Enable timer2 interrupts
056E    43E610        4582     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0571    32            4583     	RETI
                      4584     
                      4585     
                      4586     
                      4587     
                      4588     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4589     ;
                      4590     ; Wait xms ~(x*4*250)  (Different entry points)	
                      4591     ;
                      4592     ; No assumptions
                      4593     ;
                      4594     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4595     WAIT1MS: 	
0572    7901          4596     MOV R1 , # 1 
0574    020590        4597     	JMP	WAITXMS_O
                      4598     
                      4599     WAIT3MS: 	
0577    7903          4600     MOV R1 , # 3 
0579    020590        4601     	JMP	WAITXMS_O
                      4602     
                      4603     WAIT10MS: 	
057C    790A          4604     MOV R1 , # 10 
057E    020590        4605     	JMP	WAITXMS_O
                      4606     
                      4607     WAIT30MS: 	
0581    791E          4608     MOV R1 , # 30 
0583    020590        4609     	JMP	WAITXMS_O
                      4610     
                      4611     WAIT100MS: 	
0586    7964          4612     MOV R1 , # 100 
0588    020590        4613     	JMP	WAITXMS_O
                      4614     
                      4615     WAIT200MS: 	
058B    79C8          4616     MOV R1 , # 200 
058D    020590        4617     	JMP	WAITXMS_O
                      4618     
                      4619     WAITXMS_O: 	; Outer loop
0590    7817          4620     MOV R0 , # 23 
                      4621     WAITXMS_M: 	; Middle loop
0592    E4            4622     	CLR	A
0593    D5E0FD        4623      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
0596    D8FA          4624     DJNZ R0 , WAITXMS_M 
0598    D9F6          4625     DJNZ R1 , WAITXMS_O 
059A    22            4626     	RET
                      4627     
                      4628     
                      4629     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4630     ;
                      4631     ; Beeper routines (4 different entry points) 
                      4632     ;
                      4633     ; No assumptions
                      4634     ;
                      4635     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4636     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
059B    7A14          4637     MOV R2 , # 20 
059D    7B78          4638     MOV R3 , # 120 
059F    0205B7        4639     	JMP	BEEP
                      4640     
                      4641     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
05A2    7A10          4642     MOV R2 , # 16 
05A4    7B8C          4643     MOV R3 , # 140 
05A6    0205B7        4644     	JMP	BEEP
                      4645     
                      4646     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
05A9    7A0D          4647     MOV R2 , # 13 
05AB    7BB4          4648     MOV R3 , # 180 
05AD    0205B7        4649     	JMP	BEEP
                      4650     
                      4651     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
05B0    7A0B          4652     MOV R2 , # 11 
05B2    7BC8          4653     MOV R3 , # 200 
05B4    0205B7        4654     	JMP	BEEP
                      4655     
                      4656     BEEP: 	; Beep loop start
05B7    E573          4657     	MOV	A, BEEP_STRENGTH
05B9    D5E001        4658     	DJNZ	ACC, BEEP_START 
05BC    22            4659     	RET
                      4660     
                      4661     BEEP_START:     
05BD    7902          4662     MOV R1 , # 2 
                      4663     BEEP_ONOFF: 
05BF    E4            4664     	CLR	A
                      4665     	BPFET_OFF			; BpFET off
05C0    C293          4665+1   CLR P1 . 3 
05C2    D5E0FD        4666     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      4667     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
05C5    D292          4667+1   SETB P1 . 2 
05C7    D5E0FD        4668     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      4669     	BNFET_OFF			; BnFET off again
05CA    C292          4669+1   CLR P1 . 2 
05CC    D5E0FD        4670     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      4671     	BPFET_ON			; BpFET on
05CF    D293          4671+1   SETB P1 . 3 
05D1    D5E0FD        4672     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      4673     	; Turn on nfet
05D4    E9            4674     MOV A , R1 
05D5    20E002        4675     	JB	ACC.0, BEEP_ANFET_ON
                      4676     	ANFET_ON			; AnFET on
05D8    D294          4676+1   SETB P1 . 4 
                      4677     BEEP_ANFET_ON: 
05DA    30E002        4678     	JNB	ACC.0, BEEP_CNFET_ON
                      4679     	CNFET_ON			; CnFET on
05DD    D290          4679+1   SETB P1 . 0 
                      4680     BEEP_CNFET_ON: 
05DF    E573          4681     	MOV	A, BEEP_STRENGTH
05E1    D5E0FD        4682     	DJNZ	ACC, $		
                      4683     	; Turn off nfet
05E4    E9            4684     MOV A , R1 
05E5    20E002        4685     	JB	ACC.0, BEEP_ANFET_OFF
                      4686     	ANFET_OFF			; AnFET off
05E8    C294          4686+1   CLR P1 . 4 
                      4687     BEEP_ANFET_OFF: 
05EA    30E002        4688     	JNB	ACC.0, BEEP_CNFET_OFF
                      4689     	CNFET_OFF			; CnFET off
05ED    C290          4689+1   CLR P1 . 0 
                      4690     BEEP_CNFET_OFF: 
05EF    7496          4691     	MOV	A, #150		; 25s off
05F1    D5E0FD        4692     	DJNZ	ACC, $		
05F4    D9C9          4693     DJNZ R1 , BEEP_ONOFF 
                      4694     	; Copy variable
05F6    EA            4695     MOV A , R2 
05F7    F8            4696     MOV R0 , A 
                      4697     BEEP_OFF: 		; Fets off loop
05F8    D5E0FD        4698     	DJNZ	ACC, $
05FB    D8FB          4699     DJNZ R0 , BEEP_OFF 
05FD    DBB8          4700     DJNZ R3 , BEEP 
                      4701     	BPFET_OFF			; BpFET off
05FF    C293          4701+1   CLR P1 . 3 
0601    22            4702     	RET
                      4703     
                      4704     
                      4705     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4706     ;
                      4707     ; Division 16bit unsigned by 16bit unsigned
                      4708     ;
                      4709     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      4710     ; Result will be in Temp2/Temp1
                      4711     ;
                      4712     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4713     DIV_U16_BY_U16: 	
0602    C3            4714     	CLR	C       
0603    7C00          4715     MOV R4 , # 0 
0605    7D00          4716     MOV R5 , # 0 
0607    75F000        4717     	MOV	B, #0
                      4718     DIV_U16_BY_U16_DIV1: 
060A    05F0          4719     	INC	B      			; Increment counter for each left shift
060C    EA            4720     MOV A , R2 
060D    33            4721     	RLC	A      		
060E    FA            4722     MOV R2 , A 
060F    EB            4723     MOV A , R3 
0610    33            4724     	RLC	A      	  	
0611    FB            4725     MOV R3 , A 
0612    50F6          4726     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      4727     DIV_U16_BY_U16_DIV2:         
0614    EB            4728     MOV A , R3 
0615    13            4729     	RRC	A      
0616    FB            4730     MOV R3 , A 
0617    EA            4731     MOV A , R2 
0618    13            4732     	RRC	A      
0619    FA            4733     MOV R2 , A 
061A    C3            4734     	CLR	C      
061B    E9            4735     MOV A , R1 
061C    FF            4736     MOV R7 , A 
061D    E8            4737     MOV A , R0 
061E    FE            4738     MOV R6 , A 
061F    E8            4739     MOV A , R0 
0620    9A            4740     SUBB A , R2 
0621    F8            4741     MOV R0 , A 
0622    E9            4742     MOV A , R1 
0623    9B            4743     SUBB A , R3 
0624    F9            4744     MOV R1 , A 
0625    5004          4745     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
0627    EF            4746     MOV A , R7 
0628    F9            4747     MOV R1 , A 
0629    EE            4748     MOV A , R6 
062A    F8            4749     MOV R0 , A 
                      4750     DIV_U16_BY_U16_DIV3: 
062B    B3            4751     	CPL	C      			; Invert carry, so it can be directly copied into result
062C    EC            4752     MOV A , R4 
062D    33            4753     	RLC	A      			; Shift carry flag into temporary result
062E    FC            4754     MOV R4 , A 
062F    ED            4755     MOV A , R5 
0630    33            4756     	RLC	A
0631    FD            4757     MOV R5 , A 
0632    D5F0DF        4758     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
0635    ED            4759     MOV A , R5 
0636    F9            4760     MOV R1 , A 
0637    EC            4761     MOV A , R4 
0638    F8            4762     MOV R0 , A 
0639    22            4763     	RET
                      4764     
                      4765     
                      4766     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4767     ;
                      4768     ; Multiplication 16bit signed by 8bit unsigned
                      4769     ;
                      4770     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      4771     ; Result will be in Temp2/Temp1. Result will divided by 16
                      4772     ;
                      4773     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4774     MULT_S16_BY_U8_DIV_16: 
063A    E8            4775     MOV A , R0 
063B    89F0          4776     MOV B , R1 
063D    8A20          4777     MOV BIT_ACCESS , R2 
063F    D2D4          4778     	SETB	PSW.4		; Select register bank 2 for math routines
0641    F8            4779     MOV R0 , A 
0642    A9F0          4780     MOV R1 , B 
0644    7B00          4781     MOV R3 , # 0 
0646    30F70B        4782     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      4783     
0649    7BFF          4784     MOV R3 , # 0FFH 
064B    F4            4785     	CPL	A
064C    2401          4786     	ADD	A, #1
064E    F8            4787     MOV R0 , A 
064F    E9            4788     MOV A , R1 
0650    F4            4789     	CPL	A
0651    3400          4790     	ADDC	A, #0
0653    F9            4791     MOV R1 , A 
                      4792     MULT_S16_BY_U8_POSITIVE: 
0654    E8            4793     MOV A , R0 
0655    8520F0        4794     	MOV	B, BIT_ACCESS
0658    A4            4795     	MUL	AB
0659    ADF0          4796     MOV R5 , B 
065B    F8            4797     MOV R0 , A 
065C    E9            4798     MOV A , R1 
065D    8520F0        4799     	MOV	B, BIT_ACCESS
0660    A4            4800     	MUL	AB
0661    AFF0          4801     MOV R7 , B 
0663    FE            4802     MOV R6 , A 
0664    ED            4803     MOV A , R5 
0665    2E            4804     ADD A , R6 
0666    F9            4805     MOV R1 , A 
0667    7400          4806     	MOV	A, #0
0669    3F            4807     ADDC A , R7 
066A    FA            4808     MOV R2 , A 
066B    7C04          4809     MOV R4 , # 4 
                      4810     MULT_S16_BY_U8_DIV_LOOP: 
066D    C3            4811     	CLR	C			; Rotate right 
066E    EA            4812     MOV A , R2 
066F    13            4813     	RRC	A
0670    FA            4814     MOV R2 , A 
0671    E9            4815     MOV A , R1 
0672    13            4816     	RRC	A
0673    F9            4817     MOV R1 , A 
0674    E8            4818     MOV A , R0 
0675    13            4819     	RRC	A
0676    F8            4820     MOV R0 , A 
0677    DCF4          4821     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      4822     
0679    8BF0          4823     MOV B , R3 
067B    30F70A        4824     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      4825     
067E    E8            4826     MOV A , R0 
067F    F4            4827     	CPL	A
0680    2401          4828     	ADD	A, #1
0682    F8            4829     MOV R0 , A 
0683    E9            4830     MOV A , R1 
0684    F4            4831     	CPL	A
0685    3400          4832     	ADDC	A, #0
0687    F9            4833     MOV R1 , A 
                      4834     
                      4835     MULT_S16_BY_U8_EXIT: 
0688    E8            4836     MOV A , R0 
0689    89F0          4837     MOV B , R1 
068B    C2D4          4838     	CLR	PSW.4		; Select normal register bank
068D    F8            4839     MOV R0 , A 
068E    A9F0          4840     MOV R1 , B 
0690    22            4841     	RET
                      4842     
                      4843     
                      4844     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4845     ;
                      4846     ; Calculate governor routines
                      4847     ;
                      4848     ; No assumptions
                      4849     ;
                      4850     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      4851     ; The governor task is split into several routines in order to distribute processing time
                      4852     ;
                      4853     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4854     ; First governor routine - calculate governor target
                      4855     IF MODE == 0	; Main
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	JB	FLAGS1.GOV_ACTIVE, GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	JNB	FLAGS1.GOV_ACTIVE, GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                                
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	CLR	FLAGS1.GOV_ACTIVE
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	SETB	FLAGS1.GOV_ACTIVE
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      4993     IF MODE == 1	; Tail
                      4994     CALC_GOVERNOR_TARGET: 
0691    22            4995     	RET						
                      4996     ENDIF
                      4997     IF MODE == 2	; Multi
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Closed loop mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_TARGET_CALC	; Yes - branch
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_TARGET_CALC:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #RCP_STOP				; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	JMP	GOVERNOR_ACTIVATE			; No - activate
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	CLR	FLAGS1.GOV_ACTIVE
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	TEMP1, #PGM_GOV_MODE		; Store gov mode
                               	MOV	A, @TEMP1
                               	MOV	TEMP5, A
                               	SETB	FLAGS1.GOV_ACTIVE
                               	MOV	A, REQUESTED_PWM			; Load requested pwm
                               	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                               	; Calculate comm period target 2*(51000/Requested_Pwm)
                               	MOV	TEMP1, #38H				; Load 51000
                               	MOV	TEMP2, #0C7H
                               	MOV	TEMP3, COMM_PERIOD4X_L		; Load comm period
                               	MOV	TEMP4, COMM_PERIOD4X_H		
                               	; Set speed range 
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 200k eRPM range here
                               	; Check range
                               	MOV	A, TEMP5
                               	DEC	A
                               	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                               GOVERNOR_ACTIVATE_100K:
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 100k eRPM range here
                               	MOV	A, TEMP5					; Check range again
                               	DEC	A
                               	DEC	A
                               	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                               GOVERNOR_ACTIVATE_50K:
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 50k eRPM range here
                               GOVERNOR_ACTIVATE_RANGE_SET:
                               	CALL	DIV_U16_BY_U16
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      5075     
                      5076     
                      5077     ; Second governor routine - calculate governor proportional error
                      5078     CALC_GOVERNOR_PROP_ERROR: 
                      5079     IF MODE <= 1	; Main or tail
                      5080     	; Load comm period and divide by 2
0692    C3            5081     	CLR	C
0693    E541          5082     	MOV	A, COMM_PERIOD4X_H
0695    13            5083     	RRC	A
0696    F9            5084     MOV R1 , A 
0697    E540          5085     	MOV	A, COMM_PERIOD4X_L
0699    13            5086     	RRC	A
069A    F8            5087     MOV R0 , A 
                      5088     	; Calculate error
069B    C3            5089     	CLR	C
069C    E544          5090     	MOV	A, GOV_TARGET_L
069E    98            5091     SUBB A , R0 
069F    F8            5092     MOV R0 , A 
06A0    E545          5093     	MOV	A, GOV_TARGET_H
06A2    99            5094     SUBB A , R1 
06A3    F9            5095     MOV R1 , A 
                      5096     ENDIF
                      5097     IF MODE == 2	; Multi
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, GOVERNOR_REQ_PWM
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               ENDIF
                      5107     	; Check error and limit
06A4    500C          5108     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      5109     
06A6    C3            5110     	CLR	C
06A7    E8            5111     MOV A , R0 
06A8    9480          5112     	SUBB	A, #80H					; Is error too negative?
06AA    E9            5113     MOV A , R1 
06AB    94FF          5114     	SUBB	A, #0FFH
06AD    4016          5115     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
06AF    0206C9        5116     	JMP	GOVERNOR_STORE_PROP_ERROR
                      5117     
                      5118     GOVERNOR_CHECK_PROP_LIMIT_POS: 
06B2    C3            5119     	CLR	C
06B3    E8            5120     MOV A , R0 
06B4    947F          5121     	SUBB	A, #7FH					; Is error too positive?
06B6    E9            5122     MOV A , R1 
06B7    9400          5123     	SUBB	A, #00H
06B9    5003          5124     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
06BB    0206C9        5125     	JMP	GOVERNOR_STORE_PROP_ERROR
                      5126     
                      5127     GOVERNOR_LIMIT_PROP_ERROR_POS: 
06BE    787F          5128     MOV R0 , # 7FH 
06C0    7900          5129     MOV R1 , # 00H 
06C2    0206C9        5130     	JMP	GOVERNOR_STORE_PROP_ERROR
                      5131     
                      5132     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
06C5    7880          5133     MOV R0 , # 80H 
06C7    79FF          5134     MOV R1 , # 0FFH 
                      5135     
                      5136     GOVERNOR_STORE_PROP_ERROR: 
                      5137     	; Store proportional
06C9    8849          5138     MOV GOV_PROPORTIONAL_L , R0 
06CB    894A          5139     MOV GOV_PROPORTIONAL_H , R1 
                      5140     CALC_GOVERNOR_PROP_ERROR_EXIT: 
06CD    22            5141     	RET						
                      5142     
                      5143     
                      5144     ; Third governor routine - calculate governor integral error
                      5145     CALC_GOVERNOR_INT_ERROR: 
                      5146     	; Add proportional to integral
06CE    E549          5147     	MOV	A, GOV_PROPORTIONAL_L
06D0    2546          5148     	ADD	A, GOV_INTEGRAL_L
06D2    F8            5149     MOV R0 , A 
06D3    E54A          5150     	MOV	A, GOV_PROPORTIONAL_H
06D5    3547          5151     	ADDC	A, GOV_INTEGRAL_H
06D7    F9            5152     MOV R1 , A 
06D8    854A20        5153     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
06DB    E4            5154     	CLR	A
06DC    300701        5155     	JNB	BIT_ACCESS.7, ($+4)			
06DF    F4            5156     	CPL	A
06E0    3548          5157     	ADDC	A, GOV_INTEGRAL_X
06E2    FA            5158     MOV R2 , A 
                      5159     	; Check integral and limit
06E3    30E709        5160     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      5161     
06E6    C3            5162     	CLR	C
06E7    EA            5163     MOV A , R2 
06E8    94F0          5164     	SUBB	A, #0F0H					; Is error too negative?
06EA    4015          5165     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
06EC    020707        5166     	JMP	GOVERNOR_CHECK_PWM
                      5167     
                      5168     GOVERNOR_CHECK_INT_LIMIT_POS: 
06EF    C3            5169     	CLR	C
06F0    EA            5170     MOV A , R2 
06F1    940F          5171     	SUBB	A, #0FH					; Is error too positive?
06F3    5003          5172     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
06F5    020707        5173     	JMP	GOVERNOR_CHECK_PWM
                      5174     
                      5175     GOVERNOR_LIMIT_INT_ERROR_POS: 
06F8    78FF          5176     MOV R0 , # 0FFH 
06FA    79FF          5177     MOV R1 , # 0FFH 
06FC    7A0F          5178     MOV R2 , # 0FH 
06FE    020707        5179     	JMP	GOVERNOR_CHECK_PWM
                      5180     
                      5181     GOVERNOR_LIMIT_INT_ERROR_NEG: 
0701    7800          5182     MOV R0 , # 00H 
0703    7900          5183     MOV R1 , # 00H 
0705    7AF0          5184     MOV R2 , # 0F0H 
                      5185     
                      5186     GOVERNOR_CHECK_PWM: 
                      5187     	; Check current pwm
0707    C3            5188     	CLR	C
0708    E524          5189     	MOV	A, CURRENT_PWM
070A    9561          5190     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
070C    500A          5191     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      5192     
070E    C3            5193     	CLR	C
070F    7401          5194     	MOV	A, #1
0711    9524          5195     	SUBB	A, CURRENT_PWM				; Is current pwm at minimum?
0713    500B          5196     	JNC	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      5197     
0715    020725        5198     	JMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      5199     
                      5200     GOVERNOR_INT_MAX_PWM: 
0718    E54A          5201     	MOV	A, GOV_PROPORTIONAL_H
071A    20E70E        5202     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      5203     
071D    020725        5204     	JMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      5205     
                      5206     GOVERNOR_INT_MIN_PWM: 
0720    E54A          5207     	MOV	A, GOV_PROPORTIONAL_H
0722    30E706        5208     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      5209     
                      5210     GOVERNOR_STORE_INT_ERROR: 
                      5211     	; Store integral
0725    8846          5212     MOV GOV_INTEGRAL_L , R0 
0727    8947          5213     MOV GOV_INTEGRAL_H , R1 
0729    8A48          5214     MOV GOV_INTEGRAL_X , R2 
                      5215     CALC_GOVERNOR_INT_ERROR_EXIT: 
072B    22            5216     	RET						
                      5217     
                      5218     
                      5219     ; Fourth governor routine - calculate governor proportional correction
                      5220     CALC_GOVERNOR_PROP_CORRECTION: 
                      5221     	; Load proportional gain
072C    78A5          5222     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
072E    E6            5223     MOV A , @ R0 
072F    FA            5224     MOV R2 , A 
                      5225     	; Load proportional
0730    C3            5226     	CLR	C
0731    E549          5227     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
0733    33            5228     	RLC	A
0734    F8            5229     MOV R0 , A 
0735    E54A          5230     	MOV	A, GOV_PROPORTIONAL_H
0737    33            5231     	RLC	A
0738    F9            5232     MOV R1 , A 
                      5233     	; Apply gain
0739    D13A          5234     	CALL	MULT_S16_BY_U8_DIV_16
                      5235     	; Check error and limit (to low byte)
073B    E9            5236     MOV A , R1 
073C    30E70B        5237     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      5238     
073F    C3            5239     	CLR	C
0740    E8            5240     MOV A , R0 
0741    9480          5241     	SUBB	A, #80H					; Is error too negative?
0743    E9            5242     MOV A , R1 
0744    94FF          5243     	SUBB	A, #0FFH
0746    4013          5244     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0748    E15F          5245     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      5246     
                      5247     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
074A    C3            5248     	CLR	C
074B    E8            5249     MOV A , R0 
074C    947F          5250     	SUBB	A, #7FH					; Is error too positive?
074E    E9            5251     MOV A , R1 
074F    9400          5252     	SUBB	A, #00H
0751    5002          5253     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0753    E15F          5254     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      5255     
                      5256     GOVERNOR_LIMIT_PROP_CORR_POS: 
0755    787F          5257     MOV R0 , # 7FH 
0757    7900          5258     MOV R1 , # 00H 
0759    E15F          5259     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      5260     
                      5261     GOVERNOR_LIMIT_PROP_CORR_NEG: 
075B    7880          5262     MOV R0 , # 80H 
075D    79FF          5263     MOV R1 , # 0FFH 
                      5264     
                      5265     GOVERNOR_APPLY_PROP_CORR: 
                      5266     	; Test proportional sign
075F    E8            5267     MOV A , R0 
0760    20E715        5268     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      5269     
                      5270     	; Subtract positive proportional
0763    C3            5271     	CLR	C
0764    E523          5272     	MOV	A, GOVERNOR_REQ_PWM
0766    98            5273     SUBB A , R0 
0767    F8            5274     MOV R0 , A 
                      5275     	; Check result
0768    4009          5276     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      5277     
076A    C3            5278     	CLR	C
076B    E8            5279     MOV A , R0 
076C    9401          5280     	SUBB	A, #1
076E    4003          5281     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0770    020786        5282     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      5283     
                      5284     GOVERNOR_CORR_PROP_MIN_PWM: 
0773    7801          5285     MOV R0 , # 1 
0775    020786        5286     	JMP	GOVERNOR_STORE_PROP_CORR
                      5287     
                      5288     GOVERNOR_CORR_NEG_PROP: 
                      5289     	; Add negative proportional
0778    E8            5290     MOV A , R0 
0779    F4            5291     	CPL	A
077A    2401          5292     	ADD	A, #1
077C    2523          5293     	ADD	A, GOVERNOR_REQ_PWM
077E    F8            5294     MOV R0 , A 
                      5295     	; Check result
077F    4003          5296     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0781    020786        5297     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      5298     
                      5299     GOVERNOR_CORR_PROP_MAX_PWM: 
0784    78FF          5300     MOV R0 , # 255 
                      5301     GOVERNOR_STORE_PROP_CORR: 
                      5302     	; Store proportional pwm
0786    884B          5303     MOV GOV_PROP_PWM , R0 
                      5304     CALC_GOVERNOR_PROP_CORR_EXIT: 
0788    22            5305     	RET
                      5306     
                      5307     
                      5308     ; Fifth governor routine - calculate governor integral correction
                      5309     CALC_GOVERNOR_INT_CORRECTION: 
                      5310     	; Load integral gain
0789    78A6          5311     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
078B    E6            5312     MOV A , @ R0 
078C    FA            5313     MOV R2 , A 
                      5314     	; Load integral
078D    A847          5315     MOV R0 , GOV_INTEGRAL_H 
078F    A948          5316     MOV R1 , GOV_INTEGRAL_X 
                      5317     	; Apply gain
0791    D13A          5318     	CALL	MULT_S16_BY_U8_DIV_16
                      5319     	; Check integral and limit
0793    E9            5320     MOV A , R1 
0794    30E70C        5321     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      5322     
0797    C3            5323     	CLR	C
0798    E8            5324     MOV A , R0 
0799    9401          5325     	SUBB	A, #01H					; Is integral too negative?
079B    E9            5326     MOV A , R1 
079C    94FF          5327     	SUBB	A, #0FFH
079E    4016          5328     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
07A0    0207BA        5329     	JMP	GOVERNOR_APPLY_INT_CORR
                      5330     
                      5331     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
07A3    C3            5332     	CLR	C
07A4    E8            5333     MOV A , R0 
07A5    94FF          5334     	SUBB	A, #0FFH					; Is integral too positive?
07A7    E9            5335     MOV A , R1 
07A8    9400          5336     	SUBB	A, #00H
07AA    5003          5337     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
07AC    0207BA        5338     	JMP	GOVERNOR_APPLY_INT_CORR
                      5339     
                      5340     GOVERNOR_LIMIT_INT_CORR_POS: 
07AF    78FF          5341     MOV R0 , # 0FFH 
07B1    7900          5342     MOV R1 , # 00H 
07B3    0207BA        5343     	JMP	GOVERNOR_APPLY_INT_CORR
                      5344     
                      5345     GOVERNOR_LIMIT_INT_CORR_NEG: 
07B6    7801          5346     MOV R0 , # 01H 
07B8    79FF          5347     MOV R1 , # 0FFH 
                      5348     
                      5349     GOVERNOR_APPLY_INT_CORR: 
                      5350     	; Test integral sign
07BA    E9            5351     MOV A , R1 
07BB    20E715        5352     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      5353     
                      5354     	; Subtract positive integral
07BE    C3            5355     	CLR	C
07BF    E54B          5356     	MOV	A, GOV_PROP_PWM
07C1    98            5357     SUBB A , R0 
07C2    F8            5358     MOV R0 , A 
                      5359     	; Check result
07C3    4009          5360     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      5361     
07C5    C3            5362     	CLR	C
07C6    E8            5363     MOV A , R0 
07C7    9401          5364     	SUBB	A, #1
07C9    4003          5365     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
07CB    0207E1        5366     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      5367     
                      5368     GOVERNOR_CORR_INT_MIN_PWM: 
07CE    7801          5369     MOV R0 , # 1 
07D0    0207E1        5370     	JMP	GOVERNOR_STORE_INT_CORR
                      5371     
                      5372     GOVERNOR_CORR_NEG_INT: 
                      5373     	; Add negative integral
07D3    E8            5374     MOV A , R0 
07D4    F4            5375     	CPL	A
07D5    2401          5376     	ADD	A, #1
07D7    254B          5377     	ADD	A, GOV_PROP_PWM
07D9    F8            5378     MOV R0 , A 
                      5379     	; Check result
07DA    4003          5380     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
07DC    0207E1        5381     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      5382     
                      5383     GOVERNOR_CORR_INT_MAX_PWM: 
07DF    78FF          5384     MOV R0 , # 255 
                      5385     GOVERNOR_STORE_INT_CORR: 
                      5386     	; Store current pwm
07E1    8824          5387     MOV CURRENT_PWM , R0 
                      5388     CALC_GOVERNOR_INT_CORR_EXIT: 
07E3    22            5389     	RET
                      5390     
                      5391     
                      5392     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5393     ;
                      5394     ; Set pwm limit low rpm
                      5395     ;
                      5396     ; No assumptions
                      5397     ;
                      5398     ; Sets power limit for low rpms and disables demag for low rpms
                      5399     ;
                      5400     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5401     SET_PWM_LIMIT_LOW_RPM: 
                      5402     	; Set pwm limit and demag disable for low rpms
07E4    78FF          5403     MOV R0 , # 0FFH 
07E6    206928        5404     JB FLAGS1 . 1 , SET_PWM_LIMIT_LOW_RPM_EXIT 
                      5405     
07E9    79A1          5406     MOV R1 , # PGM_ENABLE_POWER_PROT 
07EB    E7            5407     MOV A , @ R1 
07EC    6023          5408     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Exit if disabled
                      5409     
07EE    E541          5410     	MOV	A, COMM_PERIOD4X_H
07F0    601F          5411     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Avoid divide by zero
                      5412     
07F2    74FF          5413     	MOV	A, #255						; Divide 255 by Comm_Period4x_H
07F4    8541F0        5414     	MOV	B, COMM_PERIOD4X_H
07F7    84            5415     	DIV	AB
07F8    8539F0        5416     	MOV	B, LOW_RPM_PWR_SLOPE			; Multiply by slope
07FB    306A03        5417     JNB FLAGS1 . 2 , ( $+6 ) 
07FE    75F005        5418     	MOV	B, #5
0801    A4            5419     	MUL	AB
0802    F8            5420     MOV R0 , A 
0803    C5F0          5421     	XCH	A, B
0805    6002          5422     	JZ	($+4)						; Limit to max
                      5423     	
0807    78FF          5424     MOV R0 , # 0FFH 
                      5425     
0809    C3            5426     	CLR	C
080A    E8            5427     MOV A , R0 
080B    9564          5428     	SUBB	A, PWM_SPOOLUP_BEG
080D    5002          5429     	JNC	SET_PWM_LIMIT_LOW_RPM_EXIT
                      5430     
080F    A864          5431     MOV R0 , PWM_SPOOLUP_BEG 
                      5432     
                      5433     SET_PWM_LIMIT_LOW_RPM_EXIT: 
0811    8863          5434     MOV PWM_LIMIT_BY_RPM , R0 
0813    22            5435     	RET
                      5436     	
                      5437     
                      5438     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5439     ;
                      5440     ; Set pwm limit high rpm
                      5441     ;
                      5442     ; No assumptions
                      5443     ;
                      5444     ; Sets power limit for high rpms
                      5445     ;
                      5446     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5447     SET_PWM_LIMIT_HIGH_RPM: 
                      5448     IF MCU_48MHZ == 1
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_L
                               	SUBB	A, #0C8H				; Limit Comm_Period to 200, which is 400k erpm
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, #00H
                               ELSE
0814    C3            5455     	CLR	C
0815    E540          5456     	MOV	A, COMM_PERIOD4X_L
0817    9440          5457     	SUBB	A, #40H				; Limit Comm_Period to 320, which is 250k erpm
0819    E541          5458     	MOV	A, COMM_PERIOD4X_H
081B    9401          5459     	SUBB	A, #01H
                      5460     ENDIF
081D    E563          5461     	MOV	A, PWM_LIMIT_BY_RPM
081F    5003          5462     	JNC	SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT
                      5463     	
0821    14            5464     	DEC	A
0822    0125          5465     	AJMP	SET_PWM_LIMIT_HIGH_RPM_STORE
                      5466     	
                      5467     SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT: 
0824    04            5468     	INC	A
                      5469     SET_PWM_LIMIT_HIGH_RPM_STORE: 
0825    6002          5470     	JZ	($+4)
                      5471     
0827    F563          5472     	MOV	PWM_LIMIT_BY_RPM, A
                      5473     
0829    22            5474     	RET
                      5475     
                      5476     
                      5477     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5478     ;
                      5479     ; Measure lipo cells
                      5480     ;
                      5481     ; No assumptions
                      5482     ;
                      5483     ; Measure voltage and calculate lipo cells
                      5484     ;
                      5485     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5486     MEASURE_LIPO_CELLS: 
                      5487     IF MODE >= 1	; Tail or multi
                      5488     	; If not supported, then exit
082A    02082D        5489     	JMP	MEASURE_LIPO_EXIT
                      5490     ENDIF
                      5491     IF MODE == 0	; Main
                               	; Load programmed low voltage limit
                               	MOV	TEMP1, #PGM_LOW_VOLTAGE_LIM	; Load limit
                               	MOV	A, @TEMP1				
                               	MOV	BIT_ACCESS, A				; Store in Bit_Access
                               	; Set commutation to BpFET on
                               	CALL	COMM5COMM6			
                               	; Start adc
                               	START_ADC 
                               	; Wait for ADC reference to settle, and then start again
                               	CALL	WAIT1MS
                               	START_ADC
                               	; Wait for ADC conversion to complete
                               MEASURE_LIPO_WAIT_ADC:
                               	JNB	AD0INT, MEASURE_LIPO_WAIT_ADC
                               	; Read ADC result
                               	READ_ADC_RESULT
                               	; Stop ADC
                               	STOP_ADC
                               	; Switch power off
                               	CALL	SWITCH_POWER_OFF		
                               	; Set limit step
                               	MOV	LIPO_ADC_LIMIT_L, #ADC_LIMIT_L
                               	MOV	LIPO_ADC_LIMIT_H, #ADC_LIMIT_H
                               	CLR	C
                               	MOV	A, #ADC_LIMIT_H		; Divide 3.0V value by 2
                               	RRC	A
                               	MOV	TEMP6, A
                               	MOV	A, #ADC_LIMIT_L
                               	JZ	MEASURE_LIPO_EXIT		; Exit if disabled
                               
                               	RRC	A
                               	MOV	TEMP5, A
                               	MOV	A, #ADC_LIMIT_L		; Calculate 1.5*3.0V=4.5V value
                               	ADD	A, TEMP5
                               	MOV	TEMP5, A
                               	MOV	A, #ADC_LIMIT_H		
                               	ADDC	A, TEMP6
                               	MOV	TEMP6, A
                               	MOV	A, TEMP5				; Copy step
                               	MOV	TEMP3, A
                               	MOV	A, TEMP6	
                               	MOV	TEMP4, A
                               MEASURE_LIPO_CELL_LOOP:
                               	; Check voltage against xS lower limit
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, TEMP3				; Voltage above limit?
                               	MOV	A, TEMP2
                               	SUBB A, TEMP4
                               	JC	MEASURE_LIPO_ADJUST		; No - branch
                               
                               	; Set xS voltage limit
                               	MOV	A, LIPO_ADC_LIMIT_L		
                               	ADD	A, #ADC_LIMIT_L
                               	MOV	LIPO_ADC_LIMIT_L, A
                               	MOV	A, LIPO_ADC_LIMIT_H		
                               	ADDC	A, #ADC_LIMIT_H
                               	MOV	LIPO_ADC_LIMIT_H, A
                               	; Set (x+1)S lower limit
                               	MOV	A, TEMP3
                               	ADD	A, TEMP5				; Add step
                               	MOV	TEMP3, A
                               	MOV	A, TEMP4
                               	ADDC	A, TEMP6
                               	MOV	TEMP4, A
                               	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                               
                               MEASURE_LIPO_ADJUST:
                               	MOV	TEMP7, LIPO_ADC_LIMIT_L
                               	MOV	TEMP8, LIPO_ADC_LIMIT_H
                               	; Calculate 3.125%
                               	CLR	C
                               	MOV	A, LIPO_ADC_LIMIT_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, LIPO_ADC_LIMIT_L	
                               	RRC	A
                               	MOV	TEMP1, A			; After this 50%
                               	CLR	C
                               	MOV	A, TEMP2
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1	
                               	RRC	A
                               	MOV	TEMP1, A			; After this 25%
                               	; Divide three times to get to 3.125%
                               	MOV	TEMP3, #3
                               MEASURE_LIPO_DIVIDE_LOOP:
                               	CLR	C
                               	MOV	A, TEMP2
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1	
                               	RRC	A
                               	MOV	TEMP1, A			
                               	DJNZ	TEMP3, MEASURE_LIPO_DIVIDE_LOOP
                               
                               	; Add the programmed number of 0.1V (or 3.125% increments)
                               	MOV	TEMP3, BIT_ACCESS		; Load programmed limit (Bit_Access has Pgm_Low_Voltage_Lim)
                               	DEC	TEMP3
                               	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                               
                               	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
                               	MOV	LIPO_ADC_LIMIT_H, #0
                               	JMP	MEASURE_LIPO_EXIT	
                               
                               MEASURE_LIPO_LIMIT_ON:
                               	DEC	TEMP3
                               	MOV	A, TEMP3
                               	JZ	MEASURE_LIPO_UPDATE
                               
                               MEASURE_LIPO_ADD_LOOP:
                               	MOV	A, TEMP7			; Add 3.125%
                               	ADD	A, TEMP1
                               	MOV	TEMP7, A
                               	MOV	A, TEMP8
                               	ADDC	A, TEMP2
                               	MOV	TEMP8, A
                               	DJNZ	TEMP3, MEASURE_LIPO_ADD_LOOP
                               
                               MEASURE_LIPO_UPDATE:
                               	; Set ADC limit
                               	MOV	LIPO_ADC_LIMIT_L, TEMP7
                               	MOV	LIPO_ADC_LIMIT_H, TEMP8
                               ENDIF
                      5617     MEASURE_LIPO_EXIT: 
082D    22            5618     	RET
                      5619     
                      5620     
                      5621     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5622     ;
                      5623     ; Start ADC conversion
                      5624     ;
                      5625     ; No assumptions
                      5626     ;
                      5627     ; Start conversion used for measuring power supply voltage
                      5628     ;
                      5629     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5630     START_ADC_CONVERSION: 
                      5631     	; Start adc
                      5632     	START_ADC 
082E    75E890        5632+1   MOV ADC0CN , # 90H  ; ADC START
0831    22            5633     	RET
                      5634     
                      5635     
                      5636     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5637     ;
                      5638     ; Check temperature, power supply voltage and limit power
                      5639     ;
                      5640     ; No assumptions
                      5641     ;
                      5642     ; Used to limit main motor power in order to maintain the required voltage
                      5643     ;
                      5644     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5645     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      5646     	; Load programmed low voltage limit
0832    7883          5647     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0834    E6            5648     MOV A , @ R0 
0835    FF            5649     MOV R7 , A 
                      5650     	; Wait for ADC conversion to complete
0836    30EDF9        5651     	JNB	AD0INT, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      5652     	; Read ADC result
                      5653     	READ_ADC_RESULT
0839    A8BD          5653+1   MOV R0 , ADC0L 
083B    A9BE          5653+1   MOV R1 , ADC0H 
                      5654     	; Stop ADC
                      5655     	STOP_ADC
                      5656     
083D    0570          5657     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
083F    C3            5658     	CLR	C
0840    E570          5659     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0842    9408          5660     SUBB A , # 8 
0844    4052          5661     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      5662     
0846    757000        5663     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0849    E9            5664     MOV A , R1 
084A    FA            5665     MOV R2 , A 
084B    79A0          5666     MOV R1 , # PGM_ENABLE_TEMP_PROT 
084D    E7            5667     MOV A , @ R1 
084E    6044          5668     	JZ	TEMP_CHECK_EXIT			; No - branch
                      5669     
0850    EA            5670     MOV A , R2 
0851    7007          5671     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      5672     
0853    E571          5673     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0855    601B          5674     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0857    020866        5675     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      5676     
                      5677     TEMP_AVERAGE_INC_DEC: 
085A    C3            5678     	CLR	C
085B    E8            5679     MOV A , R0 
085C    9571          5680     	SUBB	A, CURRENT_AVERAGE_TEMP
085E    6010          5681     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      5682     
0860    E571          5683     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0862    5006          5684     	JNC	TEMP_AVERAGE_INC				
                      5685     
0864    600C          5686     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      5687     TEMP_AVERAGE_DEC: 
0866    14            5688     	DEC	A						; Decrement average
0867    020872        5689     	JMP	TEMP_AVERAGE_UPDATED
                      5690     
                      5691     TEMP_AVERAGE_INC: 
086A    04            5692     	INC	A						; Increment average
086B    60F9          5693     	JZ	TEMP_AVERAGE_DEC
086D    020872        5694     	JMP	TEMP_AVERAGE_UPDATED
                      5695     
                      5696     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0870    E571          5697     	MOV	A, CURRENT_AVERAGE_TEMP
                      5698     TEMP_AVERAGE_UPDATED: 
0872    F571          5699     	MOV	CURRENT_AVERAGE_TEMP, A
0874    C3            5700     	CLR	C
0875    946D          5701     SUBB A , # 109 
0877    401B          5702     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5703     
0879    7561C0        5704     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      5705     
087C    C3            5706     	CLR	C
087D    9404          5707     SUBB A , # 4 
087F    4013          5708     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5709     
0881    756180        5710     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      5711     
0884    C3            5712     	CLR	C
0885    9404          5713     SUBB A , # 4 
0887    400B          5714     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5715     
0889    756140        5716     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      5717     
088C    C3            5718     	CLR	C
088D    9404          5719     SUBB A , # 4 
088F    4003          5720     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5721     
0891    756100        5722     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      5723     
                      5724     TEMP_CHECK_EXIT: 
                      5725     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0894    75BB0E        5725+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0897    22            5726     	RET
                      5727     
                      5728     CHECK_VOLTAGE_START: 
                      5729     IF MODE == 0	; Main 
                               	; Check if low voltage limiting is enabled
                               	MOV	A, TEMP8
                               	CLR	C
                               	SUBB	A, #1					; Is low voltage limit disabled?
                               	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                               
                               	MOV	A, #ADC_LIMIT_L			; Is low voltage limit zero (ESC does not support it)?
                               	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                               
                               	; Check if ADC is saturated
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, #0FFH
                               	MOV	A, TEMP2
                               	SUBB	A, #03H
                               	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                               
                               	; Check voltage against limit
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, LIPO_ADC_LIMIT_L
                               	MOV	A, TEMP2
                               	SUBB	A, LIPO_ADC_LIMIT_H
                               	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                               
                               	; Decrease pwm limit
                               	MOV  A, PWM_LIMIT
                               	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                               
                               	DEC	PWM_LIMIT					; Decrement limit
                               	JMP	CHECK_VOLTAGE_LIM
                               
                               CHECK_VOLTAGE_GOOD:
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	CPL	A			
                               	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                               
                               	INC	PWM_LIMIT					; Increment limit
                               
                               CHECK_VOLTAGE_LIM:
                               	MOV	TEMP1, PWM_LIMIT			; Set limit
                               	CLR	C
                               	MOV	A, CURRENT_PWM
                               	SUBB	A, TEMP1
                               	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                               
                               	MOV	TEMP1, CURRENT_PWM			; Set current pwm (no limiting)
                               
                               CHECK_VOLTAGE_SPOOLUP_LIM:
                               	; Slow spoolup
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_LIMIT_SPOOLUP
                               	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                               
                               	MOV	TEMP1, PWM_LIMIT_SPOOLUP
                               	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
                               	CPL	A
                               	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                                
                               	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                               
                               CHECK_VOLTAGE_EXIT:
                               	MOV  CURRENT_PWM_LIMITED, TEMP1
                               	MOV	CURRENT_PWM_LIM_DITH, TEMP1
                               ENDIF
                      5797     IF MODE == 1	; Tail
                      5798     	; Increase pwm limit
0898    E561          5799     	MOV  A, PWM_LIMIT
089A    F4            5800     	CPL	A			
089B    6002          5801     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      5802     
089D    0561          5803     	INC	PWM_LIMIT					; Increment limit
                      5804     
                      5805     CHECK_VOLTAGE_LIM: 
                      5806     ENDIF
                      5807     IF MODE == 2	; Multi
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	ADD	A, #16			
                               	JNC	($+4)					; If not max - branch
                               
                               	MOV	A, #255
                               
                               	MOV	PWM_LIMIT, A				; Increment limit 
                               	; Set current pwm limited if closed loop mode
                               	MOV	TEMP2, #PGM_GOV_MODE		; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)			
                               	AJMP	CHECK_VOLTAGE_PWM_DONE		; No - branch
                               
                               	CLR	C
                               	MOV	TEMP1, PWM_LIMIT			; Set limit
                               	MOV	A, CURRENT_PWM
                               	SUBB	A, TEMP1
                               	JNC	CHECK_VOLTAGE_LOW_RPM		; If current pwm above limit - branch and limit	
                               
                               	MOV	TEMP1, CURRENT_PWM			; Set current pwm (no limiting)
                               
                               CHECK_VOLTAGE_LOW_RPM:
                               	; Limit pwm for low rpms
                               	CLR	C
                               	MOV	A, TEMP1					; Check against limit
                               	SUBB	A, PWM_LIMIT_BY_RPM
                               	JC	($+4)					; If current pwm below limit - branch
                               
                               	MOV	TEMP1, PWM_LIMIT_BY_RPM		; Limit pwm
                               
                               	MOV  CURRENT_PWM_LIMITED, TEMP1
                               	MOV	CURRENT_PWM_LIM_DITH, TEMP1
                               CHECK_VOLTAGE_PWM_DONE:
                               ENDIF
                      5842     	; Set adc mux for next conversion
089F    E570          5843     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
08A1    B40703        5844     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      5845     
                      5846     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
08A4    75BB10        5846+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5847     
                      5848     CHECK_VOLTAGE_RET: 
08A7    22            5849     	RET
                      5850     
                      5851     
                      5852     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5853     ;
                      5854     ; Set startup PWM routine
                      5855     ;
                      5856     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      5857     ;
                      5858     ; Used for pwm control during startup
                      5859     ;
                      5860     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5861     SET_STARTUP_PWM: 	
                      5862     	; Adjust startup power
08A8    7432          5863     MOV A , # 50 
08AA    79A7          5864     MOV R1 , # PGM_STARTUP_PWR_DECODED 
08AC    87F0          5865     MOV B , @ R1 
08AE    A4            5866     	MUL	AB
08AF    C5F0          5867     	XCH	A, B
08B1    A2F7          5868     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
08B3    33            5869     	RLC	A
08B4    F8            5870     MOV R0 , A 
08B5    C3            5871     	CLR	C
08B6    E8            5872     MOV A , R0 
08B7    9561          5873     	SUBB	A, PWM_LIMIT	
08B9    4002          5874     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      5875     
08BB    A861          5876     MOV R0 , PWM_LIMIT 
                      5877     
                      5878     STARTUP_PWM_SET_PWM: 
                      5879     	; Set pwm variables
08BD    8822          5880     MOV REQUESTED_PWM , R0 
08BF    8824          5881     MOV CURRENT_PWM , R0 
08C1    8825          5882     MOV CURRENT_PWM_LIMITED , R0 
08C3    8826          5883     MOV CURRENT_PWM_LIM_DITH , R0 
08C5    8864          5884     MOV PWM_SPOOLUP_BEG , R0 
08C7    22            5885     	RET
                      5886     
                      5887     
                      5888     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5889     ;
                      5890     ; Initialize timing routine
                      5891     ;
                      5892     ; No assumptions
                      5893     ;
                      5894     ; Part of initialization before motor start
                      5895     ;
                      5896     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5897     INITIALIZE_TIMING:  
08C8    754000        5898     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
08CB    7541F0        5899     	MOV	COMM_PERIOD4X_H, #0F0H
08CE    22            5900     	RET
                      5901     
                      5902     
                      5903     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5904     ;
                      5905     ; Calculate next commutation timing routine
                      5906     ;
                      5907     ; No assumptions
                      5908     ;
                      5909     ; Called immediately after each commutation
                      5910     ; Also sets up timer 3 to wait advance timing
                      5911     ; Two entry points are used
                      5912     ;
                      5913     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5914     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
                      5915     	; Read commutation time
08CF    C2AF          5916     	CLR	EA
08D1    75C820        5917     	MOV	TMR2CN, #20H		; Timer2 disabled
08D4    A8CC          5918     MOV R0 , TMR2L 
08D6    A9CD          5919     MOV R1 , TMR2H 
08D8    AA3A          5920     MOV R2 , TIMER2_X 
08DA    30CF01        5921     	JNB	TF2H, ($+4)		; Check if interrupt is pending
08DD    0A            5922     INC R2 
08DE    75C824        5923     	MOV	TMR2CN, #24H		; Timer2 enabled
08E1    D2AF          5924     	SETB	EA
                      5925     IF MCU_48MHZ == 1
                               	CLR	C
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A
                               	MOV	A, TEMP2
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	RRC	A
                               	MOV	TEMP1, A
                               ENDIF
                      5937     	; Calculate this commutation time
08E3    AB3B          5938     MOV R3 , PREV_COMM_L 
08E5    AC3C          5939     MOV R4 , PREV_COMM_H 
08E7    883B          5940     MOV PREV_COMM_L , R0 
08E9    893C          5941     MOV PREV_COMM_H , R1 
08EB    C3            5942     	CLR	C
08EC    E8            5943     MOV A , R0 
08ED    9B            5944     SUBB A , R3 
08EE    F8            5945     MOV R0 , A 
08EF    E9            5946     MOV A , R1 
08F0    9C            5947     SUBB A , R4 
08F1    206908        5948     JB FLAGS1 . 1 , CALC_NEXT_COMM_STARTUP 
                      5949     
                      5950     IF MCU_48MHZ == 1
                               	ANL	A, #7FH
                               ENDIF
08F4    F9            5953     MOV R1 , A 
08F5    306602        5954     JNB FLAGS0 . 6 , ( $+5 ) 
08F8    21DE          5955     	AJMP	CALC_NEXT_COMM_TIMING_FAST
                      5956     
08FA    2138          5957     	AJMP	CALC_NEXT_COMM_NORMAL
                      5958     
                      5959     CALC_NEXT_COMM_STARTUP: 
08FC    AD3D          5960     MOV R5 , PREV_COMM_X 
08FE    8A3D          5961     MOV PREV_COMM_X , R2 
0900    F9            5962     MOV R1 , A 
0901    EA            5963     MOV A , R2 
0902    9D            5964     SUBB A , R5 
                      5965     IF MCU_48MHZ == 1
                               	ANL	A, #7FH
                               ENDIF
0903    FA            5968     MOV R2 , A 
0904    6004          5969     	JZ	($+6)
                      5970     
0906    78FF          5971     MOV R0 , # 0FFH 
0908    79FF          5972     MOV R1 , # 0FFH 
                      5973     
090A    AE3E          5974     MOV R6 , PREV_PREV_COMM_L 
090C    AF3F          5975     MOV R7 , PREV_PREV_COMM_H 
090E    8B3E          5976     MOV PREV_PREV_COMM_L , R3 
0910    8C3F          5977     MOV PREV_PREV_COMM_H , R4 
0912    A83B          5978     MOV R0 , PREV_COMM_L 
0914    A93C          5979     MOV R1 , PREV_COMM_H 
0916    C3            5980     	CLR	C
0917    E8            5981     MOV A , R0 
0918    9E            5982     SUBB A , R6 
0919    F8            5983     MOV R0 , A 
091A    E9            5984     MOV A , R1 
091B    9F            5985     SUBB A , R7 
091C    F9            5986     MOV R1 , A 
091D    C3            5987     	CLR	C
091E    E541          5988     	MOV	A, COMM_PERIOD4X_H		; Average with previous and save
0920    13            5989     	RRC	A
0921    FB            5990     MOV R3 , A 
0922    E540          5991     	MOV	A, COMM_PERIOD4X_L
0924    13            5992     	RRC	A
0925    FA            5993     MOV R2 , A 
0926    E8            5994     MOV A , R0 
0927    2A            5995     ADD A , R2 
0928    F540          5996     	MOV	COMM_PERIOD4X_L, A
092A    E9            5997     MOV A , R1 
092B    3B            5998     ADDC A , R3 
092C    F541          5999     	MOV	COMM_PERIOD4X_H, A
092E    5006          6000     	JNC	($+8)
                      6001     
0930    7540FF        6002     	MOV	COMM_PERIOD4X_L, #0FFH
0933    7541FF        6003     	MOV	COMM_PERIOD4X_H, #0FFH
                      6004     
0936    2185          6005     	AJMP	CALC_NEW_WAIT_TIMES_SETUP
                      6006     
                      6007     CALC_NEXT_COMM_NORMAL: 
                      6008     	; Calculate new commutation time 
0938    AA40          6009     MOV R2 , COMM_PERIOD4X_L 
093A    AB41          6010     MOV R3 , COMM_PERIOD4X_H 
093C    AC40          6011     MOV R4 , COMM_PERIOD4X_L 
093E    AD41          6012     MOV R5 , COMM_PERIOD4X_H 
0940    7E04          6013     MOV R6 , # 4 
0942    7F02          6014     MOV R7 , # 2 
0944    C3            6015     	CLR	C
0945    EB            6016     MOV A , R3 
0946    9404          6017     	SUBB	A, #04H
0948    400D          6018     	JC	CALC_NEXT_COMM_AVG_PERIOD_DIV
                      6019     
094A    1E            6020     DEC R6 
094B    1F            6021     DEC R7 
                      6022     
094C    C3            6023     	CLR	C
094D    EB            6024     MOV A , R3 
094E    9408          6025     	SUBB	A, #08H
0950    4005          6026     	JC	CALC_NEXT_COMM_AVG_PERIOD_DIV
                      6027     
0952    206A02        6028     JB FLAGS1 . 2 , CALC_NEXT_COMM_AVG_PERIOD_DIV 
                      6029     
0955    1E            6030     DEC R6 
0956    1F            6031     DEC R7 
                      6032     
                      6033     CALC_NEXT_COMM_AVG_PERIOD_DIV: 
0957    C3            6034     	CLR	C
0958    ED            6035     MOV A , R5 
0959    13            6036     	RRC	A					; Divide by 2
095A    FD            6037     MOV R5 , A 
095B    EC            6038     MOV A , R4 
095C    13            6039     	RRC	A
095D    FC            6040     MOV R4 , A 
095E    DEF7          6041     DJNZ R6 , CALC_NEXT_COMM_AVG_PERIOD_DIV 
                      6042     
0960    C3            6043     	CLR	C
0961    EA            6044     MOV A , R2 
0962    9C            6045     SUBB A , R4 
0963    FA            6046     MOV R2 , A 
0964    EB            6047     MOV A , R3 
0965    9D            6048     SUBB A , R5 
0966    FB            6049     MOV R3 , A 
0967    EF            6050     MOV A , R7 
0968    6009          6051     	JZ	CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE
                      6052     
                      6053     CALC_NEXT_COMM_NEW_PERIOD_DIV: 
096A    C3            6054     	CLR	C
096B    E9            6055     MOV A , R1 
096C    13            6056     	RRC	A					; Divide by 2
096D    F9            6057     MOV R1 , A 
096E    E8            6058     MOV A , R0 
096F    13            6059     	RRC	A
0970    F8            6060     MOV R0 , A 
0971    DFF7          6061     DJNZ R7 , CALC_NEXT_COMM_NEW_PERIOD_DIV 
                      6062     
                      6063     CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE: 
0973    EA            6064     MOV A , R2 
0974    28            6065     ADD A , R0 
0975    FA            6066     MOV R2 , A 
0976    EB            6067     MOV A , R3 
0977    39            6068     ADDC A , R1 
0978    FB            6069     MOV R3 , A 
0979    8A40          6070     MOV COMM_PERIOD4X_L , R2 
097B    8B41          6071     MOV COMM_PERIOD4X_H , R3 
097D    5006          6072     	JNC	CALC_NEW_WAIT_TIMES_SETUP; If period larger than 0xffff - go to slow case
                      6073     
097F    7BFF          6074     MOV R3 , # 0FFH 
0981    8B40          6075     MOV COMM_PERIOD4X_L , R3 
0983    8B41          6076     MOV COMM_PERIOD4X_H , R3 
                      6077     
                      6078     CALC_NEW_WAIT_TIMES_SETUP: 	
                      6079     	; Set high rpm bit (if above 156k erpm)
0985    C3            6080     	CLR	C
0986    EB            6081     MOV A , R3 
0987    9402          6082     	SUBB	A, #2
0989    5002          6083     	JNC	($+4)
                      6084     
098B    D266          6085     SETB FLAGS0 . 6 
                      6086     	
                      6087     	; Load programmed commutation timing
098D    306904        6088     JNB FLAGS1 . 1 , CALC_NEW_WAIT_PER_STARTUP_DONE 
                      6089     
0990    7F03          6090     MOV R7 , # 3 
0992    21B0          6091     	AJMP	CALC_NEW_WAIT_PER_DEMAG_DONE
                      6092     
                      6093     CALC_NEW_WAIT_PER_STARTUP_DONE: 
0994    7892          6094     MOV R0 , # PGM_COMM_TIMING 
0996    E6            6095     MOV A , @ R0 
0997    FF            6096     MOV R7 , A 
0998    C3            6097     	CLR	C
0999    E537          6098     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
099B    9482          6099     	SUBB	A, #130
099D    4011          6100     	JC	CALC_NEW_WAIT_PER_DEMAG_DONE
                      6101     
099F    0F            6102     INC R7 
                      6103     
09A0    C3            6104     	CLR	C
09A1    E537          6105     	MOV	A, DEMAG_DETECTED_METRIC
09A3    94A0          6106     	SUBB	A, #160
09A5    4001          6107     	JC	($+3)
                      6108     
09A7    0F            6109     INC R7 
                      6110     
09A8    C3            6111     	CLR	C
09A9    EF            6112     MOV A , R7 
09AA    9406          6113     	SUBB	A, #6
09AC    4002          6114     	JC	($+4)
                      6115     
09AE    7F05          6116     MOV R7 , # 5 
                      6117     
                      6118     CALC_NEW_WAIT_PER_DEMAG_DONE: 
09B0    7E02          6119     MOV R6 , # 2 
                      6120     	; Load current commutation timing
09B2    E541          6121     	MOV	A, COMM_PERIOD4X_H		; Divide 4 times
09B4    C4            6122     	SWAP	A
09B5    540F          6123     	ANL	A, #00FH
09B7    F9            6124     MOV R1 , A 
09B8    E541          6125     	MOV	A, COMM_PERIOD4X_H
09BA    C4            6126     	SWAP	A
09BB    54F0          6127     	ANL	A, #0F0H
09BD    F8            6128     MOV R0 , A 
09BE    E540          6129     	MOV	A, COMM_PERIOD4X_L
09C0    C4            6130     	SWAP	A
09C1    540F          6131     	ANL	A, #00FH
09C3    28            6132     ADD A , R0 
09C4    F8            6133     MOV R0 , A 
                      6134     
09C5    C3            6135     	CLR	C
09C6    E8            6136     MOV A , R0 
09C7    9E            6137     SUBB A , R6 
09C8    FA            6138     MOV R2 , A 
09C9    E9            6139     MOV A , R1 
09CA    9400          6140     	SUBB	A, #0
09CC    FB            6141     MOV R3 , A 
09CD    4009          6142     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      6143     
09CF    C3            6144     	CLR	C
09D0    EA            6145     MOV A , R2 
09D1    9402          6146     	SUBB	A, #(COMM_TIME_MIN SHL 1)
09D3    EB            6147     MOV A , R3 
09D4    9400          6148     	SUBB	A, #0
09D6    5004          6149     	JNC	CALC_NEW_WAIT_TIMES_EXIT	; Check that result is still above minumum
                      6150     
                      6151     LOAD_MIN_TIME: 
09D8    7A02          6152     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
09DA    E4            6153     	CLR	A
09DB    FB            6154     MOV R3 , A 
                      6155     
                      6156     CALC_NEW_WAIT_TIMES_EXIT: 	
09DC    412A          6157     	AJMP	WAIT_ADVANCE_TIMING
                      6158     
                      6159     
                      6160     ; Fast calculation (Comm_Period4x_H less than 2)
                      6161     CALC_NEXT_COMM_TIMING_FAST: 			
                      6162     	; Calculate new commutation time
09DE    AA40          6163     MOV R2 , COMM_PERIOD4X_L 
09E0    AB41          6164     MOV R3 , COMM_PERIOD4X_H 
09E2    EB            6165     MOV A , R3 
09E3    C4            6166     	SWAP	A
09E4    FE            6167     MOV R6 , A 
09E5    EA            6168     MOV A , R2 
09E6    C4            6169     	SWAP A
09E7    540F          6170     	ANL	A, #0FH
09E9    4E            6171     ORL A , R6 
09EA    FC            6172     MOV R4 , A 
09EB    C3            6173     	CLR	C
09EC    EA            6174     MOV A , R2 
09ED    9C            6175     SUBB A , R4 
09EE    FA            6176     MOV R2 , A 
09EF    EB            6177     MOV A , R3 
09F0    9400          6178     	SUBB	A, #0
09F2    FB            6179     MOV R3 , A 
09F3    C3            6180     	CLR	C
09F4    E8            6181     MOV A , R0 
09F5    13            6182     	RRC	A					; Divide by 2 2 times
09F6    C3            6183     	CLR	C
09F7    13            6184     	RRC	A
09F8    F8            6185     MOV R0 , A 
09F9    EA            6186     MOV A , R2 
09FA    28            6187     ADD A , R0 
09FB    FA            6188     MOV R2 , A 
09FC    EB            6189     MOV A , R3 
09FD    3400          6190     	ADDC	A, #0
09FF    FB            6191     MOV R3 , A 
0A00    8A40          6192     MOV COMM_PERIOD4X_L , R2 
0A02    8B41          6193     MOV COMM_PERIOD4X_H , R3 
0A04    C3            6194     	CLR	C
0A05    EB            6195     MOV A , R3 
0A06    9402          6196     	SUBB	A, #2
0A08    4002          6197     	JC	($+4)
                      6198     
0A0A    C266          6199     CLR FLAGS0 . 6 
                      6200     	
0A0C    7802          6201     MOV R0 , # 2 
0A0E    EB            6202     MOV A , R3 
0A0F    C4            6203     	SWAP	A
0A10    FE            6204     MOV R6 , A 
0A11    7B00          6205     MOV R3 , # 0 
0A13    EA            6206     MOV A , R2 
0A14    C4            6207     	SWAP A
0A15    540F          6208     	ANL	A, #0FH
0A17    4E            6209     ORL A , R6 
0A18    FA            6210     MOV R2 , A 
0A19    C3            6211     	CLR	C
0A1A    EA            6212     MOV A , R2 
0A1B    98            6213     SUBB A , R0 
0A1C    FA            6214     MOV R2 , A 
0A1D    4005          6215     	JC	LOAD_MIN_TIME_FAST		; Check that result is still positive
                      6216     
0A1F    C3            6217     	CLR	C
0A20    9402          6218     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0A22    5002          6219     	JNC	CALC_NEW_WAIT_TIMES_FAST_DONE	; Check that result is still above minumum
                      6220     
                      6221     LOAD_MIN_TIME_FAST: 
0A24    7A02          6222     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
                      6223     
                      6224     CALC_NEW_WAIT_TIMES_FAST_DONE: 	
0A26    7892          6225     MOV R0 , # PGM_COMM_TIMING 
0A28    E6            6226     MOV A , @ R0 
0A29    FF            6227     MOV R7 , A 
                      6228     
                      6229     
                      6230     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6231     ;
                      6232     ; Wait advance timing routine
                      6233     ;
                      6234     ; No assumptions
                      6235     ; NOTE: Be VERY careful if using temp registers. They are passed over this routine
                      6236     ;
                      6237     ; Waits for the advance timing to elapse and sets up the next zero cross wait
                      6238     ;
                      6239     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6240     WAIT_ADVANCE_TIMING: 	
0A2A    306002        6241     JNB FLAGS0 . 0 , ( $+5 ) 
0A2D    412A          6242     	AJMP	WAIT_ADVANCE_TIMING
                      6243     
                      6244     	; Setup next wait time
0A2F    855192        6245     	MOV	TMR3RLL, WT_ZC_TOUT_START_L
0A32    855293        6246     	MOV	TMR3RLH, WT_ZC_TOUT_START_H
0A35    D260          6247     SETB FLAGS0 . 0 
0A37    43E680        6248     	ORL	EIE1, #80H	; Enable timer3 interrupts
                      6249     
                      6250     
                      6251     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6252     ;
                      6253     ; Calculate new wait times routine
                      6254     ;
                      6255     ; No assumptions
                      6256     ;
                      6257     ; Calculates new wait times
                      6258     ;
                      6259     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6260     CALC_NEW_WAIT_TIMES: 	
0A3A    C3            6261     	CLR	C
0A3B    E4            6262     	CLR	A
0A3C    9A            6263     SUBB A , R2 
0A3D    F8            6264     MOV R0 , A 
0A3E    E4            6265     	CLR	A
0A3F    9B            6266     SUBB A , R3 
0A40    F9            6267     MOV R1 , A 
                      6268     IF MCU_48MHZ == 1
                               	CLR	C
                               	MOV	A, TEMP1				; Multiply by 2
                               	RLC	A
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	RLC	A
                               	MOV	TEMP2, A
                               ENDIF
0A41    306602        6277     JNB FLAGS0 . 6 , ( $+5 ) 
0A44    41B6          6278     	AJMP	CALC_NEW_WAIT_TIMES_FAST
                      6279     
0A46    E8            6280     MOV A , R0 
0A47    FA            6281     MOV R2 , A 
0A48    E9            6282     MOV A , R1 
0A49    FB            6283     MOV R3 , A 
0A4A    D3            6284     	SETB	C					; Negative numbers - set carry
0A4B    E9            6285     MOV A , R1 
0A4C    13            6286     	RRC	A					; Divide by 2
0A4D    FD            6287     MOV R5 , A 
0A4E    E8            6288     MOV A , R0 
0A4F    13            6289     	RRC	A
0A50    FC            6290     MOV R4 , A 
0A51    8851          6291     MOV WT_ZC_TOUT_START_L , R0 
0A53    8952          6292     MOV WT_ZC_TOUT_START_H , R1 
0A55    C3            6293     	CLR	C
0A56    EF            6294     MOV A , R7 
0A57    9403          6295     	SUBB	A, #3				; Is timing normal?
0A59    6038          6296     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      6297     
0A5B    EF            6298     MOV A , R7 
0A5C    20E00D        6299     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      6300     
0A5F    E8            6301     MOV A , R0 
0A60    2C            6302     ADD A , R4 
0A61    F8            6303     MOV R0 , A 
0A62    E9            6304     MOV A , R1 
0A63    3D            6305     ADDC A , R5 
0A64    F9            6306     MOV R1 , A 
0A65    EC            6307     MOV A , R4 
0A66    FA            6308     MOV R2 , A 
0A67    ED            6309     MOV A , R5 
0A68    FB            6310     MOV R3 , A 
0A69    020A7F        6311     	JMP	STORE_TIMES_UP_OR_DOWN
                      6312     
                      6313     ADJUST_TIMING_TWO_STEPS: 
0A6C    E8            6314     MOV A , R0 
0A6D    28            6315     ADD A , R0 
0A6E    F8            6316     MOV R0 , A 
0A6F    E9            6317     MOV A , R1 
0A70    39            6318     ADDC A , R1 
0A71    F9            6319     MOV R1 , A 
0A72    C3            6320     	CLR	C
0A73    E8            6321     MOV A , R0 
0A74    2402          6322     	ADD	A, #(COMM_TIME_MIN SHL 1)
0A76    F8            6323     MOV R0 , A 
0A77    E9            6324     MOV A , R1 
0A78    3400          6325     	ADDC	A, #0
0A7A    F9            6326     MOV R1 , A 
0A7B    7AFE          6327     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
0A7D    7BFF          6328     MOV R3 , # 0FFH 
                      6329     
                      6330     STORE_TIMES_UP_OR_DOWN: 
0A7F    C3            6331     	CLR	C
0A80    EF            6332     MOV A , R7 
0A81    9403          6333     	SUBB	A, #3					; Is timing higher than normal?
0A83    400E          6334     	JC	STORE_TIMES_DECREASE		; No - branch
                      6335     
                      6336     STORE_TIMES_INCREASE: 
0A85    8A53          6337     MOV WT_COMM_START_L , R2 
0A87    8B54          6338     MOV WT_COMM_START_H , R3 
0A89    884D          6339     MOV WT_ADV_START_L , R0 
0A8B    894E          6340     MOV WT_ADV_START_H , R1 
0A8D    8C4F          6341     MOV WT_ZC_SCAN_START_L , R4 
0A8F    8D50          6342     MOV WT_ZC_SCAN_START_H , R5 
0A91    41EA          6343     	AJMP	WAIT_BEFORE_ZC_SCAN
                      6344     
                      6345     STORE_TIMES_DECREASE: 
0A93    8853          6346     MOV WT_COMM_START_L , R0 
0A95    8954          6347     MOV WT_COMM_START_H , R1 
0A97    8A4D          6348     MOV WT_ADV_START_L , R2 
0A99    8B4E          6349     MOV WT_ADV_START_H , R3 
0A9B    8C4F          6350     MOV WT_ZC_SCAN_START_L , R4 
0A9D    8D50          6351     MOV WT_ZC_SCAN_START_H , R5 
0A9F    306912        6352     JNB FLAGS1 . 1 , STORE_TIMES_EXIT 
                      6353     
0AA2    7553F0        6354     	MOV	WT_COMM_START_L, #0F0H		; Set very short delays for all but advance time during startup, in order to widen zero cross capture range
0AA5    7554FF        6355     	MOV	WT_COMM_START_H, #0FFH
0AA8    754FF0        6356     	MOV	WT_ZC_SCAN_START_L, #0F0H
0AAB    7550FF        6357     	MOV	WT_ZC_SCAN_START_H, #0FFH
0AAE    7551F0        6358     	MOV	WT_ZC_TOUT_START_L, #0F0H
0AB1    7552FF        6359     	MOV	WT_ZC_TOUT_START_H, #0FFH
                      6360     
                      6361     STORE_TIMES_EXIT: 
0AB4    41EA          6362     	AJMP	WAIT_BEFORE_ZC_SCAN
                      6363     
                      6364     
                      6365     CALC_NEW_WAIT_TIMES_FAST: 	
0AB6    E8            6366     MOV A , R0 
0AB7    FA            6367     MOV R2 , A 
0AB8    D3            6368     	SETB	C					; Negative numbers - set carry
0AB9    E8            6369     MOV A , R0 
0ABA    13            6370     	RRC	A
0ABB    FC            6371     MOV R4 , A 
0ABC    8851          6372     MOV WT_ZC_TOUT_START_L , R0 
0ABE    C3            6373     	CLR	C
0ABF    EF            6374     MOV A , R7 
0AC0    9403          6375     	SUBB	A, #3				; Is timing normal?
0AC2    6020          6376     	JZ	STORE_TIMES_DECREASE_FAST; Yes - branch
                      6377     
0AC4    EF            6378     MOV A , R7 
0AC5    20E007        6379     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS_FAST	; If an odd number - branch
                      6380     
0AC8    E8            6381     MOV A , R0 
0AC9    2C            6382     ADD A , R4 
0ACA    F8            6383     MOV R0 , A 
0ACB    EC            6384     MOV A , R4 
0ACC    FA            6385     MOV R2 , A 
0ACD    41D6          6386     	AJMP	STORE_TIMES_UP_OR_DOWN_FAST
                      6387     
                      6388     ADJUST_TIMING_TWO_STEPS_FAST: 
0ACF    E8            6389     MOV A , R0 
0AD0    28            6390     ADD A , R0 
0AD1    2402          6391     	ADD	A, #(COMM_TIME_MIN SHL 1)
0AD3    F8            6392     MOV R0 , A 
0AD4    7AFE          6393     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
                      6394     
                      6395     STORE_TIMES_UP_OR_DOWN_FAST: 
0AD6    C3            6396     	CLR	C
0AD7    EF            6397     MOV A , R7 
0AD8    9403          6398     	SUBB	A, #3				; Is timing higher than normal?
0ADA    4008          6399     	JC	STORE_TIMES_DECREASE_FAST; No - branch
                      6400     
                      6401     STORE_TIMES_INCREASE_FAST: 
0ADC    8A53          6402     MOV WT_COMM_START_L , R2 
0ADE    884D          6403     MOV WT_ADV_START_L , R0 
0AE0    8C4F          6404     MOV WT_ZC_SCAN_START_L , R4 
0AE2    41EA          6405     	AJMP	WAIT_BEFORE_ZC_SCAN
                      6406     
                      6407     STORE_TIMES_DECREASE_FAST: 
0AE4    8853          6408     MOV WT_COMM_START_L , R0 
0AE6    8A4D          6409     MOV WT_ADV_START_L , R2 
0AE8    8C4F          6410     MOV WT_ZC_SCAN_START_L , R4 
                      6411     
                      6412     
                      6413     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6414     ;
                      6415     ; Wait before zero cross scan routine
                      6416     ;
                      6417     ; No assumptions
                      6418     ;
                      6419     ; Waits for the zero cross scan wait time to elapse
                      6420     ; Also sets up timer 3 for the zero cross scan timeout time
                      6421     ;
                      6422     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6423     WAIT_BEFORE_ZC_SCAN: 	
                      6424     	; Calculate random number
0AEA    E568          6425     	MOV	A, RANDOM
0AEC    C3            6426     	CLR	C
0AED    33            6427     	RLC	A
0AEE    5002          6428     	JNC	WAIT_BEFORE_ZC_SCAN_RAND
                      6429     
0AF0    646B          6430     	XRL	A, #06BH		; Sequence length of 35, when initialized to 1
                      6431     
                      6432     WAIT_BEFORE_ZC_SCAN_RAND:           
0AF2    F568          6433     	MOV	RANDOM, A
                      6434     
                      6435     WAIT_BEFORE_ZC_SCAN_WAIT:           
0AF4    306002        6436     JNB FLAGS0 . 0 , ( $+5 ) 
0AF7    41F4          6437     	AJMP	WAIT_BEFORE_ZC_SCAN_WAIT
                      6438     
0AF9    753402        6439     	MOV	STARTUP_ZC_TIMEOUT_CNTD, #2
                      6440     SETUP_ZC_SCAN_TIMEOUT: 
0AFC    D260          6441     SETB FLAGS0 . 0 
0AFE    43E680        6442     	ORL	EIE1, #80H			; Enable timer3 interrupts
0B01    E52D          6443     	MOV	A, FLAGS1
0B03    5406          6444     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0B05    6034          6445     	JZ	WAIT_BEFORE_ZC_SCAN_EXIT		
                      6446     
0B07    A840          6447     MOV R0 , COMM_PERIOD4X_L 
0B09    A941          6448     MOV R1 , COMM_PERIOD4X_H 
0B0B    C3            6449     	CLR	C
0B0C    E9            6450     MOV A , R1 
0B0D    13            6451     	RRC	A
0B0E    F9            6452     MOV R1 , A 
0B0F    E8            6453     MOV A , R0 
0B10    13            6454     	RRC	A
0B11    F8            6455     MOV R0 , A 
                      6456     IF MCU_48MHZ == 0
0B12    C3            6457     	CLR	C
0B13    E9            6458     MOV A , R1 
0B14    13            6459     	RRC	A
0B15    F9            6460     MOV R1 , A 
0B16    E8            6461     MOV A , R0 
0B17    13            6462     	RRC	A
0B18    F8            6463     MOV R0 , A 
                      6464     ENDIF
0B19    306904        6465     JNB FLAGS1 . 1 , SETUP_ZC_SCAN_TIMEOUT_STARTUP_DONE 
                      6466     	
0B1C    E9            6467     MOV A , R1 
0B1D    2440          6468     	ADD	A, #40H				; Increase timeout somewhat to avoid false wind up
0B1F    F9            6469     MOV R1 , A 
                      6470     
                      6471     SETUP_ZC_SCAN_TIMEOUT_STARTUP_DONE: 
0B20    C2AF          6472     	CLR	EA
0B22    53E67F        6473     	ANL	EIE1, #7FH			; Disable timer3 interrupts
0B25    759100        6474     	MOV	TMR3CN, #00H			; Timer3 disabled and interrupt flag cleared
0B28    C3            6475     	CLR	C
0B29    E4            6476     	CLR	A
0B2A    98            6477     SUBB A , R0 
0B2B    F594          6478     	MOV	TMR3L, A
0B2D    E4            6479     	CLR	A
0B2E    99            6480     SUBB A , R1 
0B2F    F595          6481     	MOV	TMR3H, A
0B31    759104        6482     	MOV	TMR3CN, #04H			; Timer3 enabled and interrupt flag cleared
0B34    D260          6483     SETB FLAGS0 . 0 
0B36    43E680        6484     	ORL	EIE1, #80H			; Enable timer3 interrupts
0B39    D2AF          6485     	SETB	EA
                      6486     
                      6487     WAIT_BEFORE_ZC_SCAN_EXIT:           
0B3B    22            6488     	RET
                      6489     
                      6490     
                      6491     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6492     ;
                      6493     ; Wait for comparator to go low/high routines
                      6494     ;
                      6495     ; No assumptions
                      6496     ;
                      6497     ; Waits for the zero cross scan wait time to elapse
                      6498     ; Then scans for comparator going low/high
                      6499     ;
                      6500     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6501     WAIT_FOR_COMP_OUT_LOW: 
0B3C    D264          6502     SETB FLAGS0 . 4 
0B3E    754300        6503     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0B41    752000        6504     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0B44    306C03        6505     JNB FLAGS1 . 4 , ( $+6 ) 
0B47    752040        6506     	MOV	BIT_ACCESS, #40H		
0B4A    020B5B        6507     	JMP	WAIT_FOR_COMP_OUT_START
                      6508     
                      6509     WAIT_FOR_COMP_OUT_HIGH: 
0B4D    D264          6510     SETB FLAGS0 . 4 
0B4F    754300        6511     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0B52    752040        6512     	MOV	BIT_ACCESS, #40H			; Desired comparator output
0B55    306C03        6513     JNB FLAGS1 . 4 , ( $+6 ) 
0B58    752000        6514     	MOV	BIT_ACCESS, #00H		
                      6515     
                      6516     WAIT_FOR_COMP_OUT_START: 
                      6517     	; Set number of comparator readings
0B5B    7801          6518     MOV R0 , # 1 
0B5D    7901          6519     MOV R1 , # 1 
0B5F    206620        6520     JB FLAGS0 . 6 , COMP_SCALE_SAMPLES 
                      6521     
0B62    E52D          6522     	MOV	A, FLAGS1					; Clear demag detected flag if start phases
0B64    5406          6523     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0B66    6002          6524     	JZ	($+4)
                      6525     		
0B68    C264          6526     CLR FLAGS0 . 4 
                      6527     
0B6A    7914          6528     MOV R1 , # 20 
0B6C    E541          6529     	MOV 	A, COMM_PERIOD4X_H			; Set number of readings higher for lower speeds	
0B6E    C3            6530     	CLR	C
0B6F    13            6531     	RRC	A
0B70    7001          6532     	JNZ	($+3)
0B72    04            6533     	INC	A
0B73    F8            6534     MOV R0 , A 
0B74    C3            6535     	CLR	C						
0B75    9414          6536     	SUBB	A, #20			
0B77    4002          6537     	JC	($+4)
                      6538     
0B79    7814          6539     MOV R0 , # 20 
                      6540     	
0B7B    306904        6541     JNB FLAGS1 . 1 , COMP_SCALE_SAMPLES 
                      6542     
0B7E    781B          6543     MOV R0 , # 27 
0B80    791B          6544     MOV R1 , # 27 
                      6545     
                      6546     COMP_SCALE_SAMPLES: 
                      6547     IF MCU_48MHZ == 1
                               	CLR	C
                               	MOV	A, TEMP1
                               	RLC	A
                               	MOV	TEMP1, A
                               	CLR	C
                               	MOV	A, TEMP2
                               	RLC	A
                               	MOV	TEMP2, A
                               ENDIF
                      6557     
                      6558     COMP_CHECK_TIMEOUT: 
0B82    206010        6559     JB FLAGS0 . 0 , COMP_CHECK_TIMEOUT_NOT_TIMED_OUT 
                      6560     
0B85    E543          6561     	MOV	A, COMPARATOR_READ_CNT				; Check that comparator has been read
0B87    600C          6562     	JZ	COMP_CHECK_TIMEOUT_NOT_TIMED_OUT		; If not read - branch
                      6563     
0B89    306903        6564     JNB FLAGS1 . 1 , COMP_CHECK_TIMEOUT_TIMEOUT_EXTENDED 
                      6565     
0B8C    D53404        6566     	DJNZ	STARTUP_ZC_TIMEOUT_CNTD, COMP_CHECK_TIMEOUT_EXTEND_TIMEOUT
                      6567     
                      6568     COMP_CHECK_TIMEOUT_TIMEOUT_EXTENDED: 
0B8F    D26D          6569     SETB FLAGS1 . 5 
0B91    8106          6570     	AJMP	SETUP_COMM_WAIT
                      6571     
                      6572     COMP_CHECK_TIMEOUT_EXTEND_TIMEOUT: 
0B93    51FC          6573     	CALL	SETUP_ZC_SCAN_TIMEOUT
                      6574     COMP_CHECK_TIMEOUT_NOT_TIMED_OUT: 
0B95    0543          6575     	INC	COMPARATOR_READ_CNT			; Increment comparator read count
                      6576     	READ_COMP_OUT					; Read comparator output
0B97    E59B          6576+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0B99    F4            6576+1   CPL A  ; INVERT OUTPUT
0B9A    5440          6577     	ANL	A, #40H
0B9C    B52002        6578     	CJNE	A, BIT_ACCESS, COMP_READ_WRONG
0B9F    61F0          6579     	AJMP	COMP_READ_OK
                      6580     	
                      6581     COMP_READ_WRONG: 
0BA1    306909        6582     JNB FLAGS1 . 1 , COMP_READ_WRONG_NOT_STARTUP 
                      6583     
0BA4    08            6584     INC R0 
0BA5    C3            6585     	CLR	C
0BA6    E8            6586     MOV A , R0 
0BA7    99            6587     SUBB A , R1 
0BA8    4001          6588     	JC	($+3)
0BAA    18            6589     DEC R0 
                      6590     
0BAB    6182          6591     	AJMP	COMP_CHECK_TIMEOUT			; Continue to look for good ones
                      6592     
                      6593     COMP_READ_WRONG_NOT_STARTUP: 
0BAD    20640A        6594     JB FLAGS0 . 4 , COMP_READ_WRONG_EXTEND_TIMEOUT 
                      6595     
0BB0    08            6596     INC R0 
0BB1    C3            6597     	CLR	C
0BB2    E8            6598     MOV A , R0 
0BB3    99            6599     SUBB A , R1 
0BB4    4002          6600     	JC	($+4)
0BB6    615B          6601     	AJMP	WAIT_FOR_COMP_OUT_START		; If above initial requirement - go back and restart
                      6602     
0BB8    6182          6603     	AJMP	COMP_CHECK_TIMEOUT			; Otherwise - take another reading
                      6604     
                      6605     COMP_READ_WRONG_EXTEND_TIMEOUT: 
0BBA    C264          6606     CLR FLAGS0 . 4 
0BBC    C2AF          6607     	CLR	EA
0BBE    53E67F        6608     	ANL	EIE1, #7FH				; Disable timer3 interrupts
0BC1    759100        6609     	MOV	TMR3CN, #00H				; Timer3 disabled and interrupt flag cleared
0BC4    306612        6610     JNB FLAGS0 . 6 , COMP_READ_WRONG_LOW_RPM 
                      6611     
0BC7    759400        6612     	MOV	TMR3L, #00H				; Set timeout to ~1ms
                      6613     IF MCU_48MHZ == 1
                               	MOV	TMR3H, #0F0H
                               ELSE
0BCA    7595F8        6616     	MOV	TMR3H, #0F8H
                      6617     ENDIF
                      6618     COMP_READ_WRONG_TIMEOUT_SET: 
0BCD    759104        6619     	MOV	TMR3CN, #04H				; Timer3 enabled and interrupt flag cleared
0BD0    D260          6620     SETB FLAGS0 . 0 
0BD2    43E680        6621     	ORL	EIE1, #80H				; Enable timer3 interrupts
0BD5    D2AF          6622     	SETB	EA
0BD7    615B          6623     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      6624     
                      6625     COMP_READ_WRONG_LOW_RPM: 
0BD9    E541          6626     	MOV	A, COMM_PERIOD4X_H			; Set timeout to ~4x comm period 4x value
0BDB    7EFF          6627     MOV R6 , # 0FFH 
                      6628     IF MCU_48MHZ == 1
                               	CLR	C
                               	RLC	A
                               	JC	COMP_READ_WRONG_LOAD_TIMEOUT
                               
                               ENDIF
0BDD    C3            6634     	CLR	C
0BDE    33            6635     	RLC	A
0BDF    4005          6636     	JC	COMP_READ_WRONG_LOAD_TIMEOUT
                      6637     
0BE1    C3            6638     	CLR	C
0BE2    33            6639     	RLC	A
0BE3    4001          6640     	JC	COMP_READ_WRONG_LOAD_TIMEOUT
                      6641     
0BE5    FE            6642     MOV R6 , A 
                      6643     
                      6644     COMP_READ_WRONG_LOAD_TIMEOUT: 
0BE6    C3            6645     	CLR	C
0BE7    E4            6646     	CLR	A
0BE8    9E            6647     SUBB A , R6 
0BE9    759400        6648     	MOV	TMR3L, #0
0BEC    F595          6649     	MOV	TMR3H, A
0BEE    61CD          6650     	AJMP	COMP_READ_WRONG_TIMEOUT_SET
                      6651     
                      6652     COMP_READ_OK: 
0BF0    C3            6653     	CLR	C
0BF1    E533          6654     	MOV	A, STARTUP_CNT				; Force a timeout for the first commutation		
0BF3    9401          6655     	SUBB	A, #1
0BF5    5002          6656     	JNC	($+4)
0BF7    615B          6657     	AJMP	WAIT_FOR_COMP_OUT_START
                      6658     
0BF9    306402        6659     JNB FLAGS0 . 4 , ( $+5 ) 
0BFC    615B          6660     	AJMP	WAIT_FOR_COMP_OUT_START
                      6661     
0BFE    D802          6662     DJNZ R0 , COMP_READ_OK_JMP 
0C00    8104          6663     	AJMP	($+4)
                      6664     
                      6665     COMP_READ_OK_JMP: 
0C02    6182          6666     	AJMP	COMP_CHECK_TIMEOUT	
                      6667     
0C04    C26D          6668     CLR FLAGS1 . 5 
                      6669     
                      6670     
                      6671     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6672     ;
                      6673     ; Setup commutation timing routine
                      6674     ;
                      6675     ; No assumptions
                      6676     ;
                      6677     ; Sets up and starts wait from commutation to zero cross
                      6678     ;
                      6679     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6680     SETUP_COMM_WAIT:  
0C06    C2AF          6681     	CLR	EA
0C08    53E67F        6682     	ANL	EIE1, #7FH		; Disable timer3 interrupts
0C0B    759100        6683     	MOV	TMR3CN, #00H		; Timer3 disabled and interrupt flag cleared
0C0E    855394        6684     	MOV	TMR3L, WT_COMM_START_L
0C11    855495        6685     	MOV	TMR3H, WT_COMM_START_H
0C14    759104        6686     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
                      6687     	; Setup next wait time
0C17    854D92        6688     	MOV	TMR3RLL, WT_ADV_START_L
0C1A    854E93        6689     	MOV	TMR3RLH, WT_ADV_START_H
0C1D    D260          6690     SETB FLAGS0 . 0 
0C1F    43E680        6691     	ORL	EIE1, #80H		; Enable timer3 interrupts
0C22    D2AF          6692     	SETB	EA				; Enable interrupts again
                      6693     
                      6694     
                      6695     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6696     ;
                      6697     ; Evaluate comparator integrity
                      6698     ;
                      6699     ; No assumptions
                      6700     ;
                      6701     ; Checks comparator signal behaviour versus expected behaviour
                      6702     ;
                      6703     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6704     EVALUATE_COMPARATOR_INTEGRITY: 
0C24    E52D          6705     	MOV	A, FLAGS1
0C26    5406          6706     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0C28    6008          6707     	JZ	EVAL_COMP_CHECK_TIMEOUT
                      6708     
0C2A    206A02        6709     JB FLAGS1 . 2 , ( $+5 ) 
0C2D    0533          6710     	INC	STARTUP_CNT					; Increment counter
0C2F    020C42        6711     	JMP	EVAL_COMP_EXIT
                      6712     
                      6713     EVAL_COMP_CHECK_TIMEOUT: 
0C32    306D0D        6714     JNB FLAGS1 . 5 , EVAL_COMP_EXIT 
0C35    206C0A        6715     JB FLAGS1 . 4 , EVAL_COMP_EXIT 
0C38    206407        6716     JB FLAGS0 . 4 , EVAL_COMP_EXIT 
0C3B    1581          6717     	DEC	SP								; Routine exit without "ret" command
0C3D    1581          6718     	DEC	SP
0C3F    021585        6719     	LJMP	RUN_TO_WAIT_FOR_POWER_ON_FAIL			; Yes - exit run mode
                      6720     
                      6721     EVAL_COMP_EXIT: 
0C42    22            6722     	RET
                      6723     
                      6724     
                      6725     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6726     ;
                      6727     ; Wait for commutation routine
                      6728     ;
                      6729     ; No assumptions
                      6730     ;
                      6731     ; Waits from zero cross to commutation 
                      6732     ;
                      6733     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6734     WAIT_FOR_COMM:  
                      6735     	; Update demag metric
0C43    7800          6736     MOV R0 , # 0 
0C45    306402        6737     JNB FLAGS0 . 4 , ( $+5 ) 
                      6738     
0C48    7801          6739     MOV R0 , # 1 
                      6740     
0C4A    E537          6741     	MOV	A, DEMAG_DETECTED_METRIC	; Sliding average of 8, 256 when demag and 0 when not. Limited to minimum 120
0C4C    75F007        6742     	MOV	B, #7
0C4F    A4            6743     	MUL	AB					; Multiply by 7
0C50    F9            6744     MOV R1 , A 
0C51    E5F0          6745     	MOV	A, B					; Add new value for current demag status
0C53    28            6746     ADD A , R0 
0C54    F5F0          6747     	MOV	B, A
0C56    E9            6748     MOV A , R1 
0C57    A2F0          6749     	MOV	C, B.0				; Divide by 8
0C59    13            6750     	RRC	A					
0C5A    A2F1          6751     	MOV	C, B.1
0C5C    13            6752     	RRC	A
0C5D    A2F2          6753     	MOV	C, B.2
0C5F    13            6754     	RRC	A
0C60    F537          6755     	MOV	DEMAG_DETECTED_METRIC, A
0C62    C3            6756     	CLR	C
0C63    9478          6757     	SUBB	A, #120				; Limit to minimum 120
0C65    5003          6758     	JNC	($+5)
                      6759     
0C67    753778        6760     	MOV	DEMAG_DETECTED_METRIC, #120
                      6761     
0C6A    C3            6762     	CLR	C
0C6B    E537          6763     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0C6D    9538          6764     	SUBB	A, DEMAG_PWR_OFF_THRESH
0C6F    4008          6765     	JC	WAIT_FOR_COMM_WAIT		; Cut power if many consecutive demags. This will help retain sync during hard accelerations
                      6766     
0C71    D265          6767     SETB FLAGS0 . 5 
                      6768     IF NFETON_DELAY NE 0
                      6769     	ALL_NFETS_OFF
0C73    C294          6769+1   CLR P1 . 4 
0C75    C292          6769+1   CLR P1 . 2 
0C77    C290          6769+1   CLR P1 . 0 
                      6770     ELSE
                               	EN_OFF					; For EN/PWM style drivers
                               ENDIF
                      6773     
                      6774     WAIT_FOR_COMM_WAIT: 
0C79    306002        6775     JNB FLAGS0 . 0 , ( $+5 ) 
0C7C    8179          6776     	AJMP	WAIT_FOR_COMM_WAIT					
                      6777     
                      6778     	; Setup next wait time
0C7E    854F92        6779     	MOV	TMR3RLL, WT_ZC_SCAN_START_L
0C81    855093        6780     	MOV	TMR3RLH, WT_ZC_SCAN_START_H
0C84    D260          6781     SETB FLAGS0 . 0 
0C86    43E680        6782     	ORL	EIE1, #80H			; Enable timer3 interrupts
0C89    22            6783     	RET
                      6784     
                      6785     
                      6786     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6787     ;
                      6788     ; Commutation routines
                      6789     ;
                      6790     ; No assumptions
                      6791     ;
                      6792     ; Performs commutation switching 
                      6793     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      6794     ;
                      6795     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6796     ; Comm phase 1 to comm phase 2
                      6797     COMM1COMM2: 	
                      6798     	SET_RPM_OUT
0C8A    207D16        6799     JB FLAGS3 . 5 , COMM12_REV 
                      6800     
0C8D    C2AF          6801     	CLR 	EA					; Disable all interrupts
0C8F    754202        6802     	MOV	COMM_PHASE, #2
                      6803     	BPFET_OFF 				; Turn off pfet
0C92    C293          6803+1   CLR P1 . 3 
                      6804     	APFET_ON					; Turn on pfet
0C94    D295          6804+1   SETB P1 . 5 
0C96    306202        6805     JNB FLAGS0 . 2 , COMM12_NFET_DONE 
                      6806     	CNFET_ON					; Pwm on - turn on nfet
0C99    D290          6806+1   SETB P1 . 0 
                      6807     COMM12_NFET_DONE: 
0C9B    D2AF          6808     	SETB	EA
                      6809     	SET_COMP_PHASE_B 			; Set comparator phase
0C9D    759F70        6809+1   MOV CPT0MX , # 70H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0CA0    020E79        6810     	JMP	COMM_EXIT
                      6811     
                      6812     COMM12_REV: 	
0CA3    C2AF          6813     	CLR 	EA					; Disable all interrupts
0CA5    754202        6814     	MOV	COMM_PHASE, #2
                      6815     	BPFET_OFF 				; Turn off pfet
0CA8    C293          6815+1   CLR P1 . 3 
                      6816     	CPFET_ON					; Turn on pfet (reverse)
0CAA    D291          6816+1   SETB P1 . 1 
0CAC    306202        6817     JNB FLAGS0 . 2 , COMM12_NFET_DONE_REV 
                      6818     	ANFET_ON					; Pwm on - turn on nfet
0CAF    D294          6818+1   SETB P1 . 4 
                      6819     COMM12_NFET_DONE_REV: 
0CB1    D2AF          6820     	SETB	EA
                      6821     	SET_COMP_PHASE_B 			; Set comparator phase
0CB3    759F70        6821+1   MOV CPT0MX , # 70H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0CB6    020E79        6822     	JMP	COMM_EXIT
                      6823     
                      6824     
                      6825     ; Comm phase 2 to comm phase 3
                      6826     COMM2COMM3: 	
                      6827     	CLEAR_RPM_OUT
0CB9    307243        6828     JNB FLAGS2 . 2 , COMM23_NONDAMP 
                      6829     
                      6830     	; Comm2Comm3 Damped
0CBC    207D20        6831     JB FLAGS3 . 5 , COMM23_DAMP_REV 
                      6832     
0CBF    C2AF          6833     	CLR 	EA					; Disable all interrupts
0CC1    754203        6834     	MOV	COMM_PHASE, #3
0CC4    900132        6835     	MOV	DPTR, #PWM_BFET_DAMPED	
0CC7    757B08        6836     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6837     	CNFET_OFF					; Turn off fets
0CCA    C290          6837+1   CLR P1 . 0 
                      6838     	CPFET_OFF						
0CCC    C291          6838+1   CLR P1 . 1 
0CCE    306204        6839     JNB FLAGS0 . 2 , COMM23_NFET_OFF 
                      6840     	BNFET_ON					; Pwm on - turn on nfet
0CD1    D292          6840+1   SETB P1 . 2 
0CD3    81D7          6841     	AJMP	COMM23_FETS_DONE
                      6842     COMM23_NFET_OFF: 
                      6843     	BPFET_ON					; Pwm off - switch damping fets	
0CD5    D293          6843+1   SETB P1 . 3 
                      6844     COMM23_FETS_DONE: 
0CD7    D2AF          6845     	SETB	EA
                      6846     	SET_COMP_PHASE_C 			; Set comparator phase
0CD9    759F00        6846+1   MOV CPT0MX , # 00H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0CDC    020E79        6847     	LJMP	COMM_EXIT
                      6848     
                      6849     	; Comm2Comm3 Damped reverse
                      6850     COMM23_DAMP_REV: 
0CDF    C2AF          6851     	CLR 	EA					; Disable all interrupts
0CE1    754203        6852     	MOV	COMM_PHASE, #3
0CE4    900132        6853     	MOV	DPTR, #PWM_BFET_DAMPED	
0CE7    757B08        6854     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6855     	ANFET_OFF					; Turn off fets (reverse)
0CEA    C294          6855+1   CLR P1 . 4 
                      6856     	APFET_OFF						
0CEC    C295          6856+1   CLR P1 . 5 
0CEE    306204        6857     JNB FLAGS0 . 2 , COMM23_NFET_OFF_REV 
                      6858     	BNFET_ON					; Pwm on - turn on nfet
0CF1    D292          6858+1   SETB P1 . 2 
0CF3    81F7          6859     	AJMP	COMM23_FETS_DONE_REV
                      6860     COMM23_NFET_OFF_REV: 
                      6861     	BPFET_ON					; Pwm off - switch damping fets	
0CF5    D293          6861+1   SETB P1 . 3 
                      6862     COMM23_FETS_DONE_REV: 
0CF7    D2AF          6863     	SETB	EA
                      6864     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0CF9    759F20        6864+1   MOV CPT0MX , # 20H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0CFC    020E79        6865     	LJMP	COMM_EXIT
                      6866     
                      6867     	; Comm2Comm3 Non-damped
                      6868     COMM23_NONDAMP: 
0CFF    207D17        6869     JB FLAGS3 . 5 , COMM23_NONDAMP_REV 
                      6870     
0D02    C2AF          6871     	CLR 	EA					; Disable all interrupts
0D04    754203        6872     	MOV	COMM_PHASE, #3
0D07    90010D        6873     	MOV	DPTR, #PWM_BFET	
                      6874     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL BPFET)
                               ENDIF
                      6877     	CNFET_OFF					; Turn off nfet
0D0A    C290          6877+1   CLR P1 . 0 
0D0C    306202        6878     JNB FLAGS0 . 2 , COMM23_NFET_DONE 
                      6879     	BNFET_ON					; Yes - turn on nfet
0D0F    D292          6879+1   SETB P1 . 2 
                      6880     COMM23_NFET_DONE: 
0D11    D2AF          6881     	SETB	EA
                      6882     	SET_COMP_PHASE_C 			; Set comparator phase
0D13    759F00        6882+1   MOV CPT0MX , # 00H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0D16    020E79        6883     	LJMP	COMM_EXIT
                      6884     
                      6885     	; Comm2Comm3 Non-damped reverse
                      6886     COMM23_NONDAMP_REV: 
0D19    C2AF          6887     	CLR 	EA					; Disable all interrupts
0D1B    754203        6888     	MOV	COMM_PHASE, #3
0D1E    90010D        6889     	MOV	DPTR, #PWM_BFET	
                      6890     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL BPFET)
                               ENDIF
                      6893     	ANFET_OFF					; Turn off nfet (reverse)
0D21    C294          6893+1   CLR P1 . 4 
0D23    306202        6894     JNB FLAGS0 . 2 , COMM23_NFET_DONE_REV 
                      6895     	BNFET_ON					; Yes - turn on nfet
0D26    D292          6895+1   SETB P1 . 2 
                      6896     COMM23_NFET_DONE_REV: 
0D28    D2AF          6897     	SETB	EA
                      6898     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0D2A    759F20        6898+1   MOV CPT0MX , # 20H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0D2D    020E79        6899     	LJMP	COMM_EXIT
                      6900     
                      6901     
                      6902     ; Comm phase 3 to comm phase 4
                      6903     COMM3COMM4: 	
                      6904     	SET_RPM_OUT
0D30    207D16        6905     JB FLAGS3 . 5 , COMM34_REV 
                      6906     
0D33    C2AF          6907     	CLR 	EA					; Disable all interrupts
0D35    754204        6908     	MOV	COMM_PHASE, #4
                      6909     	APFET_OFF 				; Turn off pfet
0D38    C295          6909+1   CLR P1 . 5 
                      6910     	CPFET_ON					; Turn on pfet
0D3A    D291          6910+1   SETB P1 . 1 
0D3C    306202        6911     JNB FLAGS0 . 2 , COMM34_NFET_DONE 
                      6912     	BNFET_ON					; Pwm on - turn on nfet
0D3F    D292          6912+1   SETB P1 . 2 
                      6913     COMM34_NFET_DONE: 
0D41    D2AF          6914     	SETB	EA
                      6915     	SET_COMP_PHASE_A 			; Set comparator phase
0D43    759F20        6915+1   MOV CPT0MX , # 20H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0D46    020E79        6916     	JMP	COMM_EXIT
                      6917     
                      6918     COMM34_REV: 	
0D49    C2AF          6919     	CLR 	EA					; Disable all interrupts
0D4B    754204        6920     	MOV	COMM_PHASE, #4
                      6921     	CPFET_OFF 				; Turn off pfet (reverse)
0D4E    C291          6921+1   CLR P1 . 1 
                      6922     	APFET_ON					; Turn on pfet (reverse)
0D50    D295          6922+1   SETB P1 . 5 
0D52    306202        6923     JNB FLAGS0 . 2 , COMM34_NFET_DONE_REV 
                      6924     	BNFET_ON					; Pwm on - turn on nfet
0D55    D292          6924+1   SETB P1 . 2 
                      6925     COMM34_NFET_DONE_REV: 
0D57    D2AF          6926     	SETB	EA
                      6927     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0D59    759F00        6927+1   MOV CPT0MX , # 00H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0D5C    020E79        6928     	JMP	COMM_EXIT
                      6929     
                      6930     
                      6931     ; Comm phase 4 to comm phase 5
                      6932     COMM4COMM5: 	
                      6933     	CLEAR_RPM_OUT
0D5F    307243        6934     JNB FLAGS2 . 2 , COMM45_NONDAMP 
                      6935     
                      6936     	; Comm4Comm5 Damped
0D62    207D20        6937     JB FLAGS3 . 5 , COMM45_DAMP_REV 
                      6938     
0D65    C2AF          6939     	CLR 	EA					; Disable all interrupts
0D67    754205        6940     	MOV	COMM_PHASE, #5
0D6A    900121        6941     	MOV	DPTR, #PWM_AFET_DAMPED	
0D6D    757B20        6942     	MOV	DAMPINGFET, #(1 SHL APFET)
                      6943     	BNFET_OFF					; Turn off fets
0D70    C292          6943+1   CLR P1 . 2 
                      6944     	BPFET_OFF						
0D72    C293          6944+1   CLR P1 . 3 
0D74    306204        6945     JNB FLAGS0 . 2 , COMM45_NFET_OFF 
                      6946     	ANFET_ON					; Pwm on - turn on nfet
0D77    D294          6946+1   SETB P1 . 4 
0D79    A17D          6947     	AJMP	COMM45_FETS_DONE
                      6948     COMM45_NFET_OFF: 
                      6949     	APFET_ON					; Pwm off - switch damping fets	
0D7B    D295          6949+1   SETB P1 . 5 
                      6950     COMM45_FETS_DONE: 
0D7D    D2AF          6951     	SETB	EA
                      6952     	SET_COMP_PHASE_B 			; Set comparator phase
0D7F    759F70        6952+1   MOV CPT0MX , # 70H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0D82    020E79        6953     	LJMP	COMM_EXIT
                      6954     
                      6955     	; Comm4Comm5 Damped reverse
                      6956     COMM45_DAMP_REV: 
0D85    C2AF          6957     	CLR 	EA					; Disable all interrupts
0D87    754205        6958     	MOV	COMM_PHASE, #5
0D8A    900143        6959     	MOV	DPTR, #PWM_CFET_DAMPED	; (reverse)
0D8D    757B02        6960     	MOV	DAMPINGFET, #(1 SHL CPFET)	; (reverse)
                      6961     	BNFET_OFF					; Turn off fets
0D90    C292          6961+1   CLR P1 . 2 
                      6962     	BPFET_OFF						
0D92    C293          6962+1   CLR P1 . 3 
0D94    306204        6963     JNB FLAGS0 . 2 , COMM45_NFET_OFF_REV 
                      6964     	CNFET_ON					; Pwm on - turn on nfet (reverse)
0D97    D290          6964+1   SETB P1 . 0 
0D99    A19D          6965     	AJMP	COMM45_FETS_DONE_REV
                      6966     COMM45_NFET_OFF_REV: 
                      6967     	CPFET_ON					; Pwm off - switch damping fets (reverse)	
0D9B    D291          6967+1   SETB P1 . 1 
                      6968     COMM45_FETS_DONE_REV: 
0D9D    D2AF          6969     	SETB	EA
                      6970     	SET_COMP_PHASE_B 			; Set comparator phase
0D9F    759F70        6970+1   MOV CPT0MX , # 70H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0DA2    020E79        6971     	LJMP	COMM_EXIT
                      6972     
                      6973     	; Comm4Comm5 Non-damped
                      6974     COMM45_NONDAMP: 
0DA5    207D17        6975     JB FLAGS3 . 5 , COMM45_NONDAMP_REV 
                      6976     
0DA8    C2AF          6977     	CLR 	EA					; Disable all interrupts
0DAA    754205        6978     	MOV	COMM_PHASE, #5
0DAD    900103        6979     	MOV	DPTR, #PWM_AFET	
                      6980     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL APFET)
                               ENDIF
                      6983     	BNFET_OFF					; Turn off nfet
0DB0    C292          6983+1   CLR P1 . 2 
0DB2    306202        6984     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      6985     	ANFET_ON					; Yes - turn on nfet
0DB5    D294          6985+1   SETB P1 . 4 
                      6986     COMM45_NFET_DONE: 
0DB7    D2AF          6987     	SETB	EA
                      6988     	SET_COMP_PHASE_B 			; Set comparator phase
0DB9    759F70        6988+1   MOV CPT0MX , # 70H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0DBC    020E79        6989     	LJMP	COMM_EXIT
                      6990     
                      6991     	; Comm4Comm5 Non-damped reverse
                      6992     COMM45_NONDAMP_REV: 
0DBF    C2AF          6993     	CLR 	EA					; Disable all interrupts
0DC1    754205        6994     	MOV	COMM_PHASE, #5
0DC4    900117        6995     	MOV	DPTR, #PWM_CFET		;  (reverse)
                      6996     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL CPFET)
                               ENDIF
                      6999     	BNFET_OFF					; Turn off nfet
0DC7    C292          6999+1   CLR P1 . 2 
0DC9    3062EB        7000     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      7001     	CNFET_ON					; Yes - turn on nfet (reverse)
0DCC    D290          7001+1   SETB P1 . 0 
0DCE    D2AF          7002     	SETB	EA
                      7003     	SET_COMP_PHASE_B 			; Set comparator phase
0DD0    759F70        7003+1   MOV CPT0MX , # 70H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0DD3    020E79        7004     	LJMP	COMM_EXIT
                      7005     
                      7006     
                      7007     ; Comm phase 5 to comm phase 6
                      7008     COMM5COMM6: 	
                      7009     	SET_RPM_OUT
0DD6    207D16        7010     JB FLAGS3 . 5 , COMM56_REV 
                      7011     
0DD9    C2AF          7012     	CLR 	EA					; Disable all interrupts
0DDB    754206        7013     	MOV	COMM_PHASE, #6
                      7014     	CPFET_OFF 				; Turn off pfet
0DDE    C291          7014+1   CLR P1 . 1 
                      7015     	BPFET_ON					; Turn on pfet
0DE0    D293          7015+1   SETB P1 . 3 
0DE2    306202        7016     JNB FLAGS0 . 2 , COMM56_NFET_DONE 
                      7017     	ANFET_ON					; Pwm on - turn on nfet
0DE5    D294          7017+1   SETB P1 . 4 
                      7018     COMM56_NFET_DONE: 
0DE7    D2AF          7019     	SETB	EA
                      7020     	SET_COMP_PHASE_C 			; Set comparator phase
0DE9    759F00        7020+1   MOV CPT0MX , # 00H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0DEC    020E79        7021     	JMP	COMM_EXIT
                      7022     
                      7023     COMM56_REV: 
0DEF    C2AF          7024     	CLR 	EA					; Disable all interrupts
0DF1    754206        7025     	MOV	COMM_PHASE, #6
                      7026     	APFET_OFF 				; Turn off pfet (reverse)
0DF4    C295          7026+1   CLR P1 . 5 
                      7027     	BPFET_ON					; Turn on pfet
0DF6    D293          7027+1   SETB P1 . 3 
0DF8    306202        7028     JNB FLAGS0 . 2 , COMM56_NFET_DONE_REV 
                      7029     	CNFET_ON					; Pwm on - turn on nfet
0DFB    D290          7029+1   SETB P1 . 0 
                      7030     COMM56_NFET_DONE_REV: 
0DFD    D2AF          7031     	SETB	EA
                      7032     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0DFF    759F20        7032+1   MOV CPT0MX , # 20H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0E02    020E79        7033     	JMP	COMM_EXIT
                      7034     
                      7035     
                      7036     ; Comm phase 6 to comm phase 1
                      7037     COMM6COMM1: 	
                      7038     	CLEAR_RPM_OUT
0E05    307243        7039     JNB FLAGS2 . 2 , COMM61_NONDAMP 
                      7040     
                      7041     	; Comm6Comm1 Damped
0E08    207D20        7042     JB FLAGS3 . 5 , COMM61_DAMP_REV 
                      7043     
0E0B    C2AF          7044     	CLR 	EA					; Disable all interrupts
0E0D    754201        7045     	MOV	COMM_PHASE, #1
0E10    900143        7046     	MOV	DPTR, #PWM_CFET_DAMPED	
0E13    757B02        7047     	MOV	DAMPINGFET, #(1 SHL CPFET)
                      7048     	ANFET_OFF					; Turn off fets
0E16    C294          7048+1   CLR P1 . 4 
                      7049     	APFET_OFF						
0E18    C295          7049+1   CLR P1 . 5 
0E1A    306204        7050     JNB FLAGS0 . 2 , COMM61_NFET_OFF 
                      7051     	CNFET_ON					; Pwm on - turn on nfet
0E1D    D290          7051+1   SETB P1 . 0 
0E1F    C123          7052     	AJMP	COMM61_FETS_DONE
                      7053     COMM61_NFET_OFF: 
                      7054     	CPFET_ON					; Pwm off - switch damping fets	
0E21    D291          7054+1   SETB P1 . 1 
                      7055     COMM61_FETS_DONE: 
0E23    D2AF          7056     	SETB	EA
                      7057     	SET_COMP_PHASE_A 			; Set comparator phase
0E25    759F20        7057+1   MOV CPT0MX , # 20H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0E28    020E79        7058     	LJMP	COMM_EXIT
                      7059     
                      7060     	; Comm6Comm1 Damped reverse
                      7061     COMM61_DAMP_REV: 
0E2B    C2AF          7062     	CLR 	EA					; Disable all interrupts
0E2D    754201        7063     	MOV	COMM_PHASE, #1
0E30    900121        7064     	MOV	DPTR, #PWM_AFET_DAMPED	; (reverse)	
0E33    757B20        7065     	MOV	DAMPINGFET, #(1 SHL APFET)	; (reverse)
                      7066     	CNFET_OFF					; Turn off fets (reverse)
0E36    C290          7066+1   CLR P1 . 0 
                      7067     	CPFET_OFF						
0E38    C291          7067+1   CLR P1 . 1 
0E3A    306204        7068     JNB FLAGS0 . 2 , COMM61_NFET_OFF_REV 
                      7069     	ANFET_ON					; Pwm on - turn on nfet
0E3D    D294          7069+1   SETB P1 . 4 
0E3F    C143          7070     	AJMP	COMM61_FETS_DONE_REV
                      7071     COMM61_NFET_OFF_REV: 
                      7072     	APFET_ON					; Pwm off - switch damping fets (reverse)	
0E41    D295          7072+1   SETB P1 . 5 
                      7073     COMM61_FETS_DONE_REV: 
0E43    D2AF          7074     	SETB	EA
                      7075     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0E45    759F00        7075+1   MOV CPT0MX , # 00H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0E48    020E79        7076     	JMP	COMM_EXIT
                      7077     
                      7078     	; Comm6Comm1 Non-damped
                      7079     COMM61_NONDAMP: 
0E4B    207D17        7080     JB FLAGS3 . 5 , COMM61_NONDAMP_REV 
                      7081     
0E4E    C2AF          7082     	CLR 	EA					; Disable all interrupts
0E50    754201        7083     	MOV	COMM_PHASE, #1
0E53    900117        7084     	MOV	DPTR, #PWM_CFET	
                      7085     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL CPFET)
                               ENDIF
                      7088     	ANFET_OFF					; Turn off nfet
0E56    C294          7088+1   CLR P1 . 4 
0E58    306202        7089     JNB FLAGS0 . 2 , COMM61_NFET_DONE 
                      7090     	CNFET_ON					; Yes - turn on nfet
0E5B    D290          7090+1   SETB P1 . 0 
                      7091     COMM61_NFET_DONE: 
0E5D    D2AF          7092     	SETB	EA
                      7093     	SET_COMP_PHASE_A 			; Set comparator phase
0E5F    759F20        7093+1   MOV CPT0MX , # 20H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0E62    020E79        7094     	JMP	COMM_EXIT
                      7095     
                      7096     	; Comm6Comm1 Non-damped reverse
                      7097     COMM61_NONDAMP_REV: 
0E65    C2AF          7098     	CLR 	EA					; Disable all interrupts
0E67    754201        7099     	MOV	COMM_PHASE, #1
0E6A    900103        7100     	MOV	DPTR, #PWM_AFET		; (reverse)
                      7101     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL APFET)
                               ENDIF
                      7104     	CNFET_OFF					; Turn off nfet (reverse)
0E6D    C290          7104+1   CLR P1 . 0 
0E6F    306202        7105     JNB FLAGS0 . 2 , COMM61_NFET_DONE_REV 
                      7106     	ANFET_ON					; Yes - turn on nfet (reverse)
0E72    D294          7106+1   SETB P1 . 4 
                      7107     COMM61_NFET_DONE_REV: 
0E74    D2AF          7108     	SETB	EA
                      7109     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0E76    759F00        7109+1   MOV CPT0MX , # 00H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
                      7110     
                      7111     COMM_EXIT: 
0E79    C265          7112     CLR FLAGS0 . 5 
0E7B    22            7113     	RET
                      7114     
                      7115     
                      7116     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7117     ;
                      7118     ; Switch power off routine
                      7119     ;
                      7120     ; No assumptions
                      7121     ;
                      7122     ; Switches all fets off 
                      7123     ;
                      7124     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7125     SWITCH_POWER_OFF: 
0E7C    900101        7126     	MOV	DPTR, #PWM_NOFET	; Set DPTR register to pwm_nofet		
0E7F    757B00        7127     	MOV	DAMPINGFET, #0
                      7128     	ALL_NFETS_OFF			; Turn off all nfets
0E82    C294          7128+1   CLR P1 . 4 
0E84    C292          7128+1   CLR P1 . 2 
0E86    C290          7128+1   CLR P1 . 0 
                      7129     	ALL_PFETS_OFF			; Turn off all pfets
0E88    C295          7129+1   CLR P1 . 5 
0E8A    C293          7129+1   CLR P1 . 3 
0E8C    C291          7129+1   CLR P1 . 1 
0E8E    C262          7130     CLR FLAGS0 . 2 
0E90    22            7131     	RET			
                      7132     
                      7133     
                      7134     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7135     ;
                      7136     ; Set default parameters
                      7137     ;
                      7138     ; No assumptions
                      7139     ;
                      7140     ; Sets default programming parameters
                      7141     ;
                      7142     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7143     SET_DEFAULT_PARAMETERS: 
                      7144     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_SPOOLUP_TIME
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Pwm dither
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BRAKE_ON_STOP
                               ENDIF
                      7217     IF MODE == 1	; Tail
0E91    7880          7218     MOV R0 , # PGM_GOV_P_GAIN 
0E93    76FF          7219     MOV @ R0 , # 0FFH 
0E95    08            7220     INC R0 
0E96    76FF          7221     MOV @ R0 , # 0FFH 
0E98    08            7222     INC R0 
0E99    76FF          7223     MOV @ R0 , # 0FFH 
0E9B    08            7224     INC R0 
0E9C    76FF          7225     MOV @ R0 , # 0FFH 
0E9E    08            7226     INC R0 
0E9F    7603          7227     MOV @ R0 , # 3 
0EA1    08            7228     INC R0 
0EA2    7604          7229     MOV @ R0 , # 4 
0EA4    08            7230     INC R0 
0EA5    760A          7231     MOV @ R0 , # 10 
0EA7    08            7232     INC R0 
0EA8    7601          7233     MOV @ R0 , # 1 
0EAA    08            7234     INC R0 
0EAB    7601          7235     MOV @ R0 , # 1 
0EAD    08            7236     INC R0 
0EAE    7601          7237     MOV @ R0 , # 1 
                      7238     
0EB0    788C          7239     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
0EB2    7601          7240     MOV @ R0 , # 1 
0EB4    08            7241     INC R0 
0EB5    76FF          7242     MOV @ R0 , # 0FFH 
0EB7    08            7243     INC R0 
0EB8    76FF          7244     MOV @ R0 , # 0FFH 
0EBA    08            7245     INC R0 
0EBB    76FF          7246     MOV @ R0 , # 0FFH 
0EBD    08            7247     INC R0 
0EBE    76FF          7248     MOV @ R0 , # 0FFH 
0EC0    08            7249     INC R0 
0EC1    76FF          7250     MOV @ R0 , # 0FFH 
0EC3    08            7251     INC R0 
0EC4    7603          7252     MOV @ R0 , # 3 
0EC6    08            7253     INC R0 
0EC7    76FF          7254     MOV @ R0 , # 0FFH 
0EC9    08            7255     INC R0 
0ECA    76FF          7256     MOV @ R0 , # 0FFH 
0ECC    08            7257     INC R0 
0ECD    76FF          7258     MOV @ R0 , # 0FFH 
0ECF    08            7259     INC R0 
0ED0    760A          7260     MOV @ R0 , # 10 
0ED2    08            7261     INC R0 
0ED3    76F0          7262     MOV @ R0 , # 240 
0ED5    08            7263     INC R0 
0ED6    76FA          7264     MOV @ R0 , # 250 
0ED8    08            7265     INC R0 
0ED9    76FA          7266     MOV @ R0 , # 250 
0EDB    08            7267     INC R0 
0EDC    7604          7268     MOV @ R0 , # 4 
0EDE    08            7269     INC R0 
0EDF    76FF          7270     MOV @ R0 , # 0FFH 
0EE1    08            7271     INC R0 
0EE2    7601          7272     MOV @ R0 , # 1 
0EE4    08            7273     INC R0 
0EE5    7600          7274     MOV @ R0 , # 0 
0EE7    08            7275     INC R0 
0EE8    767D          7276     MOV @ R0 , # 125 
0EEA    08            7277     INC R0 
0EEB    76FF          7278     MOV @ R0 , # 0FFH 
0EED    08            7279     INC R0 
0EEE    7601          7280     MOV @ R0 , # 1 
0EF0    08            7281     INC R0 
0EF1    7601          7282     MOV @ R0 , # 1 
0EF3    08            7283     INC R0 
0EF4    7600          7284     MOV @ R0 , # 0 
0EF6    08            7285     INC R0 
0EF7    7603          7286     MOV @ R0 , # 3 
0EF9    08            7287     INC R0 
0EFA    7601          7288     MOV @ R0 , # 1 
                      7289     ENDIF
                      7290     IF MODE == 2	; Multi
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_PWM_DITHER
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BRAKE_ON_STOP
                               ENDIF
0EFC    22            7363     	RET
                      7364     
                      7365     
                      7366     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7367     ;
                      7368     ; Decode parameters
                      7369     ;
                      7370     ; No assumptions
                      7371     ;
                      7372     ; Decodes programming parameters
                      7373     ;
                      7374     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7375     DECODE_PARAMETERS: 
                      7376     	; Load programmed pwm frequency
0EFD    7887          7377     MOV R0 , # PGM_PWM_FREQ 
0EFF    E6            7378     MOV A , @ R0 
0F00    FF            7379     MOV R7 , A 
0F01    C272          7380     CLR FLAGS2 . 2 
                      7381     IF DAMPED_MODE_ENABLE == 1
                               	CJNE	TEMP8, #3, ($+5)
                               	SETB	FLAGS2.PGM_PWMOFF_DAMPED
                               ENDIF
                      7385     	; Load programmed direction
0F03    7888          7386     MOV R0 , # PGM_DIRECTION 
                      7387     IF MODE >= 1	; Tail or multi
0F05    E6            7388     MOV A , @ R0 
0F06    C3            7389     	CLR	C
0F07    9403          7390     	SUBB	A, #3
0F09    6008          7391     	JZ	DECODE_PARAMS_DIR_SET
                      7392     ENDIF
                      7393     
0F0B    C27D          7394     CLR FLAGS3 . 5 
0F0D    E6            7395     MOV A , @ R0 
0F0E    30E102        7396     	JNB	ACC.1, ($+5)
0F11    D27D          7397     SETB FLAGS3 . 5 
                      7398     DECODE_PARAMS_DIR_SET: 
0F13    C27E          7399     CLR FLAGS3 . 6 
0F15    7889          7400     MOV R0 , # PGM_INPUT_POL 
0F17    E6            7401     MOV A , @ R0 
0F18    30E102        7402     	JNB	ACC.1, ($+5)
0F1B    D27E          7403     SETB FLAGS3 . 6 
0F1D    C3            7404     	CLR	C
0F1E    EF            7405     MOV A , R7 
0F1F    9402          7406     	SUBB	A, #2
0F21    6008          7407     	JZ	DECODE_PWM_FREQ_LOW
                      7408     
0F23    758E01        7409     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
0F26    D273          7410     SETB FLAGS2 . 3 
0F28    020F30        7411     	JMP	DECODE_PWM_FREQ_END
                      7412     
                      7413     DECODE_PWM_FREQ_LOW: 
0F2B    758E00        7414     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
0F2E    C273          7415     CLR FLAGS2 . 3 
                      7416     
                      7417     DECODE_PWM_FREQ_END: 
0F30    22            7418     	RET
                      7419     
                      7420     
                      7421     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7422     ;
                      7423     ; Decode settings
                      7424     ;
                      7425     ; No assumptions
                      7426     ;
                      7427     ; Decodes various settings
                      7428     ;
                      7429     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7430     DECODE_SETTINGS: 
                      7431     	; Decode governor gains
0F31    7880          7432     MOV R0 , # PGM_GOV_P_GAIN 
0F33    E6            7433     MOV A , @ R0 
0F34    14            7434     	DEC	A	
0F35    900080        7435     	MOV	DPTR, #GOV_GAIN_TABLE
0F38    93            7436     	MOVC A, @A+DPTR	
0F39    78A5          7437     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0F3B    F6            7438     MOV @ R0 , A 
0F3C    7881          7439     MOV R0 , # PGM_GOV_I_GAIN 
0F3E    E6            7440     MOV A , @ R0 
0F3F    14            7441     	DEC	A	
0F40    900080        7442     	MOV	DPTR, #GOV_GAIN_TABLE
0F43    93            7443     	MOVC A, @A+DPTR	
0F44    78A6          7444     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0F46    F6            7445     MOV @ R0 , A 
                      7446     	; Decode startup power
0F47    7886          7447     MOV R0 , # PGM_STARTUP_PWR 
0F49    E6            7448     MOV A , @ R0 
0F4A    14            7449     	DEC	A	
0F4B    90008D        7450     	MOV	DPTR, #STARTUP_POWER_TABLE
0F4E    93            7451     	MOVC A, @A+DPTR	
0F4F    78A7          7452     MOV R0 , # PGM_STARTUP_PWR_DECODED 
0F51    F6            7453     MOV @ R0 , A 
                      7454     IF MODE == 0	; Main
                               	; Decode spoolup time
                               	MOV	TEMP1, #PGM_MAIN_SPOOLUP_TIME		
                               	MOV	A, @TEMP1
                               	MOV	TEMP1, A		; Store
                               	JNZ	DECODE_MAIN_SPOOLUP_NONZERO	; If not zero - branch
                               	
                               	MOV	MAIN_SPOOLUP_TIME_3X, #0	
                               	AJMP	DECODE_MAIN_SPOOLUP_DONE
                               
                               DECODE_MAIN_SPOOLUP_NONZERO:
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, #17		; Limit to 17 max
                               	JC	($+4)
                               
                               	MOV	TEMP1, #17
                               
                               	MOV	A, TEMP1
                               	ADD	A, TEMP1
                               	ADD	A, TEMP1		; Now 3x
                               	MOV	MAIN_SPOOLUP_TIME_3X, A
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, TEMP1		; Now 10x
                               	MOV	MAIN_SPOOLUP_TIME_10X, A
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, TEMP1		
                               	ADD	A, TEMP1		; Now 15x
                               	MOV	MAIN_SPOOLUP_TIME_15X, A
                               DECODE_MAIN_SPOOLUP_DONE:
                               ENDIF
                      7486     	; Decode low rpm power slope
0F52    7886          7487     MOV R0 , # PGM_STARTUP_PWR 
0F54    E6            7488     MOV A , @ R0 
0F55    F539          7489     	MOV	LOW_RPM_PWR_SLOPE, A
0F57    C3            7490     	CLR	C	
0F58    9402          7491     	SUBB	A, #2
0F5A    5003          7492     	JNC	($+5)
0F5C    753902        7493     	MOV	LOW_RPM_PWR_SLOPE, #2
                      7494     	; Decode demag compensation
0F5F    789C          7495     MOV R0 , # PGM_DEMAG_COMP 
0F61    E6            7496     MOV A , @ R0 
0F62    7538FF        7497     	MOV	DEMAG_PWR_OFF_THRESH, #255	; Set default
                      7498     
0F65    B40203        7499     	CJNE	A, #2, DECODE_DEMAG_HIGH
                      7500     
0F68    7538A0        7501     	MOV	DEMAG_PWR_OFF_THRESH, #160	; Settings for demag comp low
                      7502     
                      7503     DECODE_DEMAG_HIGH: 
0F6B    B40303        7504     	CJNE	A, #3, DECODE_DEMAG_DONE
                      7505     
0F6E    753882        7506     	MOV	DEMAG_PWR_OFF_THRESH, #130	; Settings for demag comp high
                      7507     
                      7508     DECODE_DEMAG_DONE: 
                      7509     	; Decode pwm dither
0F71    78A3          7510     MOV R0 , # PGM_PWM_DITHER 
0F73    E6            7511     MOV A , @ R0 
0F74    14            7512     	DEC	A	
0F75    90009A        7513     	MOV	DPTR, #PWM_DITHER_TABLE
0F78    93            7514     	MOVC A, @A+DPTR	
0F79    F566          7515     	MOV	PWM_DITHER_DECODED, A
0F7B    D17C          7516     	CALL	SWITCH_POWER_OFF			; Reset DPTR
0F7D    22            7517     	RET
                      7518     
                      7519     
                      7520     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7521     ;
                      7522     ; Set BEC voltage
                      7523     ;
                      7524     ; No assumptions
                      7525     ;
                      7526     ; Sets the BEC output voltage low or high
                      7527     ;
                      7528     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7529     SET_BEC_VOLTAGE: 
                      7530     	; Set bec voltage
                      7531     IF HIGH_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
                      7541     IF HIGH_BEC_VOLTAGE == 2
                               	SET_BEC_0				; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	CJNE	A, #1, SET_BEC_VOLTAGE_2	
                               
                               	SET_BEC_1				; Set to level 1
                               
                               SET_BEC_VOLTAGE_2:
                               	CJNE	A, #2, SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_2				; Set to level 2
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
0F7E    22            7556     	RET
                      7557     
                      7558     
                      7559     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7560     ;
                      7561     ; Find throttle gain
                      7562     ;
                      7563     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      7564     ;
                      7565     ; Finds throttle gain from throttle calibration values
                      7566     ;
                      7567     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7568     FIND_THROTTLE_GAIN: 
                      7569     	; Load programmed minimum and maximum throttle
0F7F    7896          7570     MOV R0 , # PGM_PPM_MIN_THROTTLE 
0F81    E6            7571     MOV A , @ R0 
0F82    FA            7572     MOV R2 , A 
0F83    7897          7573     MOV R0 , # PGM_PPM_MAX_THROTTLE 
0F85    E6            7574     MOV A , @ R0 
0F86    FB            7575     MOV R3 , A 
0F87    7888          7576     MOV R0 , # PGM_DIRECTION 
0F89    E6            7577     MOV A , @ R0 
0F8A    B40305        7578     	CJNE	A, #3, FIND_THROTTLE_GAIN_CHECK_FULL
                      7579     
0F8D    C3            7580     	CLR	C
0F8E    EB            7581     MOV A , R3 
0F8F    940E          7582     	SUBB	A, #14				; Compensate for higher deadband in bidirectional
0F91    FB            7583     MOV R3 , A 
                      7584     
                      7585     FIND_THROTTLE_GAIN_CHECK_FULL: 
                      7586     	; Check if full range is chosen
0F92    307F04        7587     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      7588     
0F95    7A00          7589     MOV R2 , # 0 
0F97    7BFF          7590     MOV R3 , # 255 
                      7591     
                      7592     FIND_THROTTLE_GAIN_CALCULATE: 
                      7593     	; Calculate difference
0F99    C3            7594     	CLR	C
0F9A    EB            7595     MOV A , R3 
0F9B    9A            7596     SUBB A , R2 
0F9C    FC            7597     MOV R4 , A 
                      7598     	; Check that difference is minimum 130
0F9D    C3            7599     	CLR	C
0F9E    9482          7600     	SUBB	A, #130
0FA0    5002          7601     	JNC	($+4)
                      7602     
0FA2    7C82          7603     MOV R4 , # 130 
                      7604     
                      7605     	; Find gain
0FA4    757200        7606     	MOV	PPM_THROTTLE_GAIN, #0
                      7607     TEST_THROTTLE_GAIN: 
0FA7    0572          7608     	INC	PPM_THROTTLE_GAIN
0FA9    EC            7609     MOV A , R4 
0FAA    8572F0        7610     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
0FAD    A4            7611     	MUL	AB
0FAE    C3            7612     	CLR	C
0FAF    E5F0          7613     	MOV	A, B
0FB1    947D          7614     	SUBB	A, #125
0FB3    40F2          7615     	JC	TEST_THROTTLE_GAIN
0FB5    22            7616     	RET
                      7617     
                      7618     
                      7619     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7620     ;
                      7621     ; Average throttle 
                      7622     ;
                      7623     ; Outputs result in Temp7
                      7624     ;
                      7625     ; Averages throttle calibration readings
                      7626     ;
                      7627     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7628     AVERAGE_THROTTLE: 
0FB6    D27F          7629     SETB FLAGS3 . 7 
0FB8    F17F          7630     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
0FBA    120581        7631     	CALL WAIT30MS		
0FBD    120581        7632     	CALL WAIT30MS		
0FC0    7A00          7633     MOV R2 , # 0 
0FC2    7B00          7634     MOV R3 , # 0 
0FC4    7C10          7635     MOV R4 , # 16 
                      7636     AVERAGE_THROTTLE_MEAS: 
0FC6    120577        7637     	CALL	WAIT3MS			; Wait for new RC pulse value
0FC9    E55C          7638     	MOV	A, NEW_RCP		; Get new RC pulse value
0FCB    2A            7639     ADD A , R2 
0FCC    FA            7640     MOV R2 , A 
0FCD    7400          7641     	MOV	A, #0
0FCF    3B            7642     ADDC A , R3 
0FD0    FB            7643     MOV R3 , A 
0FD1    DCF3          7644     DJNZ R4 , AVERAGE_THROTTLE_MEAS 
                      7645     
0FD3    7C04          7646     MOV R4 , # 4 
                      7647     AVERAGE_THROTTLE_DIV: 
0FD5    C3            7648     	CLR	C
0FD6    EB            7649     MOV A , R3 
0FD7    13            7650     	RRC	A      
0FD8    FB            7651     MOV R3 , A 
0FD9    EA            7652     MOV A , R2 
0FDA    13            7653     	RRC	A      
0FDB    FA            7654     MOV R2 , A 
0FDC    DCF7          7655     DJNZ R4 , AVERAGE_THROTTLE_DIV 
                      7656     
0FDE    FE            7657     MOV R6 , A 
0FDF    C27F          7658     CLR FLAGS3 . 7 
0FE1    F17F          7659     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
0FE3    22            7660     	RET
                      7661     
                      7662     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7663     ;		Music Routines
                      7664     ;
                      7665     ;
                      7666     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7667     
                      7668     MUSIC_F1: 
0FE4    7ADE          7669     MOV R2 , # 222 
                      7670     MUSIC_F1_BEEP: 
                      7671     	APFET_ON
0FE6    D295          7671+1   SETB P1 . 5 
                      7672     	CNFET_ON
0FE8    D290          7672+1   SETB P1 . 0 
0FEA    744B          7673     	MOV	A, #75		
0FEC    D5E0FD        7674     	DJNZ	ACC, $
                      7675     	CNFET_OFF
0FEF    C290          7675+1   CLR P1 . 0 
                      7676     	APFET_OFF
0FF1    C295          7676+1   CLR P1 . 5 
                      7677     
                      7678     ;X*1ms to wait
0FF3    7902          7679     MOV R1 , # 2 
                      7680     WAIT_MS_1_O_M1: 	
0FF5    7817          7681     MOV R0 , # 23 
                      7682     WAIT_MS_1_M_M1: 	
0FF7    E4            7683     	CLR	A
0FF8    D5E0FD        7684      	DJNZ	ACC, $	
0FFB    D8FA          7685     DJNZ R0 , WAIT_MS_1_M_M1 
0FFD    D9F6          7686     DJNZ R1 , WAIT_MS_1_O_M1 
                      7687     
                      7688     ;X*5us to wait
0FFF    796E          7689     MOV R1 , # 110 
                      7690     WAIT_US_100_M1: 
1001    741E          7691     	MOV	A, #30		
1003    D5E0FD        7692     	DJNZ	ACC, $
1006    D9F9          7693     DJNZ R1 , WAIT_US_100_M1 
                      7694     
1008    DADC          7695     DJNZ R2 , MUSIC_F1_BEEP 
100A    22            7696     	RET
                      7697     
                      7698     
                      7699     MUSIC_F2: 
100B    7A84          7700     MOV R2 , # 132 
                      7701     MUSIC_F2_BEEP: 
                      7702     	APFET_ON
100D    D295          7702+1   SETB P1 . 5 
                      7703     	CNFET_ON
100F    D290          7703+1   SETB P1 . 0 
1011    744B          7704     	MOV	A, #75
1013    D5E0FD        7705     	DJNZ	ACC, $
                      7706     	CNFET_OFF
1016    C290          7706+1   CLR P1 . 0 
                      7707     	APFET_OFF
1018    C295          7707+1   CLR P1 . 5 
                      7708     
                      7709     ;X*1ms to wait
101A    7903          7710     MOV R1 , # 3 
                      7711     WAIT_MS_1_O_M2: 	
101C    7817          7712     MOV R0 , # 23 
                      7713     WAIT_MS_1_M_M2: 
101E    E4            7714     	CLR	A
101F    D5E0FD        7715      	DJNZ	ACC, $
1022    D8FA          7716     DJNZ R0 , WAIT_MS_1_M_M2 
1024    D9F6          7717     DJNZ R1 , WAIT_MS_1_O_M2 
                      7718     
                      7719     ;X*5us to wait
1026    792B          7720     MOV R1 , # 43 
                      7721     WAIT_US_100_M2: 
1028    741E          7722     	MOV	A, #30		
102A    D5E0FD        7723     	DJNZ	ACC, $
102D    D9F9          7724     DJNZ R1 , WAIT_US_100_M2 
102F    DADC          7725     DJNZ R2 , MUSIC_F2_BEEP 
1031    22            7726     	RET
                      7727     
                      7728     
                      7729     MUSIC_F3: 
1032    7A84          7730     MOV R2 , # 132 
                      7731     MUSIC_F3_BEEP: 
                      7732     	APFET_ON
1034    D295          7732+1   SETB P1 . 5 
                      7733     	CNFET_ON
1036    D290          7733+1   SETB P1 . 0 
1038    744B          7734     	MOV	A, #75	
103A    D5E0FD        7735     	DJNZ	ACC, $
                      7736     	CNFET_OFF
103D    C290          7736+1   CLR P1 . 0 
                      7737     	APFET_OFF
103F    C295          7737+1   CLR P1 . 5 
                      7738     
                      7739     ;X*1ms to wait
1041    7902          7740     MOV R1 , # 2 
                      7741     WAIT_MS_1_O_M3: 	
1043    7817          7742     MOV R0 , # 23 
                      7743     WAIT_MS_1_M_M3: 	
1045    E4            7744     	CLR	A
1046    D5E0FD        7745      	DJNZ	ACC, $	
1049    D8FA          7746     DJNZ R0 , WAIT_MS_1_M_M3 
104B    D9F6          7747     DJNZ R1 , WAIT_MS_1_O_M3 
                      7748     
104D    791D          7749     MOV R1 , # 29 
                      7750     WAIT_US_100_M3: 
104F    741E          7751     	MOV	A, #30		
1051    D5E0FD        7752     	DJNZ	ACC, $
1054    D9F9          7753     DJNZ R1 , WAIT_US_100_M3 
1056    DADC          7754     DJNZ R2 , MUSIC_F3_BEEP 
1058    22            7755     	RET
                      7756     
                      7757     
                      7758     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7759     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7760     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7761     ;
                      7762     ; Main program start
                      7763     ;
                      7764     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7765     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7766     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7767     PGM_START: 
                      7768     	; Initialize flash keys to invalid values
1059    757C00        7769     	MOV	FLASH_KEY_1, #0
105C    757D00        7770     	MOV	FLASH_KEY_2, #0
                      7771     	; Check flash lock byte
105F    E5EF          7772     	MOV	A, RSTSRC			
1061    20E603        7773     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      7774     
1064    752000        7775     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      7776     
1067    0520          7777     	INC	BIT_ACCESS
1069    903FFF        7778     MOV DPTR , # 16383 
106C    E520          7779     	MOV	A, BIT_ACCESS
106E    14            7780     	DEC	A
106F    6006          7781     	JZ	LOCK_BYTE_TEST
                      7782     
1071    901DFF        7783     MOV DPTR , # 7679 
1074    14            7784     	DEC	A
1075    6000          7785     	JZ	LOCK_BYTE_TEST
                      7786     
                      7787     LOCK_BYTE_TEST: 
1077    93            7788     	MOVC A, @A+DPTR		; Read lock byte
1078    04            7789     	INC	A				
1079    6003          7790     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      7791     
                      7792     IF ONE_S_CAPABLE == 0		
107B    75EF16        7793     	MOV	RSTSRC, #16H			; Generate hardware reset and set missing clock and VDD monitor
                      7794     ELSE
                               	MOV	RSTSRC, #14H			; Generate hardware reset and disable VDD monitor
                               ENDIF
                      7797     
                      7798     LOCK_BYTE_OK: 
                      7799     	; Disable the WDT.
                      7800     IF SIGNATURE_001 == 0F3H		
107E    53D9BF        7801     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
1081    75D908        7802     	MOV	PCA0MD, #0X08     ; PCA0MD divider to Sysclock instead of sysclock / 12 - Multishot
                      7803     ENDIF
                      7804     IF SIGNATURE_001 == 0F8H		
                               	MOV	WDTCN, #0DEH		; Disable watchdog
                               	MOV	WDTCN, #0ADH		
                               ENDIF
                      7808     	; Initialize stack
1084    7581C0        7809     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      7810     	; Initialize VDD monitor
1087    43FF80        7811     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
108A    120572        7812     	CALL	WAIT1MS			; Wait at least 100us
                      7813     IF ONE_S_CAPABLE == 0		
108D    75EF06        7814     	MOV 	RSTSRC, #06H   	; Set missing clock and VDD monitor as a reset source if not 1S capable
                      7815     ELSE
                               	MOV 	RSTSRC, #04H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it
                               ENDIF
                      7818     	; Set clock frequency
                      7819     IF SIGNATURE_001 == 0F3H		
1090    43B203        7820     	ORL	OSCICN, #03H		; Set clock divider to 1 (not supported on 'f850)
                      7821     ENDIF
                      7822     IF SIGNATURE_001 == 0F8H		
                               	MOV	CLKSEL, #00H		; Set clock divider to 1 (not supported on 'f3xx)
                               ENDIF
1093    E5B3          7825     	MOV	A, OSCICL				
1095    2402          7826     	ADD	A, #02H			; 24.5MHz to 24MHz (~0.5-1% per step)
1097    20E70D        7827     	JB	ACC.7, RESET_CAL_DONE	; Is carry (7bit) set? - branch
                      7828     
109A    F521          7829     	MOV	BIT_ACCESS_INT, A
                      7830     IF SIGNATURE_002 <> 010H		
109C    E5E3          7831     	MOV	A, OSCLCN
                      7832     ELSE
                               	MOV	A, OSCXCN
                               ENDIF
109E    20E006        7835     	JB	ACC.0, RESET_CAL_DONE	; Set if cal aleady done
                      7836     
10A1    8521B3        7837     	MOV	OSCICL, BIT_ACCESS_INT
                      7838     IF SIGNATURE_002 <> 010H		
10A4    43E301        7839     	ORL	OSCLCN, #01H			; Tag that cal is done
                      7840     ELSE
                               	ORL	OSCXCN, #01H			; Tag that cal is done
                               ENDIF
                      7843     
                      7844     RESET_CAL_DONE: 
                      7845     	; Switch power off
10A7    120E7C        7846     	CALL	SWITCH_POWER_OFF
                      7847     	; Ports initialization
10AA    7580FF        7848     MOV P0 , # 255 
10AD    75A400        7849     MOV P0MDOUT , # 0 
10B0    75F1DC        7850     MOV P0MDIN , # -36 
10B3    75D4EF        7851     MOV P0SKIP , # 239 
10B6    7590C0        7852     MOV P1 , # 192 
10B9    75A53F        7853     MOV P1MDOUT , # 63 
10BC    75F23F        7854     MOV P1MDIN , # 63 
10BF    75D5C0        7855     MOV P1SKIP , # 192 
                      7856     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
10C2    75A601        7859     MOV P2MDOUT , # 1 
                      7860     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      7867     	; Initialize the XBAR and related functionality
                      7868     	INITIALIZE_XBAR
10C5    75E241        7868+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      7869     	; Switch power off again, after initializing ports
10C8    120E7C        7870     	CALL	SWITCH_POWER_OFF
                      7871     	; Clear RAM
10CB    E4            7872     	CLR	A				; Clear accumulator
10CC    F8            7873     MOV R0 , A 
                      7874     CLEAR_RAM: 	
10CD    F6            7875     MOV @ R0 , A 
10CE    D8FD          7876     DJNZ R0 , CLEAR_RAM 
                      7877     	; Initialize LFSR
10D0    756801        7878     	MOV	RANDOM, #1
                      7879     	; Set default programmed parameters
10D3    120E91        7880     	CALL	SET_DEFAULT_PARAMETERS
                      7881     	; Read all programmed parameters
10D6    1215D6        7882     	CALL READ_ALL_EEPROM_PARAMETERS
                      7883     	; Set beep strength
10D9    7898          7884     MOV R0 , # PGM_BEEP_STRENGTH 
10DB    8673          7885     MOV BEEP_STRENGTH , @ R0 
                      7886     	; Set initial arm variable
10DD    753001        7887     	MOV	INITIAL_ARM, #1
                      7888     	; Initializing beep
10E0    C2AF          7889     	CLR	EA				; Disable interrupts explicitly
                      7890     
10E2    12058B        7891       CALL WAIT200MS
10E5    120FE4        7892     	CALL MUSIC_F1
10E8    120586        7893     	CALL WAIT100MS
10EB    120FE4        7894     	CALL MUSIC_F1
10EE    120586        7895     	CALL WAIT100MS
10F1    120FE4        7896     	CALL MUSIC_F1
10F4    120586        7897     	CALL WAIT100MS
10F7    110B          7898     	CALL MUSIC_F2
10F9    1132          7899     	CALL MUSIC_F3
10FB    120FE4        7900     	CALL MUSIC_F1
10FE    120586        7901     	CALL WAIT100MS
1101    110B          7902     	CALL MUSIC_F2
1103    1132          7903     	CALL MUSIC_F3
1105    120FE4        7904     	CALL MUSIC_F1
1108    120FE4        7905     	CALL MUSIC_F1
                      7906     
                      7907     IF MODE <= 1	; Main or tail
                      7908     	; Wait for receiver to initialize
110B    1216F3        7909     	CALL	WAIT1S
110E    12058B        7910     	CALL	WAIT200MS
1111    12058B        7911     	CALL	WAIT200MS
1114    120586        7912     	CALL	WAIT100MS
                      7913     ENDIF
                      7914     
                      7915     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7916     ;
                      7917     ; No signal entry point
                      7918     ;
                      7919     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7920     INIT_NO_SIGNAL: 
                      7921     	; Disable interrupts explicitly
1117    C2AF          7922     	CLR	EA				
                      7923     	; Initialize flash keys to invalid values
1119    757C00        7924     	MOV	FLASH_KEY_1, #0
111C    757D00        7925     	MOV	FLASH_KEY_2, #0
                      7926     	; Check if input signal is high for more than 15ms
111F    78FA          7927     MOV R0 , # 250 
                      7928     INPUT_HIGH_CHECK_1: 
1121    79FA          7929     MOV R1 , # 250 
                      7930     INPUT_HIGH_CHECK_2: 
1123    308407        7931     JNB 128 . 4 , BOOTLOADER_DONE 
1126    D9FB          7932     DJNZ R1 , INPUT_HIGH_CHECK_2 
1128    D8F7          7933     DJNZ R0 , INPUT_HIGH_CHECK_1 
                      7934     
112A    021C00        7935     	LJMP	1C00H			; Jump to bootloader
                      7936     
                      7937     BOOTLOADER_DONE: 
                      7938     	; Decode parameters
112D    120EFD        7939     	CALL	DECODE_PARAMETERS
                      7940     	; Decode settings
1130    120F31        7941     	CALL	DECODE_SETTINGS
                      7942     	; Set BEC voltage
1133    120F7E        7943     	CALL	SET_BEC_VOLTAGE
                      7944     	; Find throttle gain from stored min and max settings
1136    120F7F        7945     	CALL	FIND_THROTTLE_GAIN
                      7946     	; Set beep strength
1139    7898          7947     MOV R0 , # PGM_BEEP_STRENGTH 
113B    8673          7948     MOV BEEP_STRENGTH , @ R0 
                      7949     	; Switch power off
113D    120E7C        7950     	CALL	SWITCH_POWER_OFF
                      7951     	; Set clock frequency
                      7952     IF MCU_48MHZ == 1
                               	SET_MCU_CLK_24MHZ
                               ENDIF
                      7955     	; Timer control
1140    758810        7956     	MOV	TCON, #10H		; Timer0 enabled
                      7957     	; Timer mode
1143    758902        7958     	MOV	TMOD, #02H		; Timer0 as 8bit
                      7959     	; Timer2: clk/12 for 128us and 32ms interrupts
1146    75C824        7960     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      7961     	; Timer3: clk/12 for commutation timing
1149    759104        7962     	MOV	TMR3CN, #04H		; Timer3 enabled
                      7963     	; PCA
114C    75D840        7964     	MOV	PCA0CN, #40H		; PCA enabled
                      7965     	; Enable interrupts
114F    75A822        7966     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
1152    75B802        7967     	MOV	IP, #02H			; High priority to timer0 interrupts
1155    75E690        7968     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      7969     	; Initialize comparator
1158    759B80        7970     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
115B    759D00        7971     	MOV	CPT0MD, #00H		; Comparator response time 100ns
                      7972     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #00H		; Comparator response time 100ns
                               ENDIF
                      7976     	; Initialize ADC
                      7977     	INITIALIZE_ADC			; Initialize ADC operation
115E    75D10E        7977+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
1161    75BC58        7977+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
1164    75BB0E        7977+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
1167    75BA11        7977+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
116A    75E880        7977+1   MOV ADC0CN , # 80H  ; ADC ENABLED
116D    120572        7978     	CALL	WAIT1MS
1170    D2AF          7979     	SETB	EA				; Enable all interrupts
                      7980     	; Measure number of lipo cells
1172    12082A        7981     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      7982     	; Reset stall count
1175    753600        7983     	MOV	STALL_CNT, #0
                      7984     	; Initialize RC pulse
                      7985     	RCP_INT_FIRST 					; Enable interrupt and set to first edge
1178    53DACF        7985+1   ANL PCA0CPM0 , # 0CFH 
117B    207E03        7985+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
117E    43DA20        7985+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
1181    307E03        7985+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
1184    43DA10        7985+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      7986     	RCP_INT_ENABLE		 			; Enable interrupt
1187    43DA01        7986+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      7987     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
118A    C2D8          7987+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
118C    C271          7988     CLR FLAGS2 . 1 
118E    12058B        7989     	CALL WAIT200MS
                      7990     
                      7991     	; Measure PWM frequency
                      7992     MEASURE_PWM_FREQ_INIT: 	
1191    D261          7993     SETB FLAGS0 . 1 
1193    7B03          7994     MOV R3 , # 3 
                      7995     MEASURE_PWM_FREQ_START: 	
1195    7A0C          7996     MOV R2 , # 12 
                      7997     MEASURE_PWM_FREQ_LOOP: 	
                      7998     	; Check if period diff was accepted
1197    E55B          7999     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
1199    7007          8000     	JNZ	MEASURE_PWM_FREQ_WAIT
                      8001     
119B    7A0C          8002     MOV R2 , # 12 
119D    DB03          8003     DJNZ R3 , ( $+5 ) 
119F    021117        8004     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      8005     
                      8006     MEASURE_PWM_FREQ_WAIT: 
11A2    120581        8007     	CALL	WAIT30MS						; Wait 30ms for new pulse
11A5    207003        8008     JB FLAGS2 . 0 , ( $+6 ) 
11A8    021117        8009     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      8010     
11AB    C270          8011     CLR FLAGS2 . 0 
11AD    E55C          8012     	MOV	A, NEW_RCP					; Load value
11AF    C3            8013     	CLR	C
11B0    9402          8014     SUBB A , # 2 
11B2    40E1          8015     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      8016     
11B4    E52F          8017     	MOV	A, FLAGS3						; Check pwm frequency flags
11B6    541F          8018     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
11B8    855E5D        8019     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
11BB    F55E          8020     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
11BD    B55DD5        8021     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      8022     
11C0    DAD5          8023     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      8024     
                      8025     	; Clear measure pwm frequency flag
11C2    C261          8026     CLR FLAGS0 . 1 
                      8027     	; Set up RC pulse interrupts after pwm frequency measurement
                      8028     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
11C4    53DACF        8028+1   ANL PCA0CPM0 , # 0CFH 
11C7    207E03        8028+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
11CA    43DA20        8028+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
11CD    307E03        8028+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
11D0    43DA10        8028+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      8029     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
11D3    C2D8          8029+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
11D5    C271          8030     CLR FLAGS2 . 1 
11D7    78A2          8031     MOV R0 , # PGM_ENABLE_PWM_INPUT 
11D9    E6            8032     MOV A , @ R0 
11DA    7008          8033     	JNZ	TEST_FOR_ONESHOT				; If it is - proceed
                      8034     
11DC    D274          8035     SETB FLAGS2 . 4 
11DE    E52F          8036     	MOV	A, FLAGS3						; Clear pwm frequency flags
11E0    54E0          8037     	ANL	A, #NOT((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
11E2    F52F          8038     	MOV	FLAGS3, A
                      8039     
                      8040     TEST_FOR_ONESHOT: 	
                      8041     	; Test whether signal is OneShot125
11E4    C275          8042     CLR FLAGS2 . 5 
11E6    752900        8043     	MOV	RCP_OUTSIDE_RANGE_CNT, #0		; Reset out of range counter
11E9    120586        8044     	CALL WAIT100MS						; Wait for new RC pulse
11EC    307409        8045     JNB FLAGS2 . 4 , VALIDATE_RCP_START 
                      8046     
11EF    C3            8047     	CLR	C
11F0    E529          8048     	MOV	A, RCP_OUTSIDE_RANGE_CNT			; Check how many pulses were outside normal PPM range (800-2160us)
11F2    940A          8049     	SUBB	A, #10						
11F4    4002          8050     	JC	VALIDATE_RCP_START
                      8051     
11F6    D275          8052     SETB FLAGS2 . 5 
                      8053     
                      8054     	; Validate RC pulse
                      8055     VALIDATE_RCP_START: 	
11F8    120577        8056     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
11FB    7802          8057     MOV R0 , # 2 
11FD    307402        8058     JNB FLAGS2 . 4 , ( $+5 ) 
                      8059     
1200    7800          8060     MOV R0 , # 0 
                      8061     
1202    C3            8062     	CLR	C
1203    E55C          8063     	MOV	A, NEW_RCP					; Load value
1205    98            8064     SUBB A , R0 
1206    40F0          8065     	JC	VALIDATE_RCP_START				; No - start over
                      8066     
                      8067     	; Beep arm sequence start signal
1208    C2AF          8068     	CLR 	EA							; Disable all interrupts
120A    12059B        8069     	CALL BEEP_F1						; Signal that RC pulse is ready
120D    12059B        8070     	CALL BEEP_F1
1210    D2AF          8071     	SETB	EA							; Enable all interrupts
1212    12058B        8072     	CALL WAIT200MS	
                      8073     
                      8074     	; Arming sequence start
1215    754C00        8075     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      8076     ARMING_START: 
                      8077     IF MODE >= 1	; Tail or multi
1218    7888          8078     MOV R0 , # PGM_DIRECTION 
121A    E6            8079     MOV A , @ R0 
121B    B40302        8080     	CJNE	A, #3, ($+5)
                      8081     
121E    6114          8082     	AJMP	PROGRAM_BY_TX_CHECKED	; Disable tx programming if bidirectional operation
                      8083     ENDIF
                      8084     
1220    120577        8085     	CALL WAIT3MS
1223    788C          8086     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
1225    E6            8087     MOV A , @ R0 
1226    C3            8088     	CLR	C
1227    9401          8089     	SUBB	A, #1				; Is TX programming enabled?
1229    5003          8090     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      8091     
122B    021314        8092     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      8093     
                      8094     ARMING_INITIAL_ARM_CHECK: 
122E    E530          8095     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
1230    C3            8096     	CLR	C
1231    9401          8097     	SUBB	A, #1				; Is it the initial arm sequence?
1233    5003          8098     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      8099     
1235    021314        8100     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      8101     
                      8102     ARMING_PPM_CHECK: 
                      8103     	; Initialize flash keys to valid values
1238    757CA5        8104     	MOV	FLASH_KEY_1, #0A5H
123B    757DF1        8105     	MOV	FLASH_KEY_2, #0F1H
123E    207435        8106     JB FLAGS2 . 4 , THROTTLE_HIGH_CAL_START 
                      8107     
                      8108     	; PWM tx program entry
1241    C3            8109     	CLR	C
1242    E55C          8110     	MOV	A, NEW_RCP			; Load new RC pulse value
1244    94FF          8111     SUBB A , # 255 
1246    5003          8112     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      8113     
1248    021314        8114     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      8115     
                      8116     PROGRAM_BY_TX_ENTRY_PWM: 	
124B    C2AF          8117     	CLR	EA					; Disable all interrupts
124D    1205B0        8118     	CALL BEEP_F4
1250    D2AF          8119     	SETB	EA					; Enable all interrupts
1252    120586        8120     	CALL WAIT100MS
1255    C3            8121     	CLR	C
1256    E55C          8122     	MOV	A, NEW_RCP			; Load new RC pulse value
1258    9401          8123     SUBB A , # 1 
125A    50EF          8124     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      8125     
                      8126     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
125C    C2AF          8127     	CLR	EA					; Disable all interrupts
125E    12059B        8128     	CALL BEEP_F1
1261    12057C        8129     	CALL WAIT10MS
1264    12059B        8130     	CALL BEEP_F1
1267    D2AF          8131     	SETB	EA					; Enable all interrupts
1269    120586        8132     	CALL WAIT100MS
126C    C3            8133     	CLR	C
126D    E55C          8134     	MOV	A, NEW_RCP			; Load new RC pulse value
126F    94FF          8135     SUBB A , # 255 
1271    40E9          8136     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      8137     
1273    021778        8138     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      8139     
                      8140     	; PPM throttle calibration and tx program entry
                      8141     THROTTLE_HIGH_CAL_START: 
                      8142     IF MODE <= 1	; Main or tail
1276    7F05          8143     MOV R7 , # 5 
                      8144     ELSE
                               	MOV	TEMP8, #2				; Set 1 seconds wait time
                               ENDIF
                      8147     THROTTLE_HIGH_CAL: 			
1278    D27F          8148     SETB FLAGS3 . 7 
127A    120F7F        8149     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
127D    120586        8150     	CALL WAIT100MS				; Wait for new throttle value
1280    C2AF          8151     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
1282    C27F          8152     CLR FLAGS3 . 7 
1284    120F7F        8153     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1287    AE5C          8154     MOV R6 , NEW_RCP 
1289    C3            8155     	CLR	C
128A    E55C          8156     	MOV	A, NEW_RCP			; Load new RC pulse value
128C    947F          8157     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
128E    D2AF          8158     	SETB	EA					; Enable interrupts
1290    5002          8159     	JNC	($+4)		
1292    6124          8160     	AJMP	ARM_TARGET_UPDATED		; No - branch
                      8161     
1294    120572        8162     	CALL WAIT1MS		
1297    C2AF          8163     	CLR	EA					; Disable all interrupts
1299    1205B0        8164     	CALL BEEP_F4
129C    D2AF          8165     	SETB	EA					; Enable all interrupts
129E    DFD8          8166     DJNZ R7 , THROTTLE_HIGH_CAL 
                      8167     
12A0    120FB6        8168     	CALL	AVERAGE_THROTTLE
12A3    C3            8169     	CLR	C
12A4    EE            8170     MOV A , R6 
                      8171     IF MODE <= 1	; Main or tail
12A5    9405          8172     	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
                      8173     ENDIF
12A7    7897          8174     MOV R0 , # PGM_PPM_MAX_THROTTLE 
12A9    F6            8175     MOV @ R0 , A 
12AA    12058B        8176     	CALL WAIT200MS				
12AD    1216FB        8177     	CALL	SUCCESS_BEEP
                      8178     
                      8179     THROTTLE_LOW_CAL_START: 
12B0    7F0A          8180     MOV R7 , # 10 
                      8181     THROTTLE_LOW_CAL: 			
12B2    D27F          8182     SETB FLAGS3 . 7 
12B4    120F7F        8183     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
12B7    120586        8184     	CALL WAIT100MS
12BA    C2AF          8185     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
12BC    C27F          8186     CLR FLAGS3 . 7 
12BE    120F7F        8187     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
12C1    AE5C          8188     MOV R6 , NEW_RCP 
12C3    C3            8189     	CLR	C
12C4    E55C          8190     	MOV	A, NEW_RCP			; Load new RC pulse value
12C6    947F          8191     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
12C8    D2AF          8192     	SETB	EA					; Enable interrupts
12CA    50E4          8193     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      8194     
12CC    120572        8195     	CALL WAIT1MS		
12CF    C2AF          8196     	CLR	EA					; Disable all interrupts
12D1    12059B        8197     	CALL BEEP_F1
12D4    12057C        8198     	CALL WAIT10MS
12D7    12059B        8199     	CALL BEEP_F1
12DA    D2AF          8200     	SETB	EA					; Enable all interrupts
12DC    DFD4          8201     DJNZ R7 , THROTTLE_LOW_CAL 
                      8202     
12DE    120FB6        8203     	CALL	AVERAGE_THROTTLE
12E1    EE            8204     MOV A , R6 
12E2    2403          8205     	ADD	A, #3				; Add about 1%
12E4    7896          8206     MOV R0 , # PGM_PPM_MIN_THROTTLE 
12E6    F6            8207     MOV @ R0 , A 
12E7    F8            8208     MOV R0 , A 
12E8    7997          8209     MOV R1 , # PGM_PPM_MAX_THROTTLE 
12EA    E7            8210     MOV A , @ R1 
12EB    C3            8211     	CLR	C
12EC    9482          8212     	SUBB	A, #130				; Subtract 130 (520us) from max throttle
12EE    4003          8213     	JC	PROGRAM_BY_TX_ENTRY_LIMIT
                      8214     
12F0    98            8215     SUBB A , R0 
12F1    5006          8216     	JNC	PROGRAM_BY_TX_ENTRY_STORE
                      8217     
                      8218     PROGRAM_BY_TX_ENTRY_LIMIT: 
12F3    E8            8219     MOV A , R0 
12F4    2482          8220     	ADD	A, #130				; Make max 520us higher than min
12F6    7897          8221     MOV R0 , # PGM_PPM_MAX_THROTTLE 
12F8    F6            8222     MOV @ R0 , A 
                      8223     
                      8224     PROGRAM_BY_TX_ENTRY_STORE: 
12F9    12058B        8225     	CALL WAIT200MS				
12FC    121618        8226     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
12FF    12172A        8227     	CALL	SUCCESS_BEEP_INVERTED
                      8228     
                      8229     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
1302    120586        8230     	CALL WAIT100MS
1305    120F7F        8231     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1308    C3            8232     	CLR	C
1309    E55C          8233     	MOV	A, NEW_RCP			; Load new RC pulse value
130B    94FF          8234     SUBB A , # 255 
130D    5002          8235     	JNC	($+4)
130F    4138          8236     	AJMP	ARMING_PPM_CHECK		; No - go back
                      8237     
1311    021778        8238     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      8239     
                      8240     PROGRAM_BY_TX_CHECKED: 
                      8241     	; Initialize flash keys to invalid values
1314    757C00        8242     	MOV	FLASH_KEY_1, #0
1317    757D00        8243     	MOV	FLASH_KEY_2, #0
131A    C3            8244     	CLR	C
131B    E55C          8245     	MOV	A, NEW_RCP			; Load new RC pulse value
131D    954C          8246     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
131F    4003          8247     	JC	ARM_TARGET_UPDATED		; No - do not update
                      8248     
1321    855C4C        8249     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      8250     
                      8251     ARM_TARGET_UPDATED: 
1324    120586        8252     	CALL WAIT100MS				; Wait for new throttle value
1327    7801          8253     MOV R0 , # 1 
1329    7988          8254     MOV R1 , # PGM_DIRECTION 
132B    E7            8255     MOV A , @ R1 
132C    B40302        8256     	CJNE	A, #3, ($+5)			; No - branch
                      8257     
132F    7805          8258     MOV R0 , # ( RCP_STOP+4 ) 
                      8259     
1331    C3            8260     	CLR	C
1332    E55C          8261     	MOV	A, NEW_RCP			; Load new RC pulse value
1334    98            8262     SUBB A , R0 
1335    4002          8263     	JC	ARM_END_BEEP			; Yes - proceed
                      8264     
1337    4118          8265     	JMP	ARMING_START			; No - start over
                      8266     
                      8267     ARM_END_BEEP: 
                      8268     	; Beep arm sequence end signal
1339    C2AF          8269     	CLR 	EA					; Disable all interrupts
133B    1205B0        8270     	CALL BEEP_F4			; Signal that rcpulse is ready
133E    1205B0        8271     	CALL BEEP_F4
1341    D2AF          8272     	SETB	EA					; Enable all interrupts
1343    12058B        8273     	CALL WAIT200MS
                      8274     
                      8275     	; Clear initial arm variable
1346    753000        8276     	MOV	INITIAL_ARM, #0
                      8277     
                      8278     	; Armed and waiting for power on
                      8279     WAIT_FOR_POWER_ON: 
1349    E4            8280     	CLR	A
134A    F531          8281     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
134C    F532          8282     	MOV	POWER_ON_WAIT_CNT_H, A	
                      8283     WAIT_FOR_POWER_ON_LOOP: 
134E    0531          8284     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
1350    E531          8285     	MOV	A, POWER_ON_WAIT_CNT_L
1352    F4            8286     	CPL	A
1353    703F          8287     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 3 sec)
                      8288     
1355    0532          8289     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
1357    789A          8290     MOV R0 , # PGM_BEACON_DELAY 
1359    E6            8291     MOV A , @ R0 
135A    7819          8292     MOV R0 , # 25 
135C    14            8293     	DEC	A
135D    6012          8294     	JZ	BEEP_DELAY_SET
                      8295     
135F    7832          8296     MOV R0 , # 50 
1361    14            8297     	DEC	A
1362    600D          8298     	JZ	BEEP_DELAY_SET
                      8299     
1364    787D          8300     MOV R0 , # 125 
1366    14            8301     	DEC	A
1367    6008          8302     	JZ	BEEP_DELAY_SET
                      8303     
1369    78FA          8304     MOV R0 , # 250 
136B    14            8305     	DEC	A
136C    6003          8306     	JZ	BEEP_DELAY_SET
                      8307     
136E    753200        8308     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      8309     
                      8310     BEEP_DELAY_SET: 
1371    C3            8311     	CLR	C
1372    E532          8312     	MOV	A, POWER_ON_WAIT_CNT_H
1374    98            8313     SUBB A , R0 
1375    401D          8314     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      8315     
1377    120E7C        8316     	CALL	SWITCH_POWER_OFF		; Switch power off in case braking is set
137A    120572        8317     	CALL	WAIT1MS
137D    1532          8318     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
137F    753100        8319     	MOV	POWER_ON_WAIT_CNT_L, #0	; Set low wait counter
1382    7899          8320     MOV R0 , # PGM_BEACON_STRENGTH 
1384    8673          8321     MOV BEEP_STRENGTH , @ R0 
1386    C2AF          8322     	CLR 	EA					; Disable all interrupts
1388    1205B0        8323     	CALL BEEP_F4				; Signal that there is no signal
138B    D2AF          8324     	SETB	EA					; Enable all interrupts
138D    7898          8325     MOV R0 , # PGM_BEEP_STRENGTH 
138F    8673          8326     MOV BEEP_STRENGTH , @ R0 
1391    120586        8327     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      8328     
                      8329     WAIT_FOR_POWER_ON_NO_BEEP: 
1394    12057C        8330     	CALL WAIT10MS
1397    E52A          8331     	MOV	A, RCP_TIMEOUT_CNTD				; Load RC pulse timeout counter value
1399    7005          8332     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      8333     
139B    307402        8334     JNB FLAGS2 . 4 , WAIT_FOR_POWER_ON_PPM_NOT_MISSING 
                      8335     
139E    2117          8336     	JMP	INIT_NO_SIGNAL					; If ppm and pulses missing - go back to detect input signal
                      8337     
                      8338     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
13A0    7801          8339     MOV R0 , # 1 
13A2    207402        8340     JB FLAGS2 . 4 , ( $+5 ) 
                      8341     
13A5    7806          8342     MOV R0 , # ( RCP_STOP+5 ) 
                      8343     
13A7    C3            8344     	CLR	C
13A8    E55C          8345     	MOV	A, NEW_RCP			; Load new RC pulse value
13AA    98            8346     SUBB A , R0 
13AB    40A1          8347     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      8348     
                      8349     IF MODE >= 1	; Tail or multi
13AD    7888          8350     MOV R0 , # PGM_DIRECTION 
13AF    E6            8351     MOV A , @ R0 
13B0    C3            8352     	CLR	C
13B1    9403          8353     	SUBB	A, #3
13B3    6003          8354     	JZ 	WAIT_FOR_POWER_ON_CHECK_TIMEOUT	; Do not wait if bidirectional operation
                      8355     ENDIF
                      8356     
13B5    120586        8357     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      8358     
                      8359     WAIT_FOR_POWER_ON_CHECK_TIMEOUT: 
13B8    E52A          8360     	MOV	A, RCP_TIMEOUT_CNTD		; Load RC pulse timeout counter value
13BA    7003          8361     	JNZ	($+5)				; If it is not zero - proceed
                      8362     
13BC    021117        8363     	LJMP	INIT_NO_SIGNAL			; If it is zero (pulses missing) - go back to detect input signal
                      8364     
                      8365     
                      8366     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8367     ;
                      8368     ; Start entry point
                      8369     ;
                      8370     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8371     INIT_START: 
13BF    C2AF          8372     	CLR	EA
13C1    120E7C        8373     	CALL SWITCH_POWER_OFF
13C4    E4            8374     	CLR	A
13C5    F522          8375     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
13C7    F523          8376     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
13C9    F524          8377     	MOV	CURRENT_PWM, A			; Set current pwm to zero
13CB    F525          8378     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
13CD    F526          8379     	MOV	CURRENT_PWM_LIM_DITH, A
13CF    F567          8380     	MOV	PWM_DITHER_EXCESS_POWER, A
13D1    D2AF          8381     	SETB	EA
13D3    7885          8382     MOV R0 , # PGM_MOTOR_IDLE 
13D5    E6            8383     MOV A , @ R0 
13D6    C3            8384     	CLR	C
13D7    33            8385     	RLC	A
13D8    F565          8386     	MOV	PWM_MOTOR_IDLE, A
13DA    E4            8387     	CLR	A
13DB    F544          8388     	MOV	GOV_TARGET_L, A		; Set target to zero
13DD    F545          8389     	MOV	GOV_TARGET_H, A
13DF    F546          8390     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
13E1    F547          8391     	MOV	GOV_INTEGRAL_H, A
13E3    F548          8392     	MOV	GOV_INTEGRAL_X, A
13E5    F570          8393     	MOV	ADC_CONVERSION_CNT, A
13E7    F52C          8394     	MOV	FLAGS0, A				; Clear flags0
13E9    F52D          8395     	MOV	FLAGS1, A				; Clear flags1
13EB    F537          8396     	MOV	DEMAG_DETECTED_METRIC, A	; Clear demag metric
                      8397     	;**** **** **** **** ****
                      8398     	; Motor start beginning
                      8399     	;**** **** **** **** **** 
13ED    757008        8400     MOV ADC_CONVERSION_CNT , # 8 
                      8401     	SET_ADC_IP_TEMP
13F0    75BB10        8401+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
13F3    120572        8402     	CALL WAIT1MS
13F6    12082E        8403     	CALL START_ADC_CONVERSION
                      8404     READ_INITIAL_TEMP: 
13F9    30EDFD        8405     	JNB	AD0INT, READ_INITIAL_TEMP
                      8406     	READ_ADC_RESULT						; Read initial temperature
13FC    A8BD          8406+1   MOV R0 , ADC0L 
13FE    A9BE          8406+1   MOV R1 , ADC0H 
1400    E9            8407     MOV A , R1 
1401    7001          8408     	JNZ	($+3)							; Is reading below 256?
                      8409     
1403    F8            8410     MOV R0 , A 
                      8411     
1404    8871          8412     MOV CURRENT_AVERAGE_TEMP , R0 
1406    120832        8413     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1409    757008        8414     MOV ADC_CONVERSION_CNT , # 8 
                      8415     	SET_ADC_IP_TEMP
140C    75BB10        8415+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      8416     	; Set up start operating conditions
140F    120EFD        8417     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
                      8418     	; Set max allowed power
1412    C2AF          8419     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
1414    7561FF        8420     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
1417    1208A8        8421     	CALL SET_STARTUP_PWM
141A    852261        8422     	MOV	PWM_LIMIT, REQUESTED_PWM
141D    852262        8423     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
1420    852263        8424     	MOV	PWM_LIMIT_BY_RPM, REQUESTED_PWM
1423    D2AF          8425     	SETB	EA
1425    752201        8426     	MOV	REQUESTED_PWM, #1			; Set low pwm again after calling set_startup_pwm
1428    752401        8427     	MOV	CURRENT_PWM, #1
142B    752501        8428     	MOV	CURRENT_PWM_LIMITED, #1	
142E    752601        8429     	MOV	CURRENT_PWM_LIM_DITH, #1
1431    856069        8430     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1434    756A01        8431     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      8432     	; Begin startup sequence
                      8433     IF MCU_48MHZ == 1
                               	SET_MCU_CLK_48MHZ
                               ENDIF
1437    7888          8436     MOV R0 , # PGM_DIRECTION 
1439    E6            8437     MOV A , @ R0 
143A    B40307        8438     	CJNE	A, #3, INIT_START_BIDIR_DONE
                      8439     
143D    C27D          8440     CLR FLAGS3 . 5 
143F    307602        8441     JNB FLAGS2 . 6 , ( $+5 ) 
1442    D27D          8442     SETB FLAGS3 . 5 
                      8443     
                      8444     INIT_START_BIDIR_DONE: 
1444    D268          8445     SETB FLAGS1 . 0 
1446    D269          8446     SETB FLAGS1 . 1 
1448    753300        8447     	MOV	STARTUP_CNT, #0			; Reset counter
144B    120DD6        8448     	CALL COMM5COMM6				; Initialize commutation
144E    120E05        8449     	CALL COMM6COMM1				
1451    1208C8        8450     	CALL INITIALIZE_TIMING			; Initialize timing
1454    1208CF        8451     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
1457    1208C8        8452     	CALL INITIALIZE_TIMING			; Initialize timing
145A    1208CF        8453     	CALL	CALC_NEXT_COMM_TIMING		
145D    1208C8        8454     	CALL	INITIALIZE_TIMING			; Initialize timing
                      8455     
                      8456     
                      8457     
                      8458     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8459     ;
                      8460     ; Run entry point
                      8461     ;
                      8462     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8463     
                      8464     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      8465     ; Out_cA changes from low to high
                      8466     RUN1: 
1460    120B4D        8467     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
                      8468     ;	 	setup_comm_wait		; Setup wait time from zero cross to commutation
                      8469     ;	 	evaluate_comparator_integrity	; Check whether comparator reading has been normal
1463    120691        8470     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
1466    120C43        8471     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
1469    120C8A        8472     	CALL COMM1COMM2			; Commutate
146C    1208CF        8473     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
                      8474     ;	 	wait_advance_timing		; Wait advance timing and start zero cross wait
                      8475     ;	 	calc_new_wait_times
                      8476     ;	 	wait_before_zc_scan		; Wait zero cross wait and start zero cross timeout
                      8477     
                      8478     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      8479     ; Out_cB changes from high to low
                      8480     RUN2: 
146F    120B3C        8481     	CALL WAIT_FOR_COMP_OUT_LOW
                      8482     ;	 	setup_comm_wait	
                      8483     ;		evaluate_comparator_integrity	
1472    306E03        8484     JNB FLAGS1 . 6 , ( $+6 ) 
1475    120692        8485     	LCALL CALC_GOVERNOR_PROP_ERROR
1478    206603        8486     JB FLAGS0 . 6 , ( $+6 ) 
147B    1207E4        8487     	LCALL SET_PWM_LIMIT_LOW_RPM
147E    306603        8488     JNB FLAGS0 . 6 , ( $+6 ) 
1481    120814        8489     	LCALL SET_PWM_LIMIT_HIGH_RPM
1484    120C43        8490     	CALL WAIT_FOR_COMM
1487    120CB9        8491     	CALL COMM2COMM3
148A    1208CF        8492     	CALL CALC_NEXT_COMM_TIMING
                      8493     ;	 	wait_advance_timing
                      8494     ;	 	calc_new_wait_times
                      8495     ;	 	wait_before_zc_scan	
                      8496     
                      8497     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      8498     ; Out_cC changes from low to high
                      8499     RUN3: 
148D    120B4D        8500     	CALL WAIT_FOR_COMP_OUT_HIGH
                      8501     ;	 	setup_comm_wait	
                      8502     ;	 	evaluate_comparator_integrity	
1490    306E03        8503     JNB FLAGS1 . 6 , ( $+6 ) 
1493    1206CE        8504     	LCALL CALC_GOVERNOR_INT_ERROR
1496    120C43        8505     	CALL WAIT_FOR_COMM
1499    120D30        8506     	CALL COMM3COMM4
149C    1208CF        8507     	CALL CALC_NEXT_COMM_TIMING
                      8508     ;	 	wait_advance_timing
                      8509     ;	 	calc_new_wait_times
                      8510     ;	 	wait_before_zc_scan	
                      8511     
                      8512     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      8513     ; Out_cA changes from high to low
                      8514     RUN4: 
149F    120B3C        8515     	CALL WAIT_FOR_COMP_OUT_LOW
                      8516     ;	 	setup_comm_wait	
                      8517     ;	 	evaluate_comparator_integrity	
14A2    306E03        8518     JNB FLAGS1 . 6 , ( $+6 ) 
14A5    12072C        8519     	LCALL CALC_GOVERNOR_PROP_CORRECTION
14A8    120C43        8520     	CALL WAIT_FOR_COMM
14AB    120D5F        8521     	CALL COMM4COMM5
14AE    1208CF        8522     	CALL CALC_NEXT_COMM_TIMING
                      8523     ;	 	wait_advance_timing
                      8524     ;	 	calc_new_wait_times
                      8525     ;	 	wait_before_zc_scan	
                      8526     
                      8527     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      8528     ; Out_cB changes from low to high
                      8529     RUN5: 
14B1    120B4D        8530     	CALL WAIT_FOR_COMP_OUT_HIGH
                      8531     ;	 	setup_comm_wait	
                      8532     ;	 	evaluate_comparator_integrity	
14B4    306E03        8533     JNB FLAGS1 . 6 , ( $+6 ) 
14B7    120789        8534     	LCALL CALC_GOVERNOR_INT_CORRECTION
14BA    120C43        8535     	CALL WAIT_FOR_COMM
14BD    120DD6        8536     	CALL COMM5COMM6
14C0    1208CF        8537     	CALL CALC_NEXT_COMM_TIMING
                      8538     ;	 	wait_advance_timing
                      8539     ;	 	calc_new_wait_times
                      8540     ;	 	wait_before_zc_scan	
                      8541     
                      8542     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      8543     ; Out_cC changes from high to low
                      8544     RUN6: 
14C3    12082E        8545     	CALL START_ADC_CONVERSION
14C6    120B3C        8546     	CALL WAIT_FOR_COMP_OUT_LOW
                      8547     ;	 	setup_comm_wait	
                      8548     ;	 	evaluate_comparator_integrity	
14C9    120C43        8549     	CALL WAIT_FOR_COMM
14CC    120E05        8550     	CALL COMM6COMM1
14CF    120832        8551     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
14D2    1208CF        8552     	CALL CALC_NEXT_COMM_TIMING
                      8553     ;	 	wait_advance_timing
                      8554     ;	 	calc_new_wait_times
                      8555     ;	 	wait_before_zc_scan	
                      8556     
                      8557     	; Check if it is direct startup
14D5    30692F        8558     JNB FLAGS1 . 1 , NORMAL_RUN_CHECKS 
                      8559     
                      8560     	; Set spoolup power variables
14D8    856461        8561     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
14DB    856462        8562     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
14DE    856069        8563     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
14E1    756A01        8564     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      8565     	; Check startup counter
14E4    7918          8566     MOV R1 , # 24 
14E6    7A0C          8567     MOV R2 , # 12 
14E8    C3            8568     	CLR	C
14E9    E533          8569     	MOV	A, STARTUP_CNT				; Load counter
14EB    99            8570     SUBB A , R1 
14EC    400C          8571     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      8572     
14EE    C269          8573     CLR FLAGS1 . 1 
14F0    D26A          8574     SETB FLAGS1 . 2 
14F2    8A35          8575     MOV INITIAL_RUN_ROT_CNTD , R2 
                      8576     IF MODE == 1	; Tail
14F4    7561FF        8577     	MOV	PWM_LIMIT, #0FFH			; Allow full power
                      8578     ENDIF
                      8579     IF MODE == 2	; Multi
                               	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG
                               	MOV	PWM_LIMIT_BY_RPM, PWM_SPOOLUP_BEG
                               ENDIF
14F7    021507        8583     	JMP	NORMAL_RUN_CHECKS
                      8584     
                      8585     DIRECT_START_CHECK_RCP: 
14FA    C3            8586     	CLR	C
14FB    E55C          8587     	MOV	A, NEW_RCP				; Load new pulse value
14FD    9401          8588     SUBB A , # 1 
14FF    4003          8589     	JC	($+5)
                      8590     
1501    021460        8591     	LJMP	RUN1						; Continue to run 
                      8592     
1504    02158D        8593     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8594     
                      8595     
                      8596     NORMAL_RUN_CHECKS: 
                      8597     	; Check if it is initial run phase
1507    306A1D        8598     JNB FLAGS1 . 2 , INITIAL_RUN_PHASE_DONE 
150A    206C1A        8599     JB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      8600     
                      8601     	; Decrement startup rotaton count
150D    E535          8602     	MOV	A, INITIAL_RUN_ROT_CNTD
150F    14            8603     	DEC	A
                      8604     	; Check number of nondamped rotations
1510    7006          8605     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      8606     
1512    C26A          8607     CLR FLAGS1 . 2 
1514    D26B          8608     SETB FLAGS1 . 3 
1516    8160          8609     	JMP RUN1						; Continue with normal run
                      8610     
                      8611     NORMAL_RUN_CHECK_STARTUP_ROT: 
1518    F535          8612     	MOV	INITIAL_RUN_ROT_CNTD, A		; Not zero - store counter
                      8613     
151A    C3            8614     	CLR	C
151B    E55C          8615     	MOV	A, NEW_RCP				; Load new pulse value
151D    9401          8616     SUBB A , # 1 
151F    4003          8617     	JC	($+5)
                      8618     
1521    021460        8619     	LJMP	RUN1						; Continue to run 
                      8620     
1524    02158D        8621     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8622     
                      8623     INITIAL_RUN_PHASE_DONE: 
                      8624     	; Reset stall count
1527    753600        8625     	MOV	STALL_CNT, #0
                      8626     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      8639     	; Exit run loop after a given time
152A    7882          8640     MOV R0 , # 130 
152C    79A4          8641     MOV R1 , # PGM_BRAKE_ON_STOP 
152E    E7            8642     MOV A , @ R1 
152F    6002          8643     	JZ	($+4)
                      8644     
1531    7803          8645     MOV R0 , # 3 
                      8646     
1533    C3            8647     	CLR	C
1534    E55F          8648     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
1536    98            8649     SUBB A , R0 
1537    5054          8650     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      8651     
1539    307404        8652     JNB FLAGS2 . 4 , RUN6_CHECK_DIR 
                      8653     
153C    E52A          8654     	MOV	A, RCP_TIMEOUT_CNTD			; Load RC pulse timeout counter value
153E    604D          8655     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      8656     
                      8657     RUN6_CHECK_DIR: 
                      8658     IF MODE >= 1	; Tail or multi
1540    7888          8659     MOV R0 , # PGM_DIRECTION 
1542    E6            8660     MOV A , @ R0 
1543    B40317        8661     	CJNE	A, #3, RUN6_CHECK_SPEED
                      8662     
1546    207D05        8663     JB FLAGS3 . 5 , RUN6_CHECK_DIR_REV 
1549    207607        8664     JB FLAGS2 . 6 , RUN6_CHECK_DIR_CHANGE 
154C    A15D          8665     	AJMP	RUN6_CHECK_SPEED
                      8666     
                      8667     RUN6_CHECK_DIR_REV: 
154E    307602        8668     JNB FLAGS2 . 6 , RUN6_CHECK_DIR_CHANGE 
1551    A15D          8669     	AJMP	RUN6_CHECK_SPEED
                      8670     
                      8671     RUN6_CHECK_DIR_CHANGE: 
1553    206C07        8672     JB FLAGS1 . 4 , RUN6_CHECK_SPEED 
                      8673     
1556    D26C          8674     SETB FLAGS1 . 4 
1558    856461        8675     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set max power while braking
155B    819F          8676     	JMP	RUN4						; Go back to run 4, thereby changing force direction
                      8677     
                      8678     RUN6_CHECK_SPEED: 
                      8679     ENDIF
155D    78F0          8680     MOV R0 , # 0F0H 
155F    306C05        8681     JNB FLAGS1 . 4 , RUN6_BRAKE_DONE 
                      8682     
1562    856461        8683     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG 	; Set max power while braking
1565    7820          8684     MOV R0 , # 20H 
                      8685     
                      8686     RUN6_BRAKE_DONE: 
1567    C3            8687     	CLR	C
1568    E541          8688     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
156A    98            8689     SUBB A , R0 
156B    5002          8690     	JNC	($+4)					; Yes - stop or turn direction 
156D    8160          8691     	AJMP	RUN1						; No - go back to run 1
                      8692     
                      8693     IF MODE >= 1	; Tail or multi
156F    306C1B        8694     JNB FLAGS1 . 4 , RUN_TO_WAIT_FOR_POWER_ON 
                      8695     
1572    C26C          8696     CLR FLAGS1 . 4 
1574    C27D          8697     CLR FLAGS3 . 5 
1576    307602        8698     JNB FLAGS2 . 6 , ( $+5 ) 
1579    D27D          8699     SETB FLAGS3 . 5 
157B    D26A          8700     SETB FLAGS1 . 2 
157D    753512        8701     	MOV	INITIAL_RUN_ROT_CNTD, #18
1580    856461        8702     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set initial max power
1583    8160          8703     	AJMP	RUN1						; Go back to run 1 
                      8704     ENDIF
                      8705     
                      8706     RUN_TO_WAIT_FOR_POWER_ON_FAIL: 	
1585    0536          8707     	INC	STALL_CNT					; Increment stall count
1587    E55C          8708     	MOV	A, NEW_RCP				; Check if RCP is zero, then it is a normal stop			
1589    6002          8709     	JZ	RUN_TO_WAIT_FOR_POWER_ON
158B    A190          8710     	AJMP	RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE
                      8711     
                      8712     RUN_TO_WAIT_FOR_POWER_ON: 	
158D    753600        8713     	MOV	STALL_CNT, #0
                      8714     
                      8715     RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE: 
1590    C2AF          8716     	CLR	EA
1592    120E7C        8717     	CALL SWITCH_POWER_OFF
1595    7887          8718     MOV R0 , # PGM_PWM_FREQ 
1597    E6            8719     MOV A , @ R0 
1598    FE            8720     MOV R6 , A 
1599    7602          8721     MOV @ R0 , # 2 
159B    120EFD        8722     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
159E    7887          8723     MOV R0 , # PGM_PWM_FREQ 
15A0    EE            8724     MOV A , R6 
15A1    F6            8725     MOV @ R0 , A 
15A2    E4            8726     	CLR	A
15A3    F522          8727     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
15A5    F523          8728     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
15A7    F524          8729     	MOV	CURRENT_PWM, A				; Set current pwm to zero
15A9    F525          8730     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
15AB    F526          8731     	MOV	CURRENT_PWM_LIM_DITH, A	
15AD    F565          8732     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
15AF    752C00        8733     	MOV	FLAGS0, #0				; Clear flags0
15B2    752D00        8734     	MOV	FLAGS1, #0				; Clear flags1
                      8735     IF MCU_48MHZ == 1
                               	SET_MCU_CLK_24MHZ
                               ENDIF
15B5    D2AF          8738     	SETB	EA
15B7    120586        8739     	CALL	WAIT100MS					; Wait for pwm to be stopped
15BA    120E7C        8740     	CALL SWITCH_POWER_OFF
15BD    78A4          8741     MOV R0 , # PGM_BRAKE_ON_STOP 
15BF    E6            8742     MOV A , @ R0 
15C0    6006          8743     	JZ	RUN_TO_WAIT_FOR_POWER_ON_BRAKE_DONE
                      8744     
                      8745     	BRAKE_FETS_ON
                      8745+1   ANFET_ON 
15C2    D294          8745+2   SETB P1 . 4 
                      8745+1   BNFET_ON 
15C4    D292          8745+2   SETB P1 . 2 
                      8745+1   CNFET_ON 
15C6    D290          8745+2   SETB P1 . 0 
                      8746     
                      8747     RUN_TO_WAIT_FOR_POWER_ON_BRAKE_DONE: 
                      8748     IF MODE == 0	; Main
                               	JNB	FLAGS2.RCP_PPM, RUN_TO_NEXT_STATE_MAIN	; If flag is not set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNTD			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	INIT_NO_SIGNAL				; If it is zero (pulses missing) - go back to detect input signal
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      8768     IF MODE >= 1	; Tail or multi
15C8    307409        8769     JNB FLAGS2 . 4 , JMP_WAIT_FOR_POWER_ON 
                      8770     
15CB    C3            8771     	CLR	C
15CC    E536          8772     	MOV	A, STALL_CNT
15CE    9404          8773     	SUBB	A, #4
15D0    4002          8774     	JC	JMP_WAIT_FOR_POWER_ON
15D2    2117          8775     	JMP	INIT_NO_SIGNAL
                      8776     
                      8777     JMP_WAIT_FOR_POWER_ON: 
15D4    6149          8778     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      8779     ENDIF
                      8780     
                      8781     
                      8782     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8783     
                      8784     $INCLUDE (BLHELITXPGM.INC)			; Include source code for programming the ESC with the TX
                      9451     $INCLUDE (BLHELIBOOTLOAD.INC)			; Include source code for bootloader
                      9858     
                      9859     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      9860     
                      9861     
------                9862     CSEG AT 19FDH
                      9863     RESET: 
19FD    021059        9864     LJMP	PGM_START
                      9865     
                      9866     
                      9867     
                      9868     
                      9869     END
MACRO ASSEMBLER BLHELI                                      09/01/16 09:39:38 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

SET4 . . . . . . .  C ADDR   1CCEH   A 
ID3. . . . . . . .  C ADDR   1C55H   A 
BYTE_CNTH. . . . .  D ADDR   0028H   A 
CRCH . . . . . . .  D ADDR   0023H   A 
CMDL . . . . . . .    REG    R4             
XH . . . . . . . .    REG    R1             
NORMAL_RUN_CHECK_~  C ADDR   1518H   A 
DECODE_DEMAG_HIGH.  C ADDR   0F6BH   A 
COMM61_DAMP_REV. .  C ADDR   0E2BH   A 
COMM12_NFET_DONE .  C ADDR   0C9BH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0B3BH   A 
CHECK_TEMP_VOLTAG~  C ADDR   0832H   A 
GOVERNOR_LIMIT_IN~  C ADDR   07AFH   A 
GOVERNOR_CORR_NEG~  C ADDR   0778H   A 
PCA_INT_PPM_BELOW~  C ADDR   045CH   A 
T2_INT_CURRENT_PW~  C ADDR   027CH   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
TIMER0_OVERFLOW_V~  D ADDR   0079H   A 
PPM_THROTTLE_GAIN.  D ADDR   0072H   A 
LIPO_ADC_LIMIT_H .  D ADDR   006FH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005EH   A 
RCP_EDGE_H . . . .  D ADDR   0058H   A 
FLAGS3 . . . . . .  D ADDR   002FH   A 
RCP_PREV_EDGE_L. .  D ADDR   0027H   A 
ADC_IP . . . . . .  N NUMB   0006h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
SBUF0. . . . . . .  D ADDR   0099H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
ALIGN_MR25_15A_MU~  N NUMB   010Bh            
DYS_XM20A_TAIL . .  N NUMB   00F8h            
POLARIS_THUNDER_4~  N NUMB   008Fh            
POLARIS_THUNDER_3~  N NUMB   008Dh            
POLARIS_THUNDER_1~  N NUMB   0087h            
SET5 . . . . . . .  C ADDR   1CD4H   A 
ID4. . . . . . . .  C ADDR   1C60H   A 
BOOT_START . . . .  N NUMB   1C00h            
FUNCTION_BEEP. . .  C ADDR   175FH   A 
INIT_START . . . .  C ADDR   13BFH   A 
PROGRAM_BY_TX_ENT~  C ADDR   124BH   A 
FIND_THROTTLE_GAI~  C ADDR   0F99H   A 
COMM45_NONDAMP . .  C ADDR   0DA5H   A 
COMM4COMM5 . . . .  C ADDR   0D5FH   A 
CALC_NEW_WAIT_TIM~  C ADDR   0985H   A 
SET_PWM_LIMIT_HIG~  C ADDR   0824H   A 
PCA_INT_RESTORE_E~  C ADDR   03E1H   A 
T2H_INT_RCP_STOP .  C ADDR   02A6H   A 
T0_INT_PWM_OFF_DA~  C ADDR   00F1H   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006DH   A 
RANDOM . . . . . .  D ADDR   0068H   A 
PWM_MOTOR_IDLE . .  D ADDR   0065H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005DH   A 
COMM_PERIOD4X_H. .  D ADDR   0041H   A 
PWM_START. . . . .  N NUMB   0032h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
DYS_XM20A_MULTI. .  N NUMB   00F9h            
ZTW_SPIDER_PRO_20~  N NUMB   00EBh            
EMAX_NANO_20A_TAIL  N NUMB   00B3h            
PLATINUM_50AV3_TA~  N NUMB   00A1h            
PLATINUM_PRO_30A_~  N NUMB   009Ah            
POLARIS_THUNDER_4~  N NUMB   0090h            
H_KING_35A_TAIL. .  N NUMB   0080h            
SET6 . . . . . . .  C ADDR   1CDCH   A 
ID5. . . . . . . .  C ADDR   1C6DH   A 
ERRORPROG. . . . .  N NUMB   00C5h            
ERRORCRC . . . . .  N NUMB   00C2h            
BOOT_DELAY . . . .  N NUMB   5F5E10h            
PARAVAL_BEEP . . .  C ADDR   176DH   A 
RUN_TO_WAIT_FOR_P~  C ADDR   15C8H   A 
COMM45_DAMP_REV. .  C ADDR   0D85H   A 
COMM23_NFET_DONE .  C ADDR   0D11H   A 
GOVERNOR_CHECK_PWM  C ADDR   0707H   A 
PWM_AFET_DAMPED_D~  C ADDR   012EH   A 
EEP_PGM_BRAKE_ON_~  C ADDR   1A27H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
DEMAG_DETECTED_ME~  D ADDR   0037H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
SIGNATURE_001. . .  N NUMB   00F3h            
RTX_PORT . . . . .  N NUMB   0080h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
B. . . . . . . . .  D ADDR   00F0H   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
P2 . . . . . . . .  D ADDR   00A0H   A 
FLYCOLOR_RAPTOR_3~  N NUMB   00D6h            
EMAX_NANO_20A_MUL~  N NUMB   00B4h            
PLATINUM_50AV3_MU~  N NUMB   00A2h            
POLARIS_THUNDER_6~  N NUMB   0092h            
H_KING_35A_MULTI .  N NUMB   0081h            
TURNIGY_AE_25A_MA~  N NUMB   0043h            
TURNIGY_AE_20A_TA~  N NUMB   0041h            
TURNIGY_PLUSH_10A~  N NUMB   001Fh            
XP_35A_SW_TAIL . .  N NUMB   0014h            
GETC . . . . . . .  C ADDR   1D92H   A 
BIT_CNT. . . . . .  D ADDR   0026H   A 
BOOT_PAGES . . . .  N NUMB   0001h            
WRITE_EEPROM_SIGN~  C ADDR   168EH   A 
WAIT_FOR_POWER_ON.  C ADDR   1349H   A 
ERASE_AND_STORE_A~  C ADDR   1618H   A 
THROTTLE_LOW_CAL_~  C ADDR   12B0H   A 
ARMING_INITIAL_AR~  C ADDR   122EH   A 
PROGRAM_BY_TX_CHE~  C ADDR   1314H   A 
FIND_THROTTLE_GAI~  C ADDR   0F92H   A 
SET_DEFAULT_PARAM~  C ADDR   0E91H   A 
COMM56_REV . . . .  C ADDR   0DEFH   A 
COMM5COMM6 . . . .  C ADDR   0DD6H   A 
COMM23_NFET_OFF_R~  C ADDR   0CF5H   A 
COMP_READ_WRONG_E~  C ADDR   0BBAH   A 
COMP_READ_OK . . .  C ADDR   0BF0H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0A26H   A 
CALC_NEXT_COMM_TI~  C ADDR   08CFH   A 
BEEP_ANFET_OFF . .  C ADDR   05EAH   A 
PCA_INT_STORE_DATA  C ADDR   0406H   A 
T2_INT_RCP_GAIN_P~  C ADDR   01FEH   A 
T2_INT_RCP_UPDATE~  C ADDR   01C5H   A 
PWM_BFET_DAMPED_D~  C ADDR   013FH   A 
RESET. . . . . . .  C ADDR   19FDH   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   00A5H   A 
PGM_ENABLE_TEMP_P~  I ADDR   00A0H   A 
_PGM_THROTTLE_RATE  I ADDR   009BH   A 
_PGM_STARTUP_RPM .  I ADDR   008FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   0062H   A 
RCP_PREPREV_EDGE_H  D ADDR   0056H   A 
WT_ZC_SCAN_START_L  D ADDR   004FH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0003h            
STARTUP_PHASE. . .  N NUMB   0001h            
RCP_SKIP_CNTD. . .  D ADDR   002BH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
SIGNATURE_002. . .  N NUMB   0030h            
LOCK_BYTE_ADDRESS~  N NUMB   1DFFh            
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
SP . . . . . . . .  D ADDR   0081H   A 
ZTW_SPIDER_PRO_20~  N NUMB   00F2h            
FLYCOLOR_FAIRY_6A~  N NUMB   00CBh            
POLARIS_THUNDER_6~  N NUMB   0093h            
SKYWALKER_20A_MAIN  N NUMB   0058h            
TURNIGY_AE_30A_TA~  N NUMB   0047h            
TURNIGY_AE_20A_MU~  N NUMB   0042h            
XP_35A_SW_MULTI. .  N NUMB   0015h            
XP_7A_MAIN . . . .  N NUMB   0004h            
PRO3 . . . . . . .  C ADDR   1D0AH   A 
BOOT_SIGN. . . . .  C ADDR   1DE9H   A 
BYTE_CNTL. . . . .  D ADDR   0027H   A 
BAUDH. . . . . . .  D ADDR   0025H   A 
CRCL . . . . . . .  D ADDR   0022H   A 
XL . . . . . . . .    REG    R0             
FUNCTION_NEXT. . .  C ADDR   17D6H   A 
THROTTLE_HIGH_CAL.  C ADDR   1278H   A 
COMM61_NFET_DONE .  C ADDR   0E5DH   A 
COMM34_NFET_DONE .  C ADDR   0D41H   A 
STORE_TIMES_INCRE~  C ADDR   0ADCH   A 
CALC_NEXT_COMM_NO~  C ADDR   0938H   A 
STARTUP_PWM_SET_P~  C ADDR   08BDH   A 
PWM_CFET_DAMPED_D~  C ADDR   0150H   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
LIPO_ADC_LIMIT_L .  D ADDR   006EH   A 
RCP_EDGE_L . . . .  D ADDR   0057H   A 
STALL_CNT. . . . .  D ADDR   0036H   A 
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
RTX_PIN. . . . . .  N NUMB   0004h            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ZTW_SPIDER_PRO_30~  N NUMB   00F5h            
ZTW_SPIDER_PRO_20~  N NUMB   00F3h            
ZTW_SPIDER_PRO_20~  N NUMB   00EFh            
FVT_LITTLEBEE_20A~  N NUMB   00E0h            
FLYCOLOR_FAIRY_6A~  N NUMB   00CCh            
POLARIS_THUNDER_8~  N NUMB   0095h            
TURNIGY_KFORCE_12~  N NUMB   0053h            
TURNIGY_AE_45A_MA~  N NUMB   0049h            
TURNIGY_AE_30A_MU~  N NUMB   0048h            
TURNIGY_PLUSH_30A~  N NUMB   002Bh            
TURNIGY_PLUSH_12A~  N NUMB   0022h            
XP_3A_TAIL . . . .  N NUMB   0002h            
PRO4 . . . . . . .  C ADDR   1D16H   A 
MAIN . . . . . . .  C ADDR   1C7FH   A 
PARAVAL_NEXT . . .  C ADDR   17C1H   A 
WRITE_EEPROM_BYTE.  C ADDR   165EH   A 
TEST_FOR_ONESHOT .  C ADDR   11E4H   A 
MEASURE_PWM_FREQ_~  C ADDR   1191H   A 
COMM61_NFET_OFF_R~  C ADDR   0E41H   A 
COMM_EXIT. . . . .  C ADDR   0E79H   A 
CALC_GOVERNOR_INT~  C ADDR   0789H   A 
BEEP_CNFET_OFF . .  C ADDR   05EFH   A 
BEEP_ANFET_ON. . .  C ADDR   05DAH   A 
PCA_INT_PPM_CHECK~  C ADDR   047DH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0511H   A 
PCA_INT_FALL_CHEC~  C ADDR   044EH   A 
PCA_INT_LIMITED. .  C ADDR   0534H   A 
T2_INT_PWM_UPDATE.  C ADDR   020EH   A 
T0_INT_PWM_OFF_DA~  C ADDR   00DCH   A 
EEP_DUMMY. . . . .  C ADDR   1A28H   A 
EEP_PGM_ENABLE_PW~  C ADDR   1A25H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A13H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
CLOCK_SET_AT_48MHZ  D ADDR   007AH   A 
COMM_PERIOD4X_L. .  D ADDR   0040H   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
RTX_MDIN . . . . .  N NUMB   00F1h            
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
MODE . . . . . . .  N NUMB   0001h            
ZTW_SPIDER_PRO_30~  N NUMB   00F6h            
ZTW_SPIDER_PRO_20~  N NUMB   00F0h            
FVT_LITTLEBEE_20A~  N NUMB   00E1h            
POLARIS_THUNDER_8~  N NUMB   0096h            
SKYWALKER_40A_MAIN  N NUMB   005Bh            
TURNIGY_KFORCE_12~  N NUMB   0054h            
TURNIGY_PLUSH_40A~  N NUMB   002Eh            
SUPERMICRO_3P5A_M~  N NUMB   0019h            
XP_3A_MULTI. . . .  N NUMB   0003h            
WAIT1. . . . . . .  C ADDR   1DE2H   A 
PRO5 . . . . . . .  C ADDR   1D1CH   A 
FUNC_PARAVAL_WAIT.  C ADDR   178BH   A 
WRITE_TAG. . . . .  C ADDR   16B7H   A 
READ_EEPROM_STORE~  C ADDR   15EFH   A 
RUN6_CHECK_DIR . .  C ADDR   1540H   A 
RUN1 . . . . . . .  C ADDR   1460H   A 
WAIT_FOR_POWER_ON~  C ADDR   13B8H   A 
MEASURE_PWM_FREQ_~  C ADDR   11A2H   A 
CLEAR_RAM. . . . .  C ADDR   10CDH   A 
SET_BEC_VOLTAGE. .  C ADDR   0F7EH   A 
DECODE_DEMAG_DONE.  C ADDR   0F71H   A 
COMM45_NFET_DONE .  C ADDR   0DB7H   A 
WAIT_FOR_COMM. . .  C ADDR   0C43H   A 
ADJUST_TIMING_TWO~  C ADDR   0ACFH   A 
CALC_GOVERNOR_PRO~  C ADDR   06CDH   A 
DIV_U16_BY_U16_DI~  C ADDR   060AH   A 
WAIT100MS. . . . .  C ADDR   0586H   A 
WAIT1MS. . . . . .  C ADDR   0572H   A 
STARTUP_POWER_TAB~  C ADDR   008DH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
FLASH_KEY_1. . . .  D ADDR   007CH   A 
SKIP_T2_INT. . . .  D ADDR   0077H   A 
TX_PGM_BEEP_NO . .  D ADDR   0076H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   006AH   A 
WT_ZC_TOUT_START_H  D ADDR   0052H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
RTX_MDOUT. . . . .  N NUMB   00A4h            
MODF . . . . . . .  B ADDR   00F8H.5 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
PSCTL. . . . . . .  D ADDR   008FH   A 
HTIRC_HUMMINGBIRD~  N NUMB   011Bh            
SERVOKING_MONSTER~  N NUMB   010Ch            
ZTW_SPIDER_PRO_20~  N NUMB   00ECh            
PLATINUM_PRO_30A_~  N NUMB   009Bh            
TURNIGY_KFORCE_12~  N NUMB   0055h            
RD1. . . . . . . .  C ADDR   1D3DH   A 
PRO6 . . . . . . .  C ADDR   1D33H   A 
ABD. . . . . . . .  C ADDR   1C2EH   A 
FUNCTION_PARAVAL_~  C ADDR   1759H   A 
STORE_NEW_VALUE_I~  C ADDR   16BFH   A 
RUN2 . . . . . . .  C ADDR   146FH   A 
ARMING_PPM_CHECK .  C ADDR   1238H   A 
COMM45_NFET_OFF_R~  C ADDR   0D9BH   A 
COMM23_FETS_DONE .  C ADDR   0CD7H   A 
COMP_READ_WRONG_T~  C ADDR   0BCDH   A 
STORE_TIMES_EXIT .  C ADDR   0AB4H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0AEAH   A 
GOVERNOR_CORR_INT~  C ADDR   07CEH   A 
GOVERNOR_STORE_PR~  C ADDR   06C9H   A 
DIV_U16_BY_U16_DI~  C ADDR   0614H   A 
BEEP_CNFET_ON. . .  C ADDR   05DFH   A 
WAIT200MS. . . . .  C ADDR   058BH   A 
T2_INT_RCP_GAIN_C~  C ADDR   01F5H   A 
T2_INT_CURRENT_PW~  C ADDR   0238H   A 
T2_INT_PULSES_ABS~  C ADDR   0170H   A 
T0_INT_PWM_ON_RET.  C ADDR   00BEH   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_MAIN_SPOOLUP_~  I ADDR   009FH   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
FLASH_KEY_2. . . .  D ADDR   007DH   A 
RCP_PREPREV_EDGE_L  D ADDR   0055H   A 
GOV_ACTIVE . . . .  N NUMB   0006h            
MOTOR_STARTED. . .  N NUMB   0003h            
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
IT01CF . . . . . .  D ADDR   00E4H   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
OVERSKY_MR_20A_PR~  N NUMB   00FDh            
ZTW_SPIDER_PRO_20~  N NUMB   00EDh            
FLYCOLOR_RAPTOR_3~  N NUMB   00D7h            
FLYCOLOR_RAPTOR_2~  N NUMB   00D3h            
PLATINUM_PRO_30A_~  N NUMB   009Ch            
TURNIGY_AE_25A_TA~  N NUMB   0044h            
TURNIGY_PLUSH_60A~  N NUMB   0031h            
TURNIGY_PLUSH_10A~  N NUMB   0020h            
MAI1 . . . . . . .  C ADDR   1C81H   A 
IN1. . . . . . . .  C ADDR   1C77H   A 
BAUDL. . . . . . .  D ADDR   0024H   A 
RUN3 . . . . . . .  C ADDR   148DH   A 
COMM56_NFET_DONE .  C ADDR   0DE7H   A 
COMP_CHECK_TIMEOU~  C ADDR   0B8FH   A 
GOVERNOR_LIMIT_IN~  C ADDR   07B6H   A 
GOVERNOR_CHECK_IN~  C ADDR   06EFH   A 
DIV_U16_BY_U16_DI~  C ADDR   062BH   A 
WAIT3MS. . . . . .  C ADDR   0577H   A 
T2_INT_PULSES_ABS~  C ADDR   01A5H   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0047H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
RCP_PPM_ONESHOT125  N NUMB   0005h            
DIR_CHANGE_BRAKE .  N NUMB   0004h            
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   0082h            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
STA. . . . . . . .  B ADDR   00C0H.5 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
FLYCOLOR_RAPTOR_3~  N NUMB   00D8h            
POLARIS_THUNDER_1~  N NUMB   0097h            
SKYWALKER_20A_TAIL  N NUMB   0059h            
TURNIGY_AE_25A_MU~  N NUMB   0045h            
TURNIGY_PLUSH_25A~  N NUMB   0028h            
TURNIGY_PLUSH_10A~  N NUMB   0021h            
XP_7A_TAIL . . . .  N NUMB   0005h            
PUTP . . . . . . .  C ADDR   1D53H   A 
SETBUF . . . . . .  C ADDR   1CC8H   A 
MAI2 . . . . . . .  C ADDR   1CA3H   A 
ERRORCOMMAND . . .  N NUMB   00C1h            
BEEP_NO_ENTRY. . .  C ADDR   1784H   A 
JMP_WAIT_FOR_POWE~  C ADDR   15D4H   A 
DIRECT_START_CHEC~  C ADDR   14FAH   A 
RUN4 . . . . . . .  C ADDR   149FH   A 
WAIT_US_100_M1 . .  C ADDR   1001H   A 
COMM61_FETS_DONE .  C ADDR   0E23H   A 
COMM23_NONDAMP_REV  C ADDR   0D19H   A 
COMP_READ_OK_JMP .  C ADDR   0C02H   A 
STORE_TIMES_UP_OR~  C ADDR   0A7FH   A 
STORE_TIMES_DECRE~  C ADDR   0A93H   A 
CALC_NEXT_COMM_NE~  C ADDR   096AH   A 
TEMP_AVERAGE_INC .  C ADDR   086AH   A 
GOVERNOR_CORR_INT~  C ADDR   07DFH   A 
MULT_S16_BY_U8_DI~  C ADDR   063AH   A 
BEEP_START . . . .  C ADDR   05BDH   A 
PCA_INT_PPM_NEG_C~  C ADDR   04D1H   A 
T2_INT_EXIT. . . .  C ADDR   027EH   A 
_EEP_PGM_DAMPING_~  C ADDR   1A16H   A 
PGM_BRAKE_ON_STOP.  I ADDR   00A4H   A 
PWM_DITHER_EXCESS~  D ADDR   0067H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
SKYWALKER_20A_MUL~  N NUMB   005Ah            
TURNIGY_AE_45A_TA~  N NUMB   004Ah            
TURNIGY_PLUSH_80A~  N NUMB   0034h            
TURNIGY_PLUSH_30A~  N NUMB   002Ch            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
XP_7A_MULTI. . . .  N NUMB   0006h            
PUT1 . . . . . . .  C ADDR   1D59H   A 
READ_TAGS. . . . .  C ADDR   169DH   A 
RUN5 . . . . . . .  C ADDR   14B1H   A 
WAIT_US_100_M2 . .  C ADDR   1028H   A 
COMP_SCALE_SAMPLES  C ADDR   0B82H   A 
CALC_NEW_WAIT_TIM~  C ADDR   09DCH   A 
SET_PWM_LIMIT_HIG~  C ADDR   0814H   A 
GOVERNOR_CORR_NEG~  C ADDR   07D3H   A 
GOVERNOR_LIMIT_PR~  C ADDR   06BEH   A 
CALC_GOVERNOR_TAR~  C ADDR   0691H   A 
PCA_INT_PWM_DIVID~  C ADDR   0518H   A 
PCA_INT_CHECK_12K~  C ADDR   0385H   A 
EEP_PGM_MOTOR_IDLE  C ADDR   1A08H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   0073H   A 
RCP_PREV_PERIOD_H.  D ADDR   005AH   A 
WT_COMM_START_H. .  D ADDR   0054H   A 
WT_ZC_TOUT_START_L  D ADDR   0051H   A 
TIMER2_X . . . . .  D ADDR   003AH   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ANFET_ON . . . . .  ? ADDR   0000H   A 
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
F85_3A_MAIN. . . .  N NUMB   00E8h            
SKYWALKER_40A_TAIL  N NUMB   005Ch            
TURNIGY_AE_45A_MU~  N NUMB   004Bh            
TURNIGY_PLUSH_40A~  N NUMB   002Fh            
TURNIGY_PLUSH_30A~  N NUMB   002Dh            
TURNIGY_PLUSH_18A~  N NUMB   0025h            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
SUPERMICRO_3P5A_T~  N NUMB   001Ah            
PUT2 . . . . . . .  C ADDR   1D6CH   A 
MAI4 . . . . . . .  C ADDR   1CDFH   A 
BAUDTIME . . . . .  N NUMB   0198h            
RUN6_CHECK_DIR_CH~  C ADDR   1553H   A 
RUN6 . . . . . . .  C ADDR   14C3H   A 
ARMING_START . . .  C ADDR   1218H   A 
MEASURE_PWM_FREQ_~  C ADDR   1197H   A 
WAIT_US_100_M3 . .  C ADDR   104FH   A 
COMM61_NONDAMP_REV  C ADDR   0E65H   A 
COMM45_FETS_DONE .  C ADDR   0D7DH   A 
COMP_CHECK_TIMEOU~  C ADDR   0B95H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0AF2H   A 
PCA_INT_CHECK_LEG~  C ADDR   0529H   A 
PCA_INT_FALL_NOT_~  C ADDR   042FH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
_EEP_PGM_GOV_MODE.  C ADDR   1A05H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
PREV_PREV_COMM_H .  D ADDR   003FH   A 
RCP_UPDATED. . . .  N NUMB   0000h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
BNFET_ON . . . . .  ? ADDR   0000H   A 
DEFAULT_PGM_MAIN_~  N NUMB   000Ah            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
HTIRC_HUMMINGBIRD~  N NUMB   011Ch            
SERVOKING_MONSTER~  N NUMB   0112h            
SERVOKING_MONSTER~  N NUMB   010Dh            
FLYCOLOR_FAIRY_30~  N NUMB   00CDh            
ROTORGEEKS_20A_MA~  N NUMB   00C4h            
ALIGN_RCE_BL15P_M~  N NUMB   006Dh            
SKYWALKER_40A_MUL~  N NUMB   005Dh            
TURNIGY_KFORCE_12~  N NUMB   0056h            
TURNIGY_PLUSH_40A~  N NUMB   0030h            
SUPERMICRO_3P5A_M~  N NUMB   001Bh            
DP_3A_MAIN . . . .  N NUMB   0016h            
PUT3 . . . . . . .  C ADDR   1D78H   A 
MAI5 . . . . . . .  C ADDR   1D38H   A 
WAIT_FOR_LOW . . .  C ADDR   1C45H   A 
PARAH. . . . . . .    REG    R3             
PROGRAM_BY_TX_ENT~  C ADDR   12F3H   A 
ARM_TARGET_UPDATED  C ADDR   1324H   A 
COMM12_NFET_DONE_~  C ADDR   0CB1H   A 
EVALUATE_COMPARAT~  C ADDR   0C24H   A 
TEMP_CHECK_EXIT. .  C ADDR   0894H   A 
GOVERNOR_APPLY_PR~  C ADDR   075FH   A 
PWM_AFET_EXIT. . .  C ADDR   010BH   A 
PGM_ENABLE_PWM_IN~  I ADDR   00A2H   A 
_PGM_STARTUP_ACCEL  I ADDR   0090H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0046H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CNFET_ON . . . . .  ? ADDR   0000H   A 
MASTER . . . . . .  B ADDR   00C0H.7 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
HTIRC_HUMMINGBIRD~  N NUMB   011Dh            
SERVOKING_MONSTER~  N NUMB   010Eh            
OVERSKY_MR_20A_PR~  N NUMB   00FEh            
FLYCOLOR_RAPTOR_2~  N NUMB   00D4h            
TURNIGY_KFORCE_12~  N NUMB   0057h            
TURNIGY_PLUSH_60A~  N NUMB   0032h            
PUT4 . . . . . . .  C ADDR   1D8AH   A 
MAI6 . . . . . . .  C ADDR   1D49H   A 
CNTH . . . . . . .    REG    R7             
WRITE_EEPROM_BLOC~  C ADDR   163BH   A 
NORMAL_RUN_CHECKS.  C ADDR   1507H   A 
INIT_NO_SIGNAL . .  C ADDR   1117H   A 
WAIT_MS_1_M_M1 . .  C ADDR   0FF7H   A 
COMM45_NONDAMP_REV  C ADDR   0DBFH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0B5BH   A 
WAIT_ADVANCE_TIMI~  C ADDR   0A2AH   A 
CALC_NEW_WAIT_PER~  C ADDR   0994H   A 
CALC_GOVERNOR_PRO~  C ADDR   0692H   A 
PCA_INT_PPM_UNIDI~  C ADDR   04CBH   A 
T2_INT_PPM_TIMEOU~  C ADDR   01B1H   A 
PWM_BFET_EXIT. . .  C ADDR   0115H   A 
T0_INT_PWM_OFF_EX~  C ADDR   00CFH   A 
_EEP_PGM_GOV_I_GA~  C ADDR   1A04H   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_BRAKE~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_COM . . . . .  N NUMB   0000h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
OVERSKY_MR_20A_PR~  N NUMB   00FFh            
FLYCOLOR_RAPTOR_2~  N NUMB   00D5h            
POLARIS_THUNDER_1~  N NUMB   0098h            
ALIGN_RCE_BL35P_M~  N NUMB   0073h            
TURNIGY_PLUSH_60A~  N NUMB   0033h            
TURNIGY_PLUSH_25A~  N NUMB   0029h            
POLYNOM. . . . . .  N NUMB   A001h            
WRITE_EEPROM_BLOC~  C ADDR   1649H   A 
PROGRAM_BY_TX_ENT~  C ADDR   1302H   A 
READ_ALL_EEPROM_P~  C ADDR   15D6H   A 
WAIT_MS_1_M_M2 . .  C ADDR   101EH   A 
COMM23_NFET_DONE_~  C ADDR   0D28H   A 
SETUP_ZC_SCAN_TIM~  C ADDR   0B20H   A 
CALC_NEXT_COMM_NE~  C ADDR   0973H   A 
CALC_NEXT_COMM_ST~  C ADDR   08FCH   A 
PWM_CFET_EXIT. . .  C ADDR   011FH   A 
T0_INT . . . . . .  C ADDR   00A8H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A18H   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
SKIP_T2H_INT . . .  D ADDR   0078H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006BH   A 
RCP_STOP_CNT . . .  D ADDR   005FH   A 
NEW_RCP. . . . . .  D ADDR   005CH   A 
RCP_PREV_PERIOD_L.  D ADDR   0059H   A 
WT_COMM_START_L. .  D ADDR   0053H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
INITIAL_RUN_PHASE.  N NUMB   0002h            
HIGH_RPM . . . . .  N NUMB   0006h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00F0h            
DEBUGPIN . . . . .  N NUMB   0000h            
ANFET. . . . . . .  N NUMB   0004h            
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
TBS_CUBE_12A_MAIN.  N NUMB   0100h            
ROTORGEEKS_20A_PL~  N NUMB   00C7h            
POLARIS_THUNDER_1~  N NUMB   0099h            
TURNIGY_PLUSH_80A~  N NUMB   0035h            
TURNIGY_PLUSH_25A~  N NUMB   002Ah            
INIT_START_BIDIR_~  C ADDR   1444H   A 
WAIT_MS_1_M_M3 . .  C ADDR   1045H   A 
WAIT_MS_1_O_M1 . .  C ADDR   0FF5H   A 
EVAL_COMP_EXIT . .  C ADDR   0C42H   A 
PCA_INT_SET_TIMEO~  C ADDR   054CH   A 
PWM_NOFET. . . . .  C ADDR   0101H   A 
EEP_PGM_PWM_DITHER  C ADDR   1A26H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
PREV_PREV_COMM_L .  D ADDR   003EH   A 
PREV_COMM_H. . . .  D ADDR   003CH   A 
RCP_DIR_REV. . . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0002h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
ACK. . . . . . . .  B ADDR   00C0H.1 A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
F85_3A_TAIL. . . .  N NUMB   00E9h            
FVT_LITTLEBEE_20A~  N NUMB   00DCh            
MDRX62H_MAIN . . .  N NUMB   00C1h            
TURNIGY_PLUSH_80A~  N NUMB   0036h            
TURNIGY_PLUSH_18A~  N NUMB   0026h            
XP_12A_MAIN. . . .  N NUMB   000Ah            
PUTW . . . . . . .  C ADDR   1D4BH   A 
PARAL. . . . . . .    REG    R2             
BOOTLOADER_DONE. .  C ADDR   112DH   A 
WAIT_MS_1_O_M2 . .  C ADDR   101CH   A 
AVERAGE_THROTTLE .  C ADDR   0FB6H   A 
DECODE_PARAMS_DIR~  C ADDR   0F13H   A 
COMM61_NFET_DONE_~  C ADDR   0E74H   A 
COMM34_NFET_DONE_~  C ADDR   0D57H   A 
SETUP_COMM_WAIT. .  C ADDR   0C06H   A 
CALC_NEXT_COMM_TI~  C ADDR   09DEH   A 
CHECK_VOLTAGE_LIM.  C ADDR   089FH   A 
CALC_GOVERNOR_INT~  C ADDR   072BH   A 
T2_INT . . . . . .  C ADDR   0154H   A 
_PGM_DAMPING_FORCE  I ADDR   0093H   A 
AUTO_BAILOUT_ARMED  D ADDR   0060H   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0000h            
APFET. . . . . . .  N NUMB   0005h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
SERVOKING_MONSTER~  N NUMB   0113h            
F85_3A_MULTI . . .  N NUMB   00EAh            
FVT_LITTLEBEE_30A~  N NUMB   00E2h            
FVT_LITTLEBEE_12A~  N NUMB   00D9h            
FLYCOLOR_FAIRY_30~  N NUMB   00CEh            
ROTORGEEKS_20A_TA~  N NUMB   00C5h            
ALIGN_RCE_BL15P_T~  N NUMB   006Eh            
RCTIMER_6A_MAIN. .  N NUMB   0067h            
TURNIGY_PLUSH_NFE~  N NUMB   003Dh            
TURNIGY_PLUSH_18A~  N NUMB   0027h            
DP_3A_TAIL . . . .  N NUMB   0017h            
XP_7A_FAST_MAIN. .  N NUMB   0007h            
GET1 . . . . . . .  C ADDR   1D97H   A 
BYTE_REG . . . . .  D ADDR   0021H   A 
CNTL . . . . . . .    REG    R6             
STORE_TAIL_FUNC_1.  C ADDR   16C3H   A 
ARM_END_BEEP . . .  C ADDR   1339H   A 
THROTTLE_HIGH_CAL~  C ADDR   1276H   A 
PGM_START. . . . .  C ADDR   1059H   A 
WAIT_MS_1_O_M3 . .  C ADDR   1043H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0B3CH   A 
CALC_NEW_WAIT_TIM~  C ADDR   0A3AH   A 
LOAD_MIN_TIME. . .  C ADDR   09D8H   A 
SET_STARTUP_PWM. .  C ADDR   08A8H   A 
GOVERNOR_STORE_IN~  C ADDR   0725H   A 
T2H_INT_EXIT . . .  C ADDR   02B7H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   02C1H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0075H   A 
ADC_CONVERSION_CNT  D ADDR   0070H   A 
GOV_ARM_TARGET . .  D ADDR   004CH   A 
RCP_PPM. . . . . .  N NUMB   0004h            
RCP_OUTSIDE_RANGE~  D ADDR   0029H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
BPFET. . . . . . .  N NUMB   0003h            
ADC_LIMIT_L. . . .  N NUMB   0085h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TXMODE . . . . . .  B ADDR   00C0H.6 A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SERVOKING_MONSTER~  N NUMB   0114h            
GRAUPNER_ULTRA_20~  N NUMB   00E5h            
FLYCOLOR_FAIRY_30~  N NUMB   00CFh            
ROTORGEEKS_20A_MU~  N NUMB   00C6h            
EMAX_20A_MAIN. . .  N NUMB   00ACh            
TAROT_30A_MAIN . .  N NUMB   00A6h            
ALIGN_RCE_BL15P_M~  N NUMB   006Fh            
DP_3A_MULTI. . . .  N NUMB   0018h            
GET2 . . . . . . .  C ADDR   1DACH   A 
FUNC_PARAVAL . . .  C ADDR   1787H   A 
WAIT1S_LOOP. . . .  C ADDR   16F5H   A 
STORE_TAIL_FUNC_2.  C ADDR   16C8H   A 
RUN6_CHECK_DIR_REV  C ADDR   154EH   A 
MUSIC_F1_BEEP. . .  C ADDR   0FE6H   A 
AVERAGE_THROTTLE_~  C ADDR   0FD5H   A 
COMP_CHECK_TIMEOUT  C ADDR   0B82H   A 
CALC_GOVERNOR_PRO~  C ADDR   0788H   A 
GOVERNOR_INT_MIN_~  C ADDR   0720H   A 
GOVERNOR_LIMIT_PR~  C ADDR   06C5H   A 
BEEP_F1. . . . . .  C ADDR   059BH   A 
PCA_INT_PPM_OUTSI~  C ADDR   0465H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   0071H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0064H   A 
PWM_LIMIT. . . . .  D ADDR   0061H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0001h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
ACKRQ. . . . . . .  B ADDR   00C0H.3 A 
TMR3L. . . . . . .  D ADDR   0094H   A 
FLYCOLOR_FAIRY_V2~  N NUMB   00D0h            
ALIGN_RCE_BL35P_T~  N NUMB   0074h            
GET3 . . . . . . .  C ADDR   1DD0H   A 
BL_FLASH_KEY_1 . .  D ADDR   0029H   A 
STORE_TAIL_FUNC_3.  C ADDR   16CDH   A 
INITIAL_RUN_PHASE~  C ADDR   1527H   A 
MUSIC_F2_BEEP. . .  C ADDR   100DH   A 
TEST_THROTTLE_GAIN  C ADDR   0FA7H   A 
COMM23_FETS_DONE_~  C ADDR   0CF7H   A 
GOVERNOR_STORE_PR~  C ADDR   0786H   A 
GOVERNOR_CHECK_PR~  C ADDR   074AH   A 
MULT_S16_BY_U8_PO~  C ADDR   0654H   A 
DIV_U16_BY_U16 . .  C ADDR   0602H   A 
BEEP_ONOFF . . . .  C ADDR   05BFH   A 
BEEP_F2. . . . . .  C ADDR   05A2H   A 
PCA_INT_PPM_BIDIR~  C ADDR   04B2H   A 
PCA_INT_CHECK_DIFF  C ADDR   03F9H   A 
T2_INT_SKIP_START.  C ADDR   01B5H   A 
PWM_AFET . . . . .  C ADDR   0103H   A 
T0_INT_PWM_OFF_FU~  C ADDR   00F8H   A 
EEP_PGM_ENABLE_PO~  C ADDR   1A24H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0015h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
PREV_COMM_L. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNTD .  D ADDR   002AH   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
TBS_CUBE_12A_TAIL.  N NUMB   0101h            
ROTORGEEKS_20A_PL~  N NUMB   00C8h            
XROTOR_10A_MAIN. .  N NUMB   00B8h            
EMAX_40A_MAIN. . .  N NUMB   00AFh            
ALIGN_RCE_BL35P_M~  N NUMB   0075h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ah            
TURNIGY_KFORCE_70~  N NUMB   004Fh            
TURNIGY_KFORCE_40~  N NUMB   004Ch            
XP_25A_MAIN. . . .  N NUMB   0010h            
INIT . . . . . . .  C ADDR   1C00H   A 
BL_FLASH_KEY_2 . .  D ADDR   002AH   A 
PARAVAL_NO_ENTRY .  C ADDR   1781H   A 
STORE_TAIL_FUNC_4.  C ADDR   16D2H   A 
RUN6_BRAKE_DONE. .  C ADDR   1567H   A 
SUCCESS_BEEP_INVE~  C ADDR   172AH   A 
SUCCESS_BEEP . . .  C ADDR   16FBH   A 
MUSIC_F3_BEEP. . .  C ADDR   1034H   A 
FIND_THROTTLE_GAIN  C ADDR   0F7FH   A 
DECODE_SETTINGS. .  C ADDR   0F31H   A 
COMM56_NFET_DONE_~  C ADDR   0DFDH   A 
RUN_TO_WAIT_FOR_P~  C ADDR   1585H   A 
TEMP_AVERAGE_INC_~  C ADDR   085AH   A 
GOVERNOR_INT_MAX_~  C ADDR   0718H   A 
GOVERNOR_LIMIT_IN~  C ADDR   06F8H   A 
BEEP_F3. . . . . .  C ADDR   05A9H   A 
PCA_INT_FAIL_MINI~  C ADDR   0312H   A 
PWM_BFET . . . . .  C ADDR   010DH   A 
T0_INT_PWM_OFF_EX~  C ADDR   00F1H   A 
_EEP_PGM_GOV_P_GA~  C ADDR   1A03H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0069H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
SKIP_DAMP_ON . . .  N NUMB   0007h            
P1_INIT. . . . . .  N NUMB   00C0h            
RTX_SKIP . . . . .  N NUMB   00D4h            
TEMP_LIMIT . . . .  N NUMB   006Dh            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
TBS_CUBE_12A_MULTI  N NUMB   0102h            
FVT_LITTLEBEE_20A~  N NUMB   00DDh            
ROTORGEEKS_20A_PL~  N NUMB   00C9h            
MDRX62H_TAIL . . .  N NUMB   00C2h            
XROTOR_20A_MAIN. .  N NUMB   00BBh            
EMAX_LIGHTNING_20~  N NUMB   00B5h            
PLATINUM_PRO_150A~  N NUMB   009Dh            
TURNIGY_PLUSH_NFE~  N NUMB   003Ah            
XP_12A_TAIL. . . .  N NUMB   000Bh            
UART_LOOP. . . . .  N NUMB   001Ah            
STORE_TAIL_FUNC_5.  C ADDR   16D7H   A 
BEEP_DELAY_SET . .  C ADDR   1371H   A 
PROGRAM_BY_TX_ENT~  C ADDR   125CH   A 
LOCK_BYTE_OK . . .  C ADDR   107EH   A 
AVERAGE_THROTTLE_~  C ADDR   0FC6H   A 
DECODE_PWM_FREQ_L~  C ADDR   0F2BH   A 
COMM61_FETS_DONE_~  C ADDR   0E43H   A 
COMP_READ_WRONG_L~  C ADDR   0BD9H   A 
SET_PWM_LIMIT_LOW~  C ADDR   0811H   A 
BEEP_F4. . . . . .  C ADDR   05B0H   A 
PCA_INT_PPM_MAX_C~  C ADDR   04F8H   A 
PCA_INT_RESTORE_E~  C ADDR   03E3H   A 
T2_INT_CURRENT_PW~  C ADDR   027AH   A 
PWM_CFET . . . . .  C ADDR   0117H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A7H   A 
_PGM_STARTUP_METH~  I ADDR   0095H   A 
_PGM_VOLT_COMP . .  I ADDR   0091H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0005h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
DAMPED_MODE_ENABLE  N NUMB   0000h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
HTIRC_HUMMINGBIRD~  N NUMB   0118h            
FVT_LITTLEBEE_30A~  N NUMB   00E3h            
FVT_LITTLEBEE_20A~  N NUMB   00DEh            
FVT_LITTLEBEE_12A~  N NUMB   00DAh            
MDRX62H_MULTI. . .  N NUMB   00C3h            
H_KING_10A_MAIN. .  N NUMB   0079h            
ALIGN_RCE_BL35X_M~  N NUMB   0070h            
RCTIMER_6A_TAIL. .  N NUMB   0068h            
TURNIGY_PLUSH_NFE~  N NUMB   003Eh            
XP_18A_MAIN. . . .  N NUMB   000Dh            
XP_12A_MULTI . . .  N NUMB   000Ch            
XP_7A_FAST_TAIL. .  N NUMB   0008h            
PROGRAM_BY_TX_EXIT  C ADDR   17E5H   A 
STORE_TAIL_FUNC_6.  C ADDR   16DCH   A 
READ_EEPROM_BYTE .  C ADDR   165AH   A 
THROTTLE_LOW_CAL .  C ADDR   12B2H   A 
COMP_READ_WRONG. .  C ADDR   0BA1H   A 
STORE_TIMES_UP_OR~  C ADDR   0AD6H   A 
STORE_TIMES_DECRE~  C ADDR   0AE4H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0872H   A 
SET_PWM_LIMIT_HIG~  C ADDR   0825H   A 
GOVERNOR_APPLY_IN~  C ADDR   07BAH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0755H   A 
BEEP_OFF . . . . .  C ADDR   05F8H   A 
WAIT10MS . . . . .  C ADDR   057CH   A 
T2_INT_CURRENT_PW~  C ADDR   0258H   A 
PWM_AFET_DAMPED_E~  C ADDR   0130H   A 
T0_INT_PWM_ON_EXIT  C ADDR   00B7H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Eh            
PGM_PWM_DITHER . .  I ADDR   00A3H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0074H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
P0_SKIP. . . . . .  N NUMB   00EFh            
DEFAULT_PGM_MAIN_~  N NUMB   000Ah            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
STO. . . . . . . .  B ADDR   00C0H.4 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
HTIRC_HUMMINGBIRD~  N NUMB   0115h            
SERVOKING_MONSTER~  N NUMB   010Fh            
DALRC_XR20A_MAIN .  N NUMB   0103h            
GRAUPNER_ULTRA_20~  N NUMB   00E6h            
FVT_LITTLEBEE_30A~  N NUMB   00E4h            
FVT_LITTLEBEE_12A~  N NUMB   00DBh            
XROTOR_40A_MAIN. .  N NUMB   00BEh            
EMAX_20A_TAIL. . .  N NUMB   00ADh            
TAROT_30A_TAIL . .  N NUMB   00A7h            
H_KING_20A_MAIN. .  N NUMB   007Ch            
RCTIMER_6A_MULTI .  N NUMB   0069h            
HIMODEL_COOL_22A_~  N NUMB   005Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0037h            
XP_7A_FAST_MULTI .  N NUMB   0009h            
GETW . . . . . . .  C ADDR   1D8EH   A 
STORE_TAIL_FUNC_7.  C ADDR   16E1H   A 
READ_TAG . . . . .  C ADDR   16A6H   A 
RESET_CAL_DONE . .  C ADDR   10A7H   A 
MUSIC_F1 . . . . .  C ADDR   0FE4H   A 
DECODE_PARAMETERS.  C ADDR   0EFDH   A 
COMM45_FETS_DONE_~  C ADDR   0D9DH   A 
COMM23_NFET_OFF. .  C ADDR   0CD5H   A 
SETUP_ZC_SCAN_TIM~  C ADDR   0AFCH   A 
STORE_TIMES_INCRE~  C ADDR   0A85H   A 
MEASURE_LIPO_CELLS  C ADDR   082AH   A 
CALC_GOVERNOR_INT~  C ADDR   06CEH   A 
PCA_INT_PPM_CALCU~  C ADDR   0494H   A 
PCA_INT_EXIT . . .  C ADDR   0560H   A 
T2_INT_RCP_UPDATE~  C ADDR   01DDH   A 
PWM_BFET_DAMPED_E~  C ADDR   0141H   A 
RCP_PERIOD_DIFF_A~  D ADDR   005BH   A 
COMPARATOR_READ_C~  D ADDR   0043H   A 
STARTUP_CNT. . . .  D ADDR   0033H   A 
PWM_TIMER0_OVERFL~  N NUMB   0003h            
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   00C0h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
ARBLOST. . . . . .  B ADDR   00C0H.2 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
TMR3CN . . . . . .  D ADDR   0091H   A 
AIKON_BOLTLITE_30~  N NUMB   0106h            
OVERSKY_MR_20A_MA~  N NUMB   00FAh            
GRAUPNER_ULTRA_20~  N NUMB   00E7h            
FLYCOLOR_FAIRY_V2~  N NUMB   00D1h            
EMAX_20A_MULTI . .  N NUMB   00AEh            
TAROT_30A_MULTI. .  N NUMB   00A8h            
HIMODEL_COOL_41A_~  N NUMB   0064h            
TURNIGY_PLUSH_6A_~  N NUMB   001Ch            
GETX . . . . . . .  C ADDR   1D9CH   A 
STORE_TAIL_FUNC_8.  C ADDR   16E6H   A 
RUN6_CHECK_SPEED .  C ADDR   155DH   A 
WAIT_FOR_POWER_ON~  C ADDR   13A0H   A 
MUSIC_F2 . . . . .  C ADDR   100BH   A 
SWITCH_POWER_OFF .  C ADDR   0E7CH   A 
COMP_READ_WRONG_N~  C ADDR   0BADH   A 
CALC_NEW_WAIT_PER~  C ADDR   09B0H   A 
WAIT30MS . . . . .  C ADDR   0581H   A 
PCA_INT_PPM_BIDIR~  C ADDR   04E9H   A 
PCA_INT_CHECK_1KHZ  C ADDR   03D2H   A 
T2H_INT. . . . . .  C ADDR   028BH   A 
PWM_CFET_DAMPED_E~  C ADDR   0152H   A 
GOV_INTEGRAL_X . .  D ADDR   0048H   A 
COMP_TIMED_OUT . .  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   0028h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
FLYCOLOR_FAIRY_V2~  N NUMB   00D2h            
XROTOR_10A_TAIL. .  N NUMB   00B9h            
EMAX_40A_TAIL. . .  N NUMB   00B0h            
EAZY_3AV2_MAIN . .  N NUMB   00A3h            
ALIGN_RCE_BL15X_T~  N NUMB   006Bh            
HIMODEL_COOL_33A_~  N NUMB   0061h            
TURNIGY_KFORCE_70~  N NUMB   0050h            
TURNIGY_KFORCE_40~  N NUMB   004Dh            
XP_25A_TAIL. . . .  N NUMB   0011h            
RST. . . . . . . .  C ADDR   1CC6H   A 
SUCCESS. . . . . .  N NUMB   0030h            
BOOT_VERSION . . .  N NUMB   0006h            
XTAL . . . . . . .  N NUMB   17D7840h            
FUNC_PARAVAL_CONT~  C ADDR   17B4H   A 
STORE_TAIL_FUNC_9.  C ADDR   16EBH   A 
WRITE_TAGS . . . .  C ADDR   16B0H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   158DH   A 
WAIT1S . . . . . .  C ADDR   16F3H   A 
MUSIC_F3 . . . . .  C ADDR   1032H   A 
COMM61_NFET_OFF. .  C ADDR   0E21H   A 
EVAL_COMP_CHECK_T~  C ADDR   0C32H   A 
ADJUST_TIMING_TWO~  C ADDR   0A6CH   A 
INITIALIZE_TIMING.  C ADDR   08C8H   A 
CHECK_VOLTAGE_RET.  C ADDR   08A7H   A 
WAITXMS_M. . . . .  C ADDR   0592H   A 
PCA_INT_CHECK_2KHZ  C ADDR   03C1H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
WT_ADV_START_H . .  D ADDR   004EH   A 
GOV_TARGET_H . . .  D ADDR   0045H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
PX1. . . . . . . .  B ADDR   00B8H.2 A 
IP . . . . . . . .  D ADDR   00B8H   A 
XROTOR_20A_TAIL. .  N NUMB   00BCh            
XROTOR_10A_MULTI .  N NUMB   00BAh            
EMAX_LIGHTNING_20~  N NUMB   00B6h            
EMAX_40A_MULTI . .  N NUMB   00B1h            
SKYIII_30A_MAIN. .  N NUMB   00A9h            
PLATINUM_PRO_150A~  N NUMB   009Eh            
POLARIS_THUNDER_2~  N NUMB   0088h            
H_KING_50A_MAIN. .  N NUMB   0082h            
GAUI_GE_183_18A_M~  N NUMB   0076h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ch            
TURNIGY_KFORCE_70~  N NUMB   0051h            
TURNIGY_KFORCE_40~  N NUMB   004Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Bh            
XP_25A_MULTI . . .  N NUMB   0012h            
EXIT . . . . . . .  C ADDR   1CB7H   A 
BOOT_MSG . . . . .  C ADDR   1DEFH   A 
READ_INITIAL_TEMP.  C ADDR   13F9H   A 
WAIT_FOR_POWER_ON~  C ADDR   1394H   A 
PROGRAM_BY_TX_ENT~  C ADDR   12F9H   A 
DECODE_PWM_FREQ_E~  C ADDR   0F30H   A 
WAIT_FOR_COMM_WAIT  C ADDR   0C79H   A 
START_ADC_CONVERS~  C ADDR   082EH   A 
MULT_S16_BY_U8_EX~  C ADDR   0688H   A 
PCA_INT_PPM_LIMIT~  C ADDR   050AH   A 
T2H_INT_RCP_GOV_P~  C ADDR   02B7H   A 
T2_INT_PWM_MIN_RUN  C ADDR   0205H   A 
PWM_DITHER_TABLE .  C ADDR   009AH   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
PGM_ENABLE_POWER_~  I ADDR   00A1H   A 
PWM_DITHER_DECODED  D ADDR   0066H   A 
PWM_LIMIT_BY_RPM .  D ADDR   0063H   A 
LOW_RPM_PWR_SLOPE.  D ADDR   0039H   A 
INITIAL_RUN_ROT_C~  D ADDR   0035H   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
MUX_A. . . . . . .  N NUMB   0005h            
PFETON_DELAY . . .  N NUMB   0005h            
HIGH_BEC_VOLTAGE .  N NUMB   0000h            
PSW. . . . . . . .  D ADDR   00D0H   A 
HTIRC_HUMMINGBIRD~  N NUMB   0119h            
ALIGN_MR25_15A_MA~  N NUMB   0109h            
XROTOR_20A_MULTI .  N NUMB   00BDh            
EMAX_LIGHTNING_20~  N NUMB   00B7h            
PLATINUM_PRO_150A~  N NUMB   009Fh            
POLARIS_THUNDER_3~  N NUMB   008Bh            
POLARIS_THUNDER_1~  N NUMB   0085h            
H_KING_10A_TAIL. .  N NUMB   007Ah            
ALIGN_RCE_BL35X_T~  N NUMB   0071h            
TURNIGY_PLUSH_NFE~  N NUMB   003Ch            
XP_18A_TAIL. . . .  N NUMB   000Eh            
WAITF. . . . . . .  C ADDR   1DDCH   A 
BOOT_BAUDRATE. . .  N NUMB   4B00h            
STORE_IN_RAM_EXIT.  C ADDR   16F0H   A 
VALIDATE_RCP_START  C ADDR   11F8H   A 
LOCK_BYTE_TEST . .  C ADDR   1077H   A 
COMM45_NFET_OFF. .  C ADDR   0D7BH   A 
COMM12_REV . . . .  C ADDR   0CA3H   A 
COMM1COMM2 . . . .  C ADDR   0C8AH   A 
COMP_READ_WRONG_L~  C ADDR   0BE6H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0AF4H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0870H   A 
TEMP_AVERAGE_DEC .  C ADDR   0866H   A 
CALC_GOVERNOR_PRO~  C ADDR   072CH   A 
WAITXMS_O. . . . .  C ADDR   0590H   A 
PCA_INT_PPM_TIMEO~  C ADDR   0555H   A 
PCA_INT_CHECK_4KHZ  C ADDR   03B0H   A 
T0_INT_PWM_OFF . .  C ADDR   00C5H   A 
TX_PGM_PARAMS_TAIL  C ADDR   009FH   A 
EEPROM_FW_SUB_REV~  N NUMB   004Bh            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   004AH   A 
DEFAULT_PGM_MULTI~  N NUMB   0050h            
MUX_B. . . . . . .  N NUMB   0007h            
RCP_IN . . . . . .  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   000Ah            
ONE_S_CAPABLE. . .  N NUMB   0000h            
ADC0GTH. . . . . .  D ADDR   00C4H   A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
HTIRC_HUMMINGBIRD~  N NUMB   011Ah            
HTIRC_HUMMINGBIRD~  N NUMB   0116h            
SERVOKING_MONSTER~  N NUMB   0110h            
DALRC_XR20A_TAIL .  N NUMB   0104h            
DYS_XM20A_MAIN . .  N NUMB   00F7h            
XROTOR_40A_TAIL. .  N NUMB   00BFh            
POLARIS_THUNDER_4~  N NUMB   008Eh            
H_KING_20A_TAIL. .  N NUMB   007Dh            
H_KING_10A_MULTI .  N NUMB   007Bh            
ALIGN_RCE_BL35X_M~  N NUMB   0072h            
HIMODEL_COOL_22A_~  N NUMB   005Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0038h            
XP_18A_MULTI . . .  N NUMB   000Fh            
PUTC . . . . . . .  C ADDR   1D6FH   A 
BIT_REG. . . . . .  D ADDR   0020H   A 
CMDH . . . . . . .    REG    R5             
READ_EEPROM_EXIT .  C ADDR   1617H   A 
WAIT_FOR_POWER_ON~  C ADDR   134EH   A 
INPUT_HIGH_CHECK_1  C ADDR   1121H   A 
CHECK_VOLTAGE_STA~  C ADDR   0898H   A 
SET_PWM_LIMIT_LOW~  C ADDR   07E4H   A 
CALC_GOVERNOR_INT~  C ADDR   07E3H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0701H   A 
MULT_S16_BY_U8_DI~  C ADDR   066DH   A 
BEEP . . . . . . .  C ADDR   05B7H   A 
PCA_INT_PPM_BIDIR~  C ADDR   04B7H   A 
PCA_INT_FALL . . .  C ADDR   0414H   A 
T2_INT_SKIP_END. .  C ADDR   01C0H   A 
EEP_PGM_TEMP_PROT~  C ADDR   1A23H   A 
_EEP_PGM_THROTTLE~  C ADDR   1A1EH   A 
_EEP_PGM_STARTUP_~  C ADDR   1A12H   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A6H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006CH   A 
COMM_PHASE . . . .  D ADDR   0042H   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
MUX_C. . . . . . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   000Ah            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
SI . . . . . . . .  B ADDR   00C0H.0 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
HTIRC_HUMMINGBIRD~  N NUMB   0117h            
SERVOKING_MONSTER~  N NUMB   0111h            
AIKON_BOLTLITE_30~  N NUMB   0107h            
DALRC_XR20A_MULTI.  N NUMB   0105h            
OVERSKY_MR_20A_TA~  N NUMB   00FBh            
XROTOR_40A_MULTI .  N NUMB   00C0h            
EMAX_NANO_20A_MAIN  N NUMB   00B2h            
PLATINUM_50AV3_MA~  N NUMB   00A0h            
H_KING_35A_MAIN. .  N NUMB   007Fh            
H_KING_20A_MULTI .  N NUMB   007Eh            
HIMODEL_COOL_41A_~  N NUMB   0065h            
HIMODEL_COOL_22A_~  N NUMB   0060h            
TURNIGY_PLUSH_NFE~  N NUMB   0039h            
TURNIGY_PLUSH_6A_~  N NUMB   001Dh            
WAITH. . . . . . .  C ADDR   1DE0H   A 
ERASE_FLASH. . . .  C ADDR   167AH   A 
RUN_TO_WAIT_FOR_P~  C ADDR   1590H   A 
PROGRAM_BY_TX. . .  C ADDR   1778H   A 
INPUT_HIGH_CHECK_2  C ADDR   1123H   A 
COMM23_NONDAMP . .  C ADDR   0CFFH   A 
COMM2COMM3 . . . .  C ADDR   0CB9H   A 
CALC_NEXT_COMM_AV~  C ADDR   0957H   A 
GOVERNOR_STORE_IN~  C ADDR   07E1H   A 
GOVERNOR_CHECK_IN~  C ADDR   07A3H   A 
GOVERNOR_CORR_PRO~  C ADDR   0773H   A 
PWM_AFET_DAMPED. .  C ADDR   0121H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_ADV_START_L . .  D ADDR   004DH   A 
GOV_TARGET_L . . .  D ADDR   0044H   A 
DEMAG_PWR_OFF_THR~  D ADDR   0038H   A 
STARTUP_ZC_TIMEOU~  D ADDR   0034H   A 
FLAGS0 . . . . . .  D ADDR   002CH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
P1_PUSHPULL. . . .  N NUMB   003Fh            
P0_DIGITAL . . . .  N NUMB   FFFFFFDCh            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
AIKON_BOLTLITE_30~  N NUMB   0108h            
OVERSKY_MR_20A_MU~  N NUMB   00FCh            
EAZY_3AV2_TAIL . .  N NUMB   00A4h            
POLARIS_THUNDER_6~  N NUMB   0091h            
HIMODEL_COOL_41A_~  N NUMB   0066h            
HIMODEL_COOL_33A_~  N NUMB   0062h            
TURNIGY_AE_20A_MA~  N NUMB   0040h            
TURNIGY_PLUSH_6A_~  N NUMB   001Eh            
XP_35A_SW_MAIN . .  N NUMB   0013h            
ID1. . . . . . . .  C ADDR   1C4AH   A 
FUNC_PARAVAL_STORE  C ADDR   17A7H   A 
WRITE_EEPROM_BYTE~  C ADDR   165FH   A 
READ_EEPROM_BLOCK1  C ADDR   15FFH   A 
READ_EEPROM_READ .  C ADDR   15F8H   A 
COMM23_DAMP_REV. .  C ADDR   0CDFH   A 
CALC_NEW_WAIT_TIM~  C ADDR   0AB6H   A 
LOAD_MIN_TIME_FAST  C ADDR   0A24H   A 
MEASURE_LIPO_EXIT.  C ADDR   082DH   A 
GOVERNOR_LIMIT_PR~  C ADDR   075BH   A 
GOVERNOR_CHECK_PR~  C ADDR   06B2H   A 
PCA_INT_SECOND_ME~  C ADDR   033BH   A 
T2H_INT_RCP_STOP_~  C ADDR   029AH   A 
PWM_BFET_DAMPED. .  C ADDR   0132H   A 
PCA_INT. . . . . .  C ADDR   02D4H   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
FLAGS1 . . . . . .  D ADDR   002DH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0001h            
P1_DIGITAL . . . .  N NUMB   003Fh            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
ZTW_SPIDER_PRO_20~  N NUMB   00F1h            
FLYCOLOR_FAIRY_6A~  N NUMB   00CAh            
SKYIII_30A_TAIL. .  N NUMB   00AAh            
EAZY_3AV2_MULTI. .  N NUMB   00A5h            
POLARIS_THUNDER_2~  N NUMB   0089h            
H_KING_50A_TAIL. .  N NUMB   0083h            
GAUI_GE_183_18A_T~  N NUMB   0077h            
HIMODEL_COOL_33A_~  N NUMB   0063h            
TURNIGY_AE_30A_MA~  N NUMB   0046h            
BOOT_INFO. . . . .  C ADDR   1DF3H   A 
ERRORVERIFY. . . .  N NUMB   00C0h            
READ_EEPROM_BLOCK2  C ADDR   160DH   A 
MEASURE_PWM_FREQ_~  C ADDR   1195H   A 
COMM61_NONDAMP . .  C ADDR   0E4BH   A 
COMM6COMM1 . . . .  C ADDR   0E05H   A 
COMM34_REV . . . .  C ADDR   0D49H   A 
COMM3COMM4 . . . .  C ADDR   0D30H   A 
COMP_CHECK_TIMEOU~  C ADDR   0B93H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0B4DH   A 
GOVERNOR_CORR_PRO~  C ADDR   0784H   A 
PCA_INT_PPM_BIDIR~  C ADDR   04ABH   A 
PCA_INT_CHECK_8KHZ  C ADDR   039FH   A 
T2_INT_CURRENT_PW~  C ADDR   0271H   A 
PWM_CFET_DAMPED. .  C ADDR   0143H   A 
_EEP_PGM_MAIN_SPO~  C ADDR   1A22H   A 
_EEP_PGM_LOW_VOLT~  C ADDR   1A06H   A 
DAMPINGFET . . . .  D ADDR   007BH   A 
WT_ZC_SCAN_START_H  D ADDR   0050H   A 
GOV_PROP_PWM . . .  D ADDR   004BH   A 
GOV_PROPORTIONAL_L  D ADDR   0049H   A 
PREV_COMM_X. . . .  D ADDR   003DH   A 
FLAGS2 . . . . . .  D ADDR   002EH   A 
DEMAG_DETECTED . .  N NUMB   0004h            
CURRENT_PWM_LIM_D~  D ADDR   0026H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
MCU_48MHZ. . . . .  N NUMB   0000h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
ALIGN_MR25_15A_TA~  N NUMB   010Ah            
ZTW_SPIDER_PRO_30~  N NUMB   00F4h            
ZTW_SPIDER_PRO_20~  N NUMB   00EEh            
FVT_LITTLEBEE_20A~  N NUMB   00DFh            
SKYIII_30A_MULTI .  N NUMB   00ABh            
POLARIS_THUNDER_8~  N NUMB   0094h            
POLARIS_THUNDER_3~  N NUMB   008Ch            
POLARIS_THUNDER_2~  N NUMB   008Ah            
POLARIS_THUNDER_1~  N NUMB   0086h            
H_KING_50A_MULTI .  N NUMB   0084h            
GAUI_GE_183_18A_M~  N NUMB   0078h            
TURNIGY_KFORCE_12~  N NUMB   0052h            
XP_3A_MAIN . . . .  N NUMB   0001h            



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6611    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =    105    ----
   IDATA SIZE       =     88    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)

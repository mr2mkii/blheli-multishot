MACRO ASSEMBLER BLHELI                                      08/30/16 15:04:18 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.18.15.328
OBJECT MODULE PLACED IN OUTPUT\HTIRC_HUMMINGBIRD_30A_PRO_REV14_7.OBJ
ASSEMBLER INVOKED BY: SET(BESCNO=285) OBJECT(OUTPUT\HTIRC_HUMMINGBIRD_30A_PRO_REV14_7.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ;
                         4     ; BLHeli program for controlling brushless motors in helicopters and multirotors
                         5     ;
                         6     ; Copyright 2011, 2012 Steffen Skaug
                         7     ; This program is distributed under the terms of the GNU General Public License
                         8     ;
                         9     ; This file is part of BLHeli.
                        10     ;
                        11     ; BLHeli is free software: you can redistribute it and/or modify
                        12     ; it under the terms of the GNU General Public License as published by
                        13     ; the Free Software Foundation, either version 3 of the License, or
                        14     ; (at your option) any later version.
                        15     ;
                        16     ; BLHeli is distributed in the hope that it will be useful,
                        17     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        18     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        19     ; GNU General Public License for more details.
                        20     ;
                        21     ; You should have received a copy of the GNU General Public License
                        22     ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                        23     ;
                        24     ;**** **** **** **** ****
                        25     ;
                        26     ; The software was initially designed for use with Eflite mCP X, but is now adapted to copters/planes in general
                        27     ;
                        28     ; The software was inspired by and started from from Bernard Konze's BLMC: http://home.versanet.de/~bkonze/blc_6a/blc_6a.htm
                        29     ; And also Simon Kirby's TGY: https://github.com/sim-/tgy
                        30     ;
                        31     ; This file is best viewed with tab width set to 5
                        32     ;
                        33     ; The input signal can be positive 1kHz, 2kHz, 4kHz, 8kHz or 12kHz PWM (e.g. taken from the "resistor tap" on mCPx)
                        34     ; And the input signal can be PPM (1-2ms) or OneShot125 (125-250us) at rates up to several hundred Hz.
                        35     ; The code autodetects the various input modes/frequencies
                        36     ; The code can also be programmed to accept inverted input signal.
                        37     ;
                        38     ; The first lines of the software must be modified according to the chosen environment:
                        39     ; Uncomment the selected ESC and main/tail/multi mode
                        40     ; BESCNO EQU "ESC"_"mode" 						
                        41     ; 
                        42     ;**** **** **** **** ****
                        43     ; Revision history:
                        44     ; - Rev1.0: Initial revision based upon BLHeli for AVR controllers
                        45     ; - Rev2.0: Changed "Eeprom" initialization, layout and defaults
                        46     ;           Various changes and improvements to comparator reading. Now using timer1 for time from pwm on/off
                        47     ;           Beeps are made louder
                        48     ;           Added programmable low voltage limit
                        49     ;           Added programmable damped tail mode (only for 1S ESCs)
                        50     ;           Added programmable motor rotation direction
                        51     ; - Rev2.1: (minor changes by 4712)
                        52     ;		  Added Disable TX Programming by PC Setup Application 
                        53     ;		  therfore changed EEPROM_LAYOUT_REVISION = 8					
                        54     ;		  Added Vdd Monitor as reset source when writing to "EEProm"
                        55     ;		  Changed for use of batch file to assemble, link and make hex files	
                        56     ; - Rev2.2: (minor changes by 4712)
                        57     ;           Added Disable Throttle Re-Arming every motor start by PC Setup Application 
                        58     ; - Rev2.3: (minor changes by 4712)
                        59     ;           Added bugfixed (2x CLR C before j(n)c operations)thx Steffen!			
                        60     ; - Rev2.4: Revisions 2.1 to 2.3 integrated
                        61     ; - Rev3.0: Added PPM (1050us-1866us) as accepted input signal
                        62     ;           Added startup rpm as a programming parameter
                        63     ;           Added startup acceleration as a programming parameter
                        64     ;           Added option for using voltage measurements to compensate motor power
                        65     ;           Added governor target by setup as a governor mode option
                        66     ;           Governor is kept active regardless of rpm
                        67     ;           Smooth governor spoolup/down in arm and setup modes
                        68     ;           Increased governor P and I gain programming ranges
                        69     ;           Increased and changed low voltage limit programming range
                        70     ;           Disabled tx programming entry for all but the first arming sequence after power on
                        71     ;           Made it possible to skip parameters in tx programming by setting throttle midstick
                        72     ;           Made it default not to rearm for every restart
                        73     ; - Rev3.1: Fixed bug that prevented chosen parameter to be set in tx programming
                        74     ; - Rev3.2: ...also updated the EEPROM revision parameter
                        75     ; - Rev3.3: Fixed negative number bug in voltage compensation
                        76     ;           Fixed bug in startup power calculation for non-default power
                        77     ;           Prevented possibility for voltage compensation fighting low voltage limiting
                        78     ;           Applied overall spoolup control to ensure soft spoolup in any mode
                        79     ;           Added a delay of 3 seconds from initiation of main motor stop until new startup is allowed
                        80     ;           Reduced beep power to reduce power consumption for very strong motors/ESCs
                        81     ; - Rev3.4: Fixed bug that prevented full power in governor arm and setup modes
                        82     ;           Increased NFETON_DELAY for XP_7A and XP_12A to allow for more powerful fets
                        83     ;           Increased initial spoolup power, and linked to startup power
                        84     ; - Rev4.0: Fixed bug that made tail tx program beeps very weak
                        85     ;           Added thermal protection feature
                        86     ;           Governor P and I gain ranges are extended up to 8.0x gain
                        87     ;           Startup sequence is aborted upon zero throttle
                        88     ;           Avoided voltage compensation function induced latency for tail when voltage compensation is not enabled
                        89     ;           Improved input signal frequency detection robustness
                        90     ; - Rev4.1: Increased thermal protection temperature limits
                        91     ; - Rev5.0: Added multi(copter) operating mode. TAIL define changed to MODE with three modes: MAIN, TAIL and MULTI
                        92     ;           Added programmable commutation timing
                        93     ;           Added a damped light mode that has less damping, but that can be used with all escs
                        94     ;           Added programmable damping force
                        95     ;           Added thermal protection for startup too
                        96     ;           Added wait beeps when waiting more than 30 sec for throttle above zero (after having been armed)
                        97     ;           Modified tail idling to provide option for very low speeds
                        98     ;           Changed PPM range to 1150-1830us
                        99     ;           Arming sequence is dropped for PPM input, unless it is governor arm mode
                       100     ;           Loss of input signal will immediately stop the motor for PPM input
                       101     ;           Bug corrected in Turnigy Plush 6A voltage measurement setup
                       102     ;           FET switching delays are set for original fets. Stronger/doubled/tripled etc fets may require faster pfet off switching
                       103     ;           Miscellaneous other changes
                       104     ; - Rev6.0: Reverted comparator reading routine to rev5.0 equivalent, in order to avoid tail motor stops
                       105     ;           Added governor range programmability
                       106     ;           Implemented startup retry sequence with varying startup power for multi mode
                       107     ;           In damped light mode, damping is now applied to the active nfet phase for fully damped capable ESCs
                       108     ; - Rev6.1: Added input signal qualification criteria for PPM, to avoid triggering on noise spikes (fix for plush hardware)
                       109     ;           Changed main and multi mode stop criteria. Will now be in run mode, even if RC pulse input is zero
                       110     ;           Fixed bug in commutation that caused rough running in damped light mode
                       111     ;           Miscellaneous other changes
                       112     ; - Rev7.0  Added direct startup mode programmability
                       113     ;           Added throttle calibration. Min>=1000us and Max<=2000us. Difference must be >520us, otherwise max is shifted so that difference=520us
                       114     ;           Added programmable throttle change rate
                       115     ;           Added programmable beep strength, beacon strength and beacon delay
                       116     ;           Reduced power step to full power significantly
                       117     ;           Miscellaneous other changes
                       118     ; - Rev8.0  Added a 2 second delay after power up, to wait for receiver initialization
                       119     ;           Added a programming option for disabling low voltage limit, and made it default for MULTI
                       120     ;           Added programable demag compensation, using the concept of SimonK
                       121     ;           Improved robustness against noisy input signal
                       122     ;           Refined direct startup
                       123     ;           Removed voltage compensation
                       124     ;           Miscellaneous other changes
                       125     ; - Rev9.0  Increased programming range for startup power, and made its default ESC dependent
                       126     ;           Made default startup method ESC dependent
                       127     ;           Even more smooth and gentle spoolup for MAIN, to suit larger helis
                       128     ;           Improved transition from stepped startup to run
                       129     ;           Refined direct startup
                       130     ; - Rev9.1  Fixed bug that changed FW revision after throttle calibration or TX programming
                       131     ; - Rev9.2  Altered timing of throttle calibration in order to work with MultiWii calibration firmware
                       132     ;           Reduced main spoolup time to around 5 seconds
                       133     ;           Changed default beacon delay to 3 minutes
                       134     ; - Rev9.3  Fixed bug in Plush 60/80A temperature reading, that caused failure in operation above 4S
                       135     ;           Corrected temperature limit for HiModel cool 22/33/41A, RCTimer 6A, Skywalker 20/40A, Turnigy AE45A, Plush 40/60/80A. Limit was previously set too high
                       136     ; - Rev9.4  Improved timing for increased maximum rpm limit
                       137     ; - Rev10.0 Added closed loop mode for multi
                       138     ;           Added high/low BEC voltage option (for the ESCs where HW supports it)
                       139     ;           Added method of resetting all programmed parameter values to defaults by TX programming
                       140     ;           Added Turnigy K-force 40A and Turnigy K-force 120A HV ESCs
                       141     ;           Enabled fully damped mode for several ESCs
                       142     ;           Extended startup power range downwards to enable very smooth start for large heli main motors
                       143     ;           Extended damping force with a highest setting
                       144     ;           Corrected temperature limits for F310 chips (Plush 40A and AE 45A)
                       145     ;           Implemented temperature reading average in order to avoid problems with ADC noise on Skywalkers
                       146     ;           Increased switching delays for XP 7A fast, in order to avoid cross conduction of N and P fets
                       147     ;           Miscellaneous other changes
                       148     ; - Rev10.1 Relaxed RC signal jitter requirement during frequency measurement
                       149     ;           Corrected bug that prevented using governor low
                       150     ;           Enabled vdd monitor always, in order to reduce likelihood of accidental overwriting of adjustments
                       151     ;           Fixed bug that caused stop for PPM input above 2048us, and moved upper accepted limit to 2160us
                       152     ; - Rev10.2 Corrected temperature limit for AE20-30/XP7-25, where limit was too high
                       153     ;           Corrected temperature limit for 120HV, where limit was too low
                       154     ;           Fixed bug that caused AE20/25/30A not to run in reverse
                       155     ; - Rev10.3 Removed vdd monitor for 1S capable ESCs, in order to avoid brownouts/resets
                       156     ;           Made auto bailout spoolup for main more smooth
                       157     ; - Rev10.4 Ensured that main spoolup and governor activation will always be smooth, regardless of throttle input
                       158     ;           Added capability to operate on 12kHz input signal too
                       159     ; - Rev11.0 Fixed bug of programming default values for governor in MULTI mode
                       160     ;           Disabled interrupts explicitly some places, to avoid possibilities for unintentional fet switching
                       161     ;           Changed interrupt disable strategy, to always allow pwm interrupts, to avoid noise when running at low rpms
                       162     ;           Added governor middle range for MAIN mode
                       163     ;           Added bidirectional mode for TAIL and MULTI mode with PPM input
                       164     ;           Changed and improved demag compensation
                       165     ;           Miscellaneous other changes
                       166     ; - Rev11.1 Fixed bug of slow acceleration response for MAIN mode running without governor
                       167     ;           Fixed bug with PWM input, where throttle remains high even when zeroing throttle (seen on V922 tail)
                       168     ;           Fixed bug in bidirectional operation, where direction change could cause reset
                       169     ;           Improved autorotation bailout for MAIN
                       170     ;           Reduced min speed back to 1220 erpm
                       171     ;           Misc code cleanups
                       172     ; - Rev11.2 Fixed throttle calibration bug
                       173     ;           Added high side driver precharge for all-nfet ESCs
                       174     ;           Optimized timing in general and for demag compensation in particular
                       175     ;           Auto bailout functionality modified
                       176     ;           Governor is deactivated for throttle inputs below 10%
                       177     ;           Increased beacon delay times
                       178     ; - Rev12.0 Added programmable main spoolup time
                       179     ;           Added programmable temperature protection enable
                       180     ;           Bidirectional mode stop/start improved. Motor is now stopped before starting
                       181     ;           Power is limited for very low rpms (when BEMF is low), in order to avoid sync loss 
                       182     ;           Damped light mode is made more smooth and quiet, particularly at low and high rpms
                       183     ;           Comparator signal qualification scheme is changed
                       184     ;           Demag compensation scheme is significantly changed
                       185     ;           Increased jitter tolerance for PPM frequency measurement
                       186     ;           Fully damped mode removed, and damped light only supported on damped capable ESCs
                       187     ;           Default tail mode changed to damped light
                       188     ;           Miscellaneous other changes
                       189     ; - Rev12.1 Fixed bug in tail code
                       190     ;           Improved startup for Atmel
                       191     ;           Added support for multiple high BEC voltages
                       192     ;           Added support for RPM output
                       193     ; - Rev12.2 Improved running smoothness, particularly for damped light
                       194     ;           Avoiding lockup at full throttle when input signal is noisy
                       195     ;           Avoiding detection of 1-wire programming signal as valid throttle signal
                       196     ; - Rev13.0 Removed stepped start
                       197     ;           Removed throttle change rate and damping force parameters
                       198     ;           Added support for OneShot125
                       199     ;           Improved commutation timing accuracy
                       200     ; - Rev13.1 Removed startup ramp for MULTI
                       201     ;           Improved startup for some odd ESCs
                       202     ; - Rev13.2 Still tweaking startup to make it more reliable and faster for all ESC/motor combos
                       203     ;           Increased deadband for bidirectional operation
                       204     ;           Relaxed signal detection criteria
                       205     ;           Added support for running 48MHz capable SiLabs MCUs at 48MHz
                       206     ;           Added bootlader to SiLabs code
                       207     ;           Miscellaneous other changes
                       208     ; - Rev14.0 Improved running at high timing
                       209     ;           Improved running at high RPMs and increased max RPM limit
                       210     ;           Avoid being locked in bootloader (implemented in Suite 13202)
                       211     ;           Improved reliability of 3D (bidirectional) mode and startup
                       212     ;           Smoother running and greatly reduced step to full power in damped light mode
                       213     ;           Removed low voltage limiting for MULTI
                       214     ;           Added pwm dither parameter
                       215     ;           Added setting for enable/disable of low RPM power protection
                       216     ;           Added setting for enable/disable of PWM input
                       217     ;           Better AFW and damping for some ESCs (that have a slow high side driver)
                       218     ;           Miscellaneous other changes
                       219     ; - Rev14.1 Fixed max throttle calibration bug (for non-oneshot)
                       220     ;           Fixed some closed loop mode bugs
                       221     ;           Relaxed signal jitter requirement for looptimes below 1000
                       222     ;           Added skipping of damping fet switching near max power, for improved high end throttle linearity, using the concept of SimonK
                       223     ;           Improved sync hold at high rpms
                       224     ; - Rev14.2 Added stalled motor shutoff after about 10 seconds (for tail and multi code with PPM input)
                       225     ;           Greatly increased maximum rpm limit, and added rpm limiting at 250k erpm (48MHz MCUs at 400k erpm)
                       226     ;           Improved bidirectional operation
                       227     ; - Rev14.3 Moved reset vector to be just before the settings segment, in order to better recover from partially failed flashing operation
                       228     ;           Added 100ms intialization delay for the Graupner Ultra 20A ESC
                       229     ;           Shortened stall detect time to about 5sec, and prevented going into tx programming after a stall
                       230     ;           Optimizations of software timing and running reliability
                       231     ; - Rev14.4 Improved startup, particularly for larger motors
                       232     ;           Improved running at very high rpms
                       233     ;           Made damped light default for MULTI on ESCs that support it
                       234     ;           Miscellaneous other changes
                       235     ; - Rev14.5 Longer between beacon beeps (to reduce motor heating), and now again beeping on two motor phases
                       236     ;           Implemented programmable brake on zero throttle
                       237     ;           Implemented hardware reload of commutation timers, to reduce sensitivity to interrupt activity on high rpms
                       238     ;           Implemented support for EN/PWM style fet drivers
                       239     ;           Slightly modified throttle calibration
                       240     ;           Improved startup, particularly for small motors
                       241     ;           Improved smoothness
                       242     ; - Rev14.6 Fixed bug that caused tail motor not to stop
                       243     ;           Fixed bug that caused brake not to work for low side pwm ESCs
                       244     ;           Fixed bug where noisy input signal could cause loss of sync
                       245     ;           Increased fet deadtime a bit for the LB20A and the LB20A pro
                       246     ;           Made low rpm power limiting programmable through the startup power parameter
                       247     ; - Rev14.7 Beeps can be turned off by programming beep strength to 1
                       248     ;           Throttle cal difference is checked to be above required minimum before storing. Throttle cal max is not stored until successful min throttle cal
                       249     ;           In order to have a good code for fixed wing planes, that has low voltage limiting, a main code spoolup time setting of 0 is made fast
                       250     ;           Improved protection of bootloader and generally reduced risk of flash corruption
                       251     ;           Some small changes for improved sync hold
                       252     ;	-Rev14.75 Modified input signal accept Multishot protocol
                       253     ;						Changed Defaults to more acceptable/appropriate values	
                       254     ;						Modified beeps to use the "Pit Stop" or "Fast Start" style tones
                       255     ;
                       256     ;**** **** **** **** ****
                       257     ; Up to 8K Bytes of In-System Self-Programmable Flash
                       258     ; Up to 768 Bytes Internal SRAM
                       259     ;
                       260     ;**** **** **** **** ****
                       261     ; Master clock is internal 24MHz oscillator (or 48MHz, for which the times below are halved)
                       262     ; Timer 0 (167/500ns counts) always counts up and is used for
                       263     ; - PWM generation
                       264     ; Timer 2 (500ns counts) always counts up and is used for
                       265     ; - RC pulse timeout/skip counts and commutation times
                       266     ; Timer 3 (500ns counts) always counts up and is used for
                       267     ; - Commutation timeouts
                       268     ; PCA0 (500ns counts) always counts up and is used for
                       269     ; - RC pulse measurement
                       270     ;
                       271     ;**** **** **** **** ****
                       272     ; Interrupt handling
                       273     ; The C8051 does not disable interrupts when entering an interrupt routine.
                       274     ; Also some interrupt flags need to be cleared by software
                       275     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                       276     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                       277     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                       278     ;
                       279     ;**** **** **** **** ****
                       280     ; Motor control:
                       281     ; - Brushless motor control with 6 states for each electrical 360 degrees
                       282     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                       283     ; - Timing advance in this implementation is set to 15deg nominally
                       284     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                       285     ; Motor sequence starting from zero crossing:
                       286     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                       287     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                       288     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                       289     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                       290     ;
                       291     ; Motor startup:
                       292     ; There is a startup phase and an initial run phase, before normal bemf commutation run begins.
                       293     ;
                       294     ;**** **** **** **** ****
                       295     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0001                 296     XP_3A_MAIN 					EQU 1
  0002                 297     XP_3A_TAIL 					EQU 2
  0003                 298     XP_3A_MULTI 					EQU 3
  0004                 299     XP_7A_MAIN 					EQU 4
  0005                 300     XP_7A_TAIL 					EQU 5
  0006                 301     XP_7A_MULTI 					EQU 6
  0007                 302     XP_7A_FAST_MAIN 				EQU 7
  0008                 303     XP_7A_FAST_TAIL 				EQU 8
  0009                 304     XP_7A_FAST_MULTI 				EQU 9
  000A                 305     XP_12A_MAIN 					EQU 10
  000B                 306     XP_12A_TAIL 					EQU 11
  000C                 307     XP_12A_MULTI 					EQU 12
  000D                 308     XP_18A_MAIN 					EQU 13
  000E                 309     XP_18A_TAIL 					EQU 14
  000F                 310     XP_18A_MULTI 					EQU 15
  0010                 311     XP_25A_MAIN 					EQU 16
  0011                 312     XP_25A_TAIL 					EQU 17
  0012                 313     XP_25A_MULTI 					EQU 18
  0013                 314     XP_35A_SW_MAIN 				EQU 19
  0014                 315     XP_35A_SW_TAIL 				EQU 20
  0015                 316     XP_35A_SW_MULTI 				EQU 21
  0016                 317     DP_3A_MAIN 					EQU 22
  0017                 318     DP_3A_TAIL  					EQU 23
  0018                 319     DP_3A_MULTI  					EQU 24
  0019                 320     SUPERMICRO_3P5A_MAIN 			EQU 25
  001A                 321     SUPERMICRO_3P5A_TAIL 			EQU 26   
  001B                 322     SUPERMICRO_3P5A_MULTI 			EQU 27   
  001C                 323     TURNIGY_PLUSH_6A_MAIN 			EQU 28
  001D                 324     TURNIGY_PLUSH_6A_TAIL 			EQU 29   
  001E                 325     TURNIGY_PLUSH_6A_MULTI 			EQU 30   
  001F                 326     TURNIGY_PLUSH_10A_MAIN 			EQU 31
  0020                 327     TURNIGY_PLUSH_10A_TAIL 			EQU 32   
  0021                 328     TURNIGY_PLUSH_10A_MULTI 			EQU 33   
  0022                 329     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                 330     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                 331     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  0025                 332     TURNIGY_PLUSH_18A_MAIN 			EQU 37
  0026                 333     TURNIGY_PLUSH_18A_TAIL 			EQU 38   
  0027                 334     TURNIGY_PLUSH_18A_MULTI 			EQU 39   
  0028                 335     TURNIGY_PLUSH_25A_MAIN 			EQU 40
  0029                 336     TURNIGY_PLUSH_25A_TAIL 			EQU 41   
  002A                 337     TURNIGY_PLUSH_25A_MULTI 			EQU 42   
  002B                 338     TURNIGY_PLUSH_30A_MAIN 			EQU 43
  002C                 339     TURNIGY_PLUSH_30A_TAIL 			EQU 44   
  002D                 340     TURNIGY_PLUSH_30A_MULTI 			EQU 45   
  002E                 341     TURNIGY_PLUSH_40A_MAIN 			EQU 46
  002F                 342     TURNIGY_PLUSH_40A_TAIL 			EQU 47   
  0030                 343     TURNIGY_PLUSH_40A_MULTI 			EQU 48   
  0031                 344     TURNIGY_PLUSH_60A_MAIN 			EQU 49
  0032                 345     TURNIGY_PLUSH_60A_TAIL 			EQU 50   
  0033                 346     TURNIGY_PLUSH_60A_MULTI 			EQU 51   
  0034                 347     TURNIGY_PLUSH_80A_MAIN 			EQU 52
  0035                 348     TURNIGY_PLUSH_80A_TAIL 			EQU 53   
  0036                 349     TURNIGY_PLUSH_80A_MULTI 			EQU 54   
  0037                 350     TURNIGY_PLUSH_NFET_18A_MAIN 		EQU 55
  0038                 351     TURNIGY_PLUSH_NFET_18A_TAIL 		EQU 56   
  0039                 352     TURNIGY_PLUSH_NFET_18A_MULTI 		EQU 57   
  003A                 353     TURNIGY_PLUSH_NFET_25A_MAIN 		EQU 58
  003B                 354     TURNIGY_PLUSH_NFET_25A_TAIL 		EQU 59   
  003C                 355     TURNIGY_PLUSH_NFET_25A_MULTI 		EQU 60   
  003D                 356     TURNIGY_PLUSH_NFET_30A_MAIN 		EQU 61
  003E                 357     TURNIGY_PLUSH_NFET_30A_TAIL 		EQU 62   
  003F                 358     TURNIGY_PLUSH_NFET_30A_MULTI 		EQU 63   
  0040                 359     TURNIGY_AE_20A_MAIN 			EQU 64
  0041                 360     TURNIGY_AE_20A_TAIL 			EQU 65   
  0042                 361     TURNIGY_AE_20A_MULTI 			EQU 66   
  0043                 362     TURNIGY_AE_25A_MAIN 			EQU 67
  0044                 363     TURNIGY_AE_25A_TAIL 			EQU 68   
  0045                 364     TURNIGY_AE_25A_MULTI 			EQU 69   
  0046                 365     TURNIGY_AE_30A_MAIN 			EQU 70
  0047                 366     TURNIGY_AE_30A_TAIL 			EQU 71   
  0048                 367     TURNIGY_AE_30A_MULTI 			EQU 72   
  0049                 368     TURNIGY_AE_45A_MAIN 			EQU 73
  004A                 369     TURNIGY_AE_45A_TAIL 			EQU 74   
  004B                 370     TURNIGY_AE_45A_MULTI 			EQU 75   
  004C                 371     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                 372     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                 373     TURNIGY_KFORCE_40A_MULTI 		EQU 78   
  004F                 374     TURNIGY_KFORCE_70A_HV_MAIN 		EQU 79   
  0050                 375     TURNIGY_KFORCE_70A_HV_TAIL 		EQU 80   
  0051                 376     TURNIGY_KFORCE_70A_HV_MULTI 		EQU 81   
  0052                 377     TURNIGY_KFORCE_120A_HV_MAIN 		EQU 82   
  0053                 378     TURNIGY_KFORCE_120A_HV_TAIL 		EQU 83   
  0054                 379     TURNIGY_KFORCE_120A_HV_MULTI 		EQU 84   
  0055                 380     TURNIGY_KFORCE_120A_HV_V2_MAIN	EQU 85   
  0056                 381     TURNIGY_KFORCE_120A_HV_V2_TAIL 	EQU 86   
  0057                 382     TURNIGY_KFORCE_120A_HV_V2_MULTI 	EQU 87   
  0058                 383     SKYWALKER_20A_MAIN 				EQU 88
  0059                 384     SKYWALKER_20A_TAIL 				EQU 89   
  005A                 385     SKYWALKER_20A_MULTI 			EQU 90   
  005B                 386     SKYWALKER_40A_MAIN 				EQU 91
  005C                 387     SKYWALKER_40A_TAIL 				EQU 92   
  005D                 388     SKYWALKER_40A_MULTI 			EQU 93   
  005E                 389     HIMODEL_COOL_22A_MAIN 			EQU 94
  005F                 390     HIMODEL_COOL_22A_TAIL 			EQU 95   
  0060                 391     HIMODEL_COOL_22A_MULTI 			EQU 96   
  0061                 392     HIMODEL_COOL_33A_MAIN 			EQU 97
  0062                 393     HIMODEL_COOL_33A_TAIL 			EQU 98   
  0063                 394     HIMODEL_COOL_33A_MULTI 			EQU 99  
  0064                 395     HIMODEL_COOL_41A_MAIN 			EQU 100
  0065                 396     HIMODEL_COOL_41A_TAIL 			EQU 101  
  0066                 397     HIMODEL_COOL_41A_MULTI 			EQU 102  
  0067                 398     RCTIMER_6A_MAIN 				EQU 103   
  0068                 399     RCTIMER_6A_TAIL 				EQU 104  
  0069                 400     RCTIMER_6A_MULTI 				EQU 105  
  006A                 401     ALIGN_RCE_BL15X_MAIN			EQU 106   
  006B                 402     ALIGN_RCE_BL15X_TAIL 			EQU 107  
  006C                 403     ALIGN_RCE_BL15X_MULTI 			EQU 108  
  006D                 404     ALIGN_RCE_BL15P_MAIN			EQU 109  
  006E                 405     ALIGN_RCE_BL15P_TAIL 			EQU 110  
  006F                 406     ALIGN_RCE_BL15P_MULTI 			EQU 111  
  0070                 407     ALIGN_RCE_BL35X_MAIN			EQU 112  
  0071                 408     ALIGN_RCE_BL35X_TAIL 			EQU 113  
  0072                 409     ALIGN_RCE_BL35X_MULTI 			EQU 114  
  0073                 410     ALIGN_RCE_BL35P_MAIN			EQU 115   
  0074                 411     ALIGN_RCE_BL35P_TAIL 			EQU 116  
  0075                 412     ALIGN_RCE_BL35P_MULTI 			EQU 117  
  0076                 413     GAUI_GE_183_18A_MAIN			EQU 118   
  0077                 414     GAUI_GE_183_18A_TAIL 			EQU 119  
  0078                 415     GAUI_GE_183_18A_MULTI 			EQU 120  
  0079                 416     H_KING_10A_MAIN				EQU 121   
  007A                 417     H_KING_10A_TAIL 				EQU 122  
  007B                 418     H_KING_10A_MULTI 				EQU 123  
  007C                 419     H_KING_20A_MAIN				EQU 124   
  007D                 420     H_KING_20A_TAIL 				EQU 125  
  007E                 421     H_KING_20A_MULTI 				EQU 126  
  007F                 422     H_KING_35A_MAIN				EQU 127   
  0080                 423     H_KING_35A_TAIL 				EQU 128 
  0081                 424     H_KING_35A_MULTI 				EQU 129  
  0082                 425     H_KING_50A_MAIN				EQU 130   
  0083                 426     H_KING_50A_TAIL 				EQU 131  
  0084                 427     H_KING_50A_MULTI 				EQU 132  
  0085                 428     POLARIS_THUNDER_12A_MAIN			EQU 133   
  0086                 429     POLARIS_THUNDER_12A_TAIL 		EQU 134  
  0087                 430     POLARIS_THUNDER_12A_MULTI 		EQU 135  
  0088                 431     POLARIS_THUNDER_20A_MAIN			EQU 136   
  0089                 432     POLARIS_THUNDER_20A_TAIL 		EQU 137  
  008A                 433     POLARIS_THUNDER_20A_MULTI 		EQU 138  
  008B                 434     POLARIS_THUNDER_30A_MAIN			EQU 139   
  008C                 435     POLARIS_THUNDER_30A_TAIL 		EQU 140  
  008D                 436     POLARIS_THUNDER_30A_MULTI 		EQU 141  
  008E                 437     POLARIS_THUNDER_40A_MAIN			EQU 142   
  008F                 438     POLARIS_THUNDER_40A_TAIL 		EQU 143  
  0090                 439     POLARIS_THUNDER_40A_MULTI 		EQU 144  
  0091                 440     POLARIS_THUNDER_60A_MAIN			EQU 145   
  0092                 441     POLARIS_THUNDER_60A_TAIL 		EQU 146  
  0093                 442     POLARIS_THUNDER_60A_MULTI 		EQU 147  
  0094                 443     POLARIS_THUNDER_80A_MAIN			EQU 148   
  0095                 444     POLARIS_THUNDER_80A_TAIL 		EQU 149  
  0096                 445     POLARIS_THUNDER_80A_MULTI 		EQU 150  
  0097                 446     POLARIS_THUNDER_100A_MAIN		EQU 151   
  0098                 447     POLARIS_THUNDER_100A_TAIL 		EQU 152  
  0099                 448     POLARIS_THUNDER_100A_MULTI 		EQU 153  
  009A                 449     PLATINUM_PRO_30A_MAIN			EQU 154   
  009B                 450     PLATINUM_PRO_30A_TAIL 			EQU 155  
  009C                 451     PLATINUM_PRO_30A_MULTI 			EQU 156  
  009D                 452     PLATINUM_PRO_150A_MAIN			EQU 157   
  009E                 453     PLATINUM_PRO_150A_TAIL 			EQU 158  
  009F                 454     PLATINUM_PRO_150A_MULTI 			EQU 159  
  00A0                 455     PLATINUM_50AV3_MAIN				EQU 160   
  00A1                 456     PLATINUM_50AV3_TAIL 			EQU 161  
  00A2                 457     PLATINUM_50AV3_MULTI 			EQU 162  
  00A3                 458     EAZY_3AV2_MAIN					EQU 163   
  00A4                 459     EAZY_3AV2_TAIL 				EQU 164  
  00A5                 460     EAZY_3AV2_MULTI 				EQU 165  
  00A6                 461     TAROT_30A_MAIN					EQU 166   
  00A7                 462     TAROT_30A_TAIL 				EQU 167  
  00A8                 463     TAROT_30A_MULTI 				EQU 168  
  00A9                 464     SKYIII_30A_MAIN				EQU 169   
  00AA                 465     SKYIII_30A_TAIL 				EQU 170  
  00AB                 466     SKYIII_30A_MULTI 				EQU 171  
  00AC                 467     EMAX_20A_MAIN					EQU 172   
  00AD                 468     EMAX_20A_TAIL 					EQU 173  
  00AE                 469     EMAX_20A_MULTI 				EQU 174  
  00AF                 470     EMAX_40A_MAIN					EQU 175   
  00B0                 471     EMAX_40A_TAIL 					EQU 176  
  00B1                 472     EMAX_40A_MULTI 				EQU 177  
  00B2                 473     EMAX_NANO_20A_MAIN				EQU 178   
  00B3                 474     EMAX_NANO_20A_TAIL 				EQU 179  
  00B4                 475     EMAX_NANO_20A_MULTI 			EQU 180  
  00B5                 476     EMAX_LIGHTNING_20A_MAIN			EQU 181   
  00B6                 477     EMAX_LIGHTNING_20A_TAIL 			EQU 182  
  00B7                 478     EMAX_LIGHTNING_20A_MULTI 		EQU 183  
  00B8                 479     XROTOR_10A_MAIN				EQU 184   
  00B9                 480     XROTOR_10A_TAIL 				EQU 185  
  00BA                 481     XROTOR_10A_MULTI 				EQU 186  
  00BB                 482     XROTOR_20A_MAIN				EQU 187   
  00BC                 483     XROTOR_20A_TAIL 				EQU 188  
  00BD                 484     XROTOR_20A_MULTI 				EQU 189  
  00BE                 485     XROTOR_40A_MAIN				EQU 190   
  00BF                 486     XROTOR_40A_TAIL 				EQU 191  
  00C0                 487     XROTOR_40A_MULTI 				EQU 192  
  00C1                 488     MDRX62H_MAIN					EQU 193   
  00C2                 489     MDRX62H_TAIL 					EQU 194  
  00C3                 490     MDRX62H_MULTI 					EQU 195  
  00C4                 491     ROTORGEEKS_20A_MAIN				EQU 196   
  00C5                 492     ROTORGEEKS_20A_TAIL 			EQU 197  
  00C6                 493     ROTORGEEKS_20A_MULTI 			EQU 198  
  00C7                 494     ROTORGEEKS_20A_PLUS_MAIN			EQU 199   
  00C8                 495     ROTORGEEKS_20A_PLUS_TAIL 		EQU 200  
  00C9                 496     ROTORGEEKS_20A_PLUS_MULTI 		EQU 201  
  00CA                 497     FLYCOLOR_FAIRY_6A_MAIN			EQU 202   
  00CB                 498     FLYCOLOR_FAIRY_6A_TAIL 			EQU 203  
  00CC                 499     FLYCOLOR_FAIRY_6A_MULTI 			EQU 204  
  00CD                 500     FLYCOLOR_FAIRY_30A_MAIN			EQU 205   
  00CE                 501     FLYCOLOR_FAIRY_30A_TAIL 			EQU 206  
  00CF                 502     FLYCOLOR_FAIRY_30A_MULTI 		EQU 207  
  00D0                 503     FLYCOLOR_FAIRY_V2_30A_MAIN		EQU 208
  00D1                 504     FLYCOLOR_FAIRY_V2_30A_TAIL 		EQU 209  
  00D2                 505     FLYCOLOR_FAIRY_V2_30A_MULTI 		EQU 210 
  00D3                 506     FLYCOLOR_RAPTOR_20A_MAIN			EQU 211   
  00D4                 507     FLYCOLOR_RAPTOR_20A_TAIL 		EQU 212  
  00D5                 508     FLYCOLOR_RAPTOR_20A_MULTI 		EQU 213  
  00D6                 509     FLYCOLOR_RAPTOR_390_20A_MAIN		EQU 214
  00D7                 510     FLYCOLOR_RAPTOR_390_20A_TAIL 		EQU 215  
  00D8                 511     FLYCOLOR_RAPTOR_390_20A_MULTI 	EQU 216  
  00D9                 512     FVT_LITTLEBEE_12A_MAIN			EQU 217  
  00DA                 513     FVT_LITTLEBEE_12A_TAIL			EQU 218  
  00DB                 514     FVT_LITTLEBEE_12A_MULTI			EQU 219  
  00DC                 515     FVT_LITTLEBEE_20A_MAIN			EQU 220  
  00DD                 516     FVT_LITTLEBEE_20A_TAIL			EQU 221  
  00DE                 517     FVT_LITTLEBEE_20A_MULTI			EQU 222  
  00DF                 518     FVT_LITTLEBEE_20A_PRO_MAIN		EQU 223  
  00E0                 519     FVT_LITTLEBEE_20A_PRO_TAIL		EQU 224  
  00E1                 520     FVT_LITTLEBEE_20A_PRO_MULTI		EQU 225  
  00E2                 521     FVT_LITTLEBEE_30A_MAIN			EQU 226  
  00E3                 522     FVT_LITTLEBEE_30A_TAIL			EQU 227  
  00E4                 523     FVT_LITTLEBEE_30A_MULTI			EQU 228  
  00E5                 524     GRAUPNER_ULTRA_20A_MAIN			EQU 229  
  00E6                 525     GRAUPNER_ULTRA_20A_TAIL			EQU 230  
  00E7                 526     GRAUPNER_ULTRA_20A_MULTI			EQU 231  
  00E8                 527     F85_3A_MAIN					EQU 232  
  00E9                 528     F85_3A_TAIL					EQU 233  
  00EA                 529     F85_3A_MULTI					EQU 234  
  00EB                 530     ZTW_SPIDER_PRO_20A_MAIN			EQU 235  
  00EC                 531     ZTW_SPIDER_PRO_20A_TAIL			EQU 236  
  00ED                 532     ZTW_SPIDER_PRO_20A_MULTI			EQU 237  
  00EE                 533     ZTW_SPIDER_PRO_20A_PREMIUM_MAIN	EQU 238  
  00EF                 534     ZTW_SPIDER_PRO_20A_PREMIUM_TAIL	EQU 239  
  00F0                 535     ZTW_SPIDER_PRO_20A_PREMIUM_MULTI	EQU 240  
  00F1                 536     ZTW_SPIDER_PRO_20A_HV_MAIN		EQU 241  
  00F2                 537     ZTW_SPIDER_PRO_20A_HV_TAIL		EQU 242  
  00F3                 538     ZTW_SPIDER_PRO_20A_HV_MULTI		EQU 243  
  00F4                 539     ZTW_SPIDER_PRO_30A_HV_MAIN		EQU 244  
  00F5                 540     ZTW_SPIDER_PRO_30A_HV_TAIL		EQU 245  
  00F6                 541     ZTW_SPIDER_PRO_30A_HV_MULTI		EQU 246  
  00F7                 542     DYS_XM20A_MAIN					EQU 247  
  00F8                 543     DYS_XM20A_TAIL					EQU 248  
  00F9                 544     DYS_XM20A_MULTI				EQU 249  
  00FA                 545     OVERSKY_MR_20A_MAIN				EQU 250  
  00FB                 546     OVERSKY_MR_20A_TAIL				EQU 251  
  00FC                 547     OVERSKY_MR_20A_MULTI			EQU 252  
  00FD                 548     OVERSKY_MR_20A_PRO_MAIN			EQU 253  
  00FE                 549     OVERSKY_MR_20A_PRO_TAIL			EQU 254  
  00FF                 550     OVERSKY_MR_20A_PRO_MULTI			EQU 255  
  0100                 551     TBS_CUBE_12A_MAIN				EQU 256 
  0101                 552     TBS_CUBE_12A_TAIL				EQU 257  
  0102                 553     TBS_CUBE_12A_MULTI				EQU 258  
  0103                 554     DALRC_XR20A_MAIN				EQU 259  
  0104                 555     DALRC_XR20A_TAIL				EQU 260  
  0105                 556     DALRC_XR20A_MULTI				EQU 261  
  0106                 557     AIKON_BOLTLITE_30A_MAIN			EQU 262  
  0107                 558     AIKON_BOLTLITE_30A_TAIL			EQU 263  
  0108                 559     AIKON_BOLTLITE_30A_MULTI			EQU 264
  0109                 560     ALIGN_MR25_15A_MAIN				EQU 265   
  010A                 561     ALIGN_MR25_15A_TAIL 			EQU 266  
  010B                 562     ALIGN_MR25_15A_MULTI 			EQU 267   
  010C                 563     SERVOKING_MONSTER_30A_MAIN		EQU 268   
  010D                 564     SERVOKING_MONSTER_30A_TAIL 		EQU 269  
  010E                 565     SERVOKING_MONSTER_30A_MULTI 		EQU 270   
  010F                 566     SERVOKING_MONSTER_30A_PRO_MAIN	EQU 271   
  0110                 567     SERVOKING_MONSTER_30A_PRO_TAIL	EQU 272  
  0111                 568     SERVOKING_MONSTER_30A_PRO_MULTI	EQU 273   
  0112                 569     SERVOKING_MONSTER_80A_MAIN		EQU 274   
  0113                 570     SERVOKING_MONSTER_80A_TAIL 		EQU 275  
  0114                 571     SERVOKING_MONSTER_80A_MULTI 		EQU 276   
  0115                 572     HTIRC_HUMMINGBIRD_12A_MAIN		EQU 277   
  0116                 573     HTIRC_HUMMINGBIRD_12A_TAIL 		EQU 278  
  0117                 574     HTIRC_HUMMINGBIRD_12A_MULTI 		EQU 279   
  0118                 575     HTIRC_HUMMINGBIRD_20A_MAIN		EQU 280   
  0119                 576     HTIRC_HUMMINGBIRD_20A_TAIL 		EQU 281  
  011A                 577     HTIRC_HUMMINGBIRD_20A_MULTI 		EQU 282   
  011B                 578     HTIRC_HUMMINGBIRD_30A_PRO_MAIN	EQU 283   
  011C                 579     HTIRC_HUMMINGBIRD_30A_PRO_TAIL	EQU 284  
  011D                 580     HTIRC_HUMMINGBIRD_30A_PRO_MULTI	EQU 285   
                       581       
                       582     
                       583     
                       584     ;**** **** **** **** ****
                       585     ; Select the ESC and mode to use (or unselect all for use with external batch compile file)
                       586     ;BESCNO EQU XP_3A_Main 
                       587     ;BESCNO EQU XP_3A_Tail
                       588     ;BESCNO EQU XP_3A_Multi
                       589     ;BESCNO EQU XP_7A_Main
                       590     ;BESCNO EQU XP_7A_Tail
                       591     ;BESCNO EQU XP_7A_Multi 	
                       592     ;BESCNO EQU XP_7A_Fast_Main
                       593     ;BESCNO EQU XP_7A_Fast_Tail
                       594     ;BESCNO EQU XP_7A_Fast_Multi
                       595     ;BESCNO EQU XP_12A_Main
                       596     ;BESCNO EQU XP_12A_Tail 
                       597     ;BESCNO EQU XP_12A_Multi
                       598     ;BESCNO EQU XP_18A_Main 
                       599     ;BESCNO EQU XP_18A_Tail 
                       600     ;BESCNO EQU XP_18A_Multi
                       601     ;BESCNO EQU XP_25A_Main 
                       602     ;BESCNO EQU XP_25A_Tail 
                       603     ;BESCNO EQU XP_25A_Multi
                       604     ;BESCNO EQU XP_35A_SW_Main
                       605     ;BESCNO EQU XP_35A_SW_Tail 
                       606     ;BESCNO EQU XP_35A_SW_Multi
                       607     ;BESCNO EQU DP_3A_Main 						
                       608     ;BESCNO EQU DP_3A_Tail 
                       609     ;BESCNO EQU DP_3A_Multi 
                       610     ;BESCNO EQU Supermicro_3p5A_Main
                       611     ;BESCNO EQU Supermicro_3p5A_Tail 
                       612     ;BESCNO EQU Supermicro_3p5A_Multi
                       613     ;BESCNO EQU Turnigy_Plush_6A_Main 
                       614     ;BESCNO EQU Turnigy_Plush_6A_Tail 
                       615     ;BESCNO EQU Turnigy_Plush_6A_Multi
                       616     ;BESCNO EQU Turnigy_Plush_10A_Main 
                       617     ;BESCNO EQU Turnigy_Plush_10A_Tail 
                       618     ;BESCNO EQU Turnigy_Plush_10A_Multi
                       619     ;BESCNO EQU Turnigy_Plush_12A_Main 
                       620     ;BESCNO EQU Turnigy_Plush_12A_Tail 
                       621     ;BESCNO EQU Turnigy_Plush_12A_Multi 
                       622     ;BESCNO EQU Turnigy_Plush_18A_Main 
                       623     ;BESCNO EQU Turnigy_Plush_18A_Tail 
                       624     ;BESCNO EQU Turnigy_Plush_18A_Multi
                       625     ;BESCNO EQU Turnigy_Plush_25A_Main 
                       626     ;BESCNO EQU Turnigy_Plush_25A_Tail
                       627     ;BESCNO EQU Turnigy_Plush_25A_Multi
                       628     ;BESCNO EQU Turnigy_Plush_30A_Main 
                       629     ;BESCNO EQU Turnigy_Plush_30A_Tail 
                       630     ;BESCNO EQU Turnigy_Plush_30A_Multi
                       631     ;BESCNO EQU Turnigy_Plush_40A_Main 
                       632     ;BESCNO EQU Turnigy_Plush_40A_Tail 
                       633     ;BESCNO EQU Turnigy_Plush_40A_Multi 
                       634     ;BESCNO EQU Turnigy_Plush_60A_Main
                       635     ;BESCNO EQU Turnigy_Plush_60A_Tail 
                       636     ;BESCNO EQU Turnigy_Plush_60A_Multi
                       637     ;BESCNO EQU Turnigy_Plush_80A_Main
                       638     ;BESCNO EQU Turnigy_Plush_80A_Tail 
                       639     ;BESCNO EQU Turnigy_Plush_80A_Multi
                       640     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Main
                       641     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Tail 
                       642     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Multi 
                       643     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Main 
                       644     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Tail
                       645     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Multi
                       646     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Main  
                       647     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Tail 
                       648     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Multi
                       649     ;BESCNO EQU Turnigy_AE_20A_Main 
                       650     ;BESCNO EQU Turnigy_AE_20A_Tail 
                       651     ;BESCNO EQU Turnigy_AE_20A_Multi
                       652     ;BESCNO EQU Turnigy_AE_25A_Main 
                       653     ;BESCNO EQU Turnigy_AE_25A_Tail 
                       654     ;BESCNO EQU Turnigy_AE_25A_Multi
                       655     ;BESCNO EQU Turnigy_AE_30A_Main 
                       656     ;BESCNO EQU Turnigy_AE_30A_Tail 
                       657     ;BESCNO EQU Turnigy_AE_30A_Multi
                       658     ;BESCNO EQU Turnigy_AE_45A_Main
                       659     ;BESCNO EQU Turnigy_AE_45A_Tail 
                       660     ;BESCNO EQU Turnigy_AE_45A_Multi
                       661     ;BESCNO EQU Turnigy_KForce_40A_Main
                       662     ;BESCNO EQU Turnigy_KForce_40A_Tail 
                       663     ;BESCNO EQU Turnigy_KForce_40A_Multi 
                       664     ;BESCNO EQU Turnigy_KForce_70A_HV_Main
                       665     ;BESCNO EQU Turnigy_KForce_70A_HV_Tail 
                       666     ;BESCNO EQU Turnigy_KForce_70A_HV_Multi
                       667     ;BESCNO EQU Turnigy_KForce_120A_HV_Main
                       668     ;BESCNO EQU Turnigy_KForce_120A_HV_Tail 
                       669     ;BESCNO EQU Turnigy_KForce_120A_HV_Multi
                       670     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Main
                       671     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Tail 
                       672     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Multi
                       673     ;BESCNO EQU Skywalker_20A_Main
                       674     ;BESCNO EQU Skywalker_20A_Tail
                       675     ;BESCNO EQU Skywalker_20A_Multi 
                       676     ;BESCNO EQU Skywalker_40A_Main 
                       677     ;BESCNO EQU Skywalker_40A_Tail 
                       678     ;BESCNO EQU Skywalker_40A_Multi
                       679     ;BESCNO EQU HiModel_Cool_22A_Main
                       680     ;BESCNO EQU HiModel_Cool_22A_Tail
                       681     ;BESCNO EQU HiModel_Cool_22A_Multi
                       682     ;BESCNO EQU HiModel_Cool_33A_Main
                       683     ;BESCNO EQU HiModel_Cool_33A_Tail
                       684     ;BESCNO EQU HiModel_Cool_33A_Multi
                       685     ;BESCNO EQU HiModel_Cool_41A_Main
                       686     ;BESCNO EQU HiModel_Cool_41A_Tail
                       687     ;BESCNO EQU HiModel_Cool_41A_Multi
                       688     ;BESCNO EQU RCTimer_6A_Main
                       689     ;BESCNO EQU RCTimer_6A_Tail
                       690     ;BESCNO EQU RCTimer_6A_Multi
                       691     ;BESCNO EQU Align_RCE_BL15X_Main
                       692     ;BESCNO EQU Align_RCE_BL15X_Tail
                       693     ;BESCNO EQU Align_RCE_BL15X_Multi
                       694     ;BESCNO EQU Align_RCE_BL15P_Main
                       695     ;BESCNO EQU Align_RCE_BL15P_Tail
                       696     ;BESCNO EQU Align_RCE_BL15P_Multi 
                       697     ;BESCNO EQU Align_RCE_BL35X_Main 
                       698     ;BESCNO EQU Align_RCE_BL35X_Tail
                       699     ;BESCNO EQU Align_RCE_BL35X_Multi
                       700     ;BESCNO EQU Align_RCE_BL35P_Main
                       701     ;BESCNO EQU Align_RCE_BL35P_Tail
                       702     ;BESCNO EQU Align_RCE_BL35P_Multi
                       703     ;BESCNO EQU Gaui_GE_183_18A_Main
                       704     ;BESCNO EQU Gaui_GE_183_18A_Tail
                       705     ;BESCNO EQU Gaui_GE_183_18A_Multi
                       706     ;BESCNO EQU H_King_10A_Main 
                       707     ;BESCNO EQU H_King_10A_Tail 
                       708     ;BESCNO EQU H_King_10A_Multi
                       709     ;BESCNO EQU H_King_20A_Main
                       710     ;BESCNO EQU H_King_20A_Tail
                       711     ;BESCNO EQU H_King_20A_Multi
                       712     ;BESCNO EQU H_King_35A_Main
                       713     ;BESCNO EQU H_King_35A_Tail
                       714     ;BESCNO EQU H_King_35A_Multi
                       715     ;BESCNO EQU H_King_50A_Main
                       716     ;BESCNO EQU H_King_50A_Tail
                       717     ;BESCNO EQU H_King_50A_Multi
                       718     ;BESCNO EQU Polaris_Thunder_12A_Main
                       719     ;BESCNO EQU Polaris_Thunder_12A_Tail
                       720     ;BESCNO EQU Polaris_Thunder_12A_Multi
                       721     ;BESCNO EQU Polaris_Thunder_20A_Main
                       722     ;BESCNO EQU Polaris_Thunder_20A_Tail
                       723     ;BESCNO EQU Polaris_Thunder_20A_Multi
                       724     ;BESCNO EQU Polaris_Thunder_30A_Main
                       725     ;BESCNO EQU Polaris_Thunder_30A_Tail
                       726     ;BESCNO EQU Polaris_Thunder_30A_Multi
                       727     ;BESCNO EQU Polaris_Thunder_40A_Main
                       728     ;BESCNO EQU Polaris_Thunder_40A_Tail
                       729     ;BESCNO EQU Polaris_Thunder_40A_Multi
                       730     ;BESCNO EQU Polaris_Thunder_60A_Main
                       731     ;BESCNO EQU Polaris_Thunder_60A_Tail
                       732     ;BESCNO EQU Polaris_Thunder_60A_Multi
                       733     ;BESCNO EQU Polaris_Thunder_80A_Main
                       734     ;BESCNO EQU Polaris_Thunder_80A_Tail
                       735     ;BESCNO EQU Polaris_Thunder_80A_Multi
                       736     ;BESCNO EQU Polaris_Thunder_100A_Main
                       737     ;BESCNO EQU Polaris_Thunder_100A_Tail
                       738     ;BESCNO EQU Polaris_Thunder_100A_Multi
                       739     ;BESCNO EQU Platinum_Pro_30A_Main
                       740     ;BESCNO EQU Platinum_Pro_30A_Tail
                       741     ;BESCNO EQU Platinum_Pro_30A_Multi 
                       742     ;BESCNO EQU Platinum_Pro_150A_Main
                       743     ;BESCNO EQU Platinum_Pro_150A_Tail
                       744     ;BESCNO EQU Platinum_Pro_150A_Multi
                       745     ;BESCNO EQU Platinum_50Av3_Main
                       746     ;BESCNO EQU Platinum_50Av3_Tail
                       747     ;BESCNO EQU Platinum_50Av3_Multi 
                       748     ;BESCNO EQU EAZY_3Av2_Main
                       749     ;BESCNO EQU EAZY_3Av2_Tail
                       750     ;BESCNO EQU EAZY_3Av2_Multi
                       751     ;BESCNO EQU Tarot_30A_Main
                       752     ;BESCNO EQU Tarot_30A_Tail
                       753     ;BESCNO EQU Tarot_30A_Multi
                       754     ;BESCNO EQU SkyIII_30A_Main
                       755     ;BESCNO EQU SkyIII_30A_Tail
                       756     ;BESCNO EQU SkyIII_30A_Multi
                       757     ;BESCNO EQU EMAX_20A_Main
                       758     ;BESCNO EQU EMAX_20A_Tail
                       759     ;BESCNO EQU EMAX_20A_Multi 
                       760     ;BESCNO EQU EMAX_40A_Main
                       761     ;BESCNO EQU EMAX_40A_Tail
                       762     ;BESCNO EQU EMAX_40A_Multi 
                       763     ;BESCNO EQU EMAX_Nano_20A_Main
                       764     ;BESCNO EQU EMAX_Nano_20A_Tail
                       765     ;BESCNO EQU EMAX_Nano_20A_Multi 
                       766     ;BESCNO EQU EMAX_Lightning_20A_Main
                       767     ;BESCNO EQU EMAX_Lightning_20A_Tail
                       768     ;BESCNO EQU EMAX_Lightning_20A_Multi 
                       769     ;BESCNO EQU XRotor_10A_Main 
                       770     ;BESCNO EQU XRotor_10A_Tail
                       771     ;BESCNO EQU XRotor_10A_Multi 
                       772     ;BESCNO EQU XRotor_20A_Main
                       773     ;BESCNO EQU XRotor_20A_Tail
                       774     ;BESCNO EQU XRotor_20A_Multi 
                       775     ;BESCNO EQU XRotor_40A_Main
                       776     ;BESCNO EQU XRotor_40A_Tail
                       777     ;BESCNO EQU XRotor_40A_Multi 
                       778     ;BESCNO EQU MDRX62H_Main
                       779     ;BESCNO EQU MDRX62H_Tail
                       780     ;BESCNO EQU MDRX62H_Multi 
                       781     ;BESCNO EQU RotorGeeks_20A_Main
                       782     ;BESCNO EQU RotorGeeks_20A_Tail
                       783     ;BESCNO EQU RotorGeeks_20A_Multi
                       784     ;BESCNO EQU RotorGeeks_20A_Plus_Main
                       785     ;BESCNO EQU RotorGeeks_20A_Plus_Tail
                       786     ;BESCNO EQU RotorGeeks_20A_Plus_Multi
                       787     ;BESCNO EQU Flycolor_Fairy_6A_Main
                       788     ;BESCNO EQU Flycolor_Fairy_6A_Tail
                       789     ;BESCNO EQU Flycolor_Fairy_6A_Multi
                       790     ;BESCNO EQU Flycolor_Fairy_30A_Main
                       791     ;BESCNO EQU Flycolor_Fairy_30A_Tail
                       792     ;BESCNO EQU Flycolor_Fairy_30A_Multi
                       793     ;BESCNO EQU Flycolor_Fairy_V2_30A_Main
                       794     ;BESCNO EQU Flycolor_Fairy_V2_30A_Tail
                       795     ;BESCNO EQU Flycolor_Fairy_V2_30A_Multi 
                       796     ;BESCNO EQU Flycolor_Raptor_20A_Main
                       797     ;BESCNO EQU Flycolor_Raptor_20A_Tail
                       798     ;BESCNO EQU Flycolor_Raptor_20A_Multi 
                       799     ;BESCNO EQU Flycolor_Raptor_390_20A_Main
                       800     ;BESCNO EQU Flycolor_Raptor_390_20A_Tail
                       801     ;BESCNO EQU Flycolor_Raptor_390_20A_Multi
                       802     ;BESCNO EQU FVT_Littlebee_12A_Main
                       803     ;BESCNO EQU FVT_Littlebee_12A_Tail
                       804     ;BESCNO EQU FVT_Littlebee_12A_Multi
                       805     ;BESCNO EQU FVT_Littlebee_20A_Main
                       806     ;BESCNO EQU FVT_Littlebee_20A_Tail
                       807     ;BESCNO EQU FVT_Littlebee_20A_Multi 
                       808     ;BESCNO EQU FVT_Littlebee_20A_Pro_Main
                       809     ;BESCNO EQU FVT_Littlebee_20A_Pro_Tail
                       810     ;BESCNO EQU FVT_Littlebee_20A_Pro_Multi 
                       811     ;BESCNO EQU FVT_Littlebee_30A_Main
                       812     ;BESCNO EQU FVT_Littlebee_30A_Tail
                       813     ;BESCNO EQU FVT_Littlebee_30A_Multi 
                       814     ;BESCNO EQU Graupner_Ultra_20A_Main
                       815     ;BESCNO EQU Graupner_Ultra_20A_Tail
                       816     ;BESCNO EQU Graupner_Ultra_20A_Multi 
                       817     ;BESCNO EQU F85_3A_Main
                       818     ;BESCNO EQU F85_3A_Tail
                       819     ;BESCNO EQU F85_3A_Multi
                       820     ;BESCNO EQU ZTW_Spider_Pro_20A_Main
                       821     ;BESCNO EQU ZTW_Spider_Pro_20A_Tail
                       822     ;BESCNO EQU ZTW_Spider_Pro_20A_Multi 
                       823     ;BESCNO EQU ZTW_Spider_Pro_20A_Premium_Main
                       824     ;BESCNO EQU ZTW_Spider_Pro_20A_Premium_Tail
                       825     ;BESCNO EQU ZTW_Spider_Pro_20A_Premium_Multi
                       826     ;BESCNO EQU ZTW_Spider_Pro_20A_HV_Main
                       827     ;BESCNO EQU ZTW_Spider_Pro_20A_HV_Tail
                       828     ;BESCNO EQU ZTW_Spider_Pro_20A_HV_Multi 
                       829     ;BESCNO EQU ZTW_Spider_Pro_30A_HV_Main
                       830     ;BESCNO EQU ZTW_Spider_Pro_30A_HV_Tail
                       831     ;BESCNO EQU ZTW_Spider_Pro_30A_HV_Multi 
                       832     ;BESCNO EQU DYS_XM20A_Main
                       833     ;BESCNO EQU DYS_XM20A_Tail
                       834     ;BESCNO EQU DYS_XM20A_Multi
                       835     ;BESCNO EQU Oversky_MR_20A_Main
                       836     ;BESCNO EQU Oversky_MR_20A_Tail
                       837     ;BESCNO EQU Oversky_MR_20A_Multi 
                       838     ;BESCNO EQU Oversky_MR_20A_Pro_Main
                       839     ;BESCNO EQU Oversky_MR_20A_Pro_Tail
                       840     ;BESCNO EQU Oversky_MR_20A_Pro_Multi
                       841     ;BESCNO EQU TBS_Cube_12A_Main	 
                       842     ;BESCNO EQU TBS_Cube_12A_Tail	  
                       843     ;BESCNO EQU TBS_Cube_12A_Multi 
                       844     ;BESCNO EQU DALRC_XR20A_Main	 
                       845     ;BESCNO EQU DALRC_XR20A_Tail	  
                       846     ;BESCNO EQU DALRC_XR20A_Multi 	 
                       847     ;BESCNO EQU AIKON_Boltlite_30A_Main	 
                       848     ;BESCNO EQU AIKON_Boltlite_30A_Tail	  
                       849     ;BESCNO EQU AIKON_Boltlite_30A_Multi 
                       850     ;BESCNO EQU Align_MR25_15A_Main	 
                       851     ;BESCNO EQU Align_MR25_15A_Tail	  
                       852     ;BESCNO EQU Align_MR25_15A_Multi
                       853     ;BESCNO EQU Servoking_Monster_30A_Main	 
                       854     ;BESCNO EQU Servoking_Monster_30A_Tail	  
                       855     ;BESCNO EQU Servoking_Monster_30A_Multi 
                       856     ;BESCNO EQU Servoking_Monster_30A_Pro_Main	 
                       857     ;BESCNO EQU Servoking_Monster_30A_Pro_Tail	  
                       858     ;BESCNO EQU Servoking_Monster_30A_Pro_Multi 
                       859     ;BESCNO EQU Servoking_Monster_80A_Main	 
                       860     ;BESCNO EQU Servoking_Monster_80A_Tail	  
                       861     ;BESCNO EQU Servoking_Monster_80A_Multi 
                       862     ;BESCNO EQU HTIRC_Hummingbird_12A_Main	 
                       863     ;BESCNO EQU HTIRC_Hummingbird_12A_Tail 	 
                       864     ;BESCNO EQU HTIRC_Hummingbird_12A_Multi  
                       865     ;BESCNO EQU HTIRC_Hummingbird_20A_Main	 
                       866     ;BESCNO EQU HTIRC_Hummingbird_20A_Tail 	 
                       867     ;BESCNO EQU HTIRC_Hummingbird_20A_Multi  
                       868     ;BESCNO EQU HTIRC_Hummingbird_30A_Pro_Main	 
                       869     ;BESCNO EQU HTIRC_Hummingbird_30A_Pro_Tail 	 
                       870     ;BESCNO EQU HTIRC_Hummingbird_30A_Pro_Multi  
                       871     
                       872     
                       873     ;**** **** **** **** ****
                       874     ; ESC selection statements
                       875     IF BESCNO == XP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       879     
                       880     IF BESCNO == XP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       884     
                       885     IF BESCNO == XP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       889     
                       890     IF BESCNO == XP_7A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       894     
                       895     IF BESCNO == XP_7A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       899     
                       900     IF BESCNO == XP_7A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       904     
                       905     IF BESCNO == XP_7A_FAST_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       909     
                       910     IF BESCNO == XP_7A_FAST_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       914     
                       915     IF BESCNO == XP_7A_FAST_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       919     
                       920     IF BESCNO == XP_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       924     
                       925     IF BESCNO == XP_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       929     
                       930     IF BESCNO == XP_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       934     
                       935     IF BESCNO == XP_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       939     
                       940     IF BESCNO == XP_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       944     
                       945     IF BESCNO == XP_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       949     
                       950     IF BESCNO == XP_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       954     
                       955     IF BESCNO == XP_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       959     
                       960     IF BESCNO == XP_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       964     
                       965     IF BESCNO == XP_35A_SW_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       969     
                       970     IF BESCNO == XP_35A_SW_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       974     
                       975     IF BESCNO == XP_35A_SW_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       979     
                       980     IF BESCNO == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       984     
                       985     IF BESCNO == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       989     
                       990     IF BESCNO == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       994     
                       995     IF BESCNO == SUPERMICRO_3P5A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       999     
                      1000     IF BESCNO == SUPERMICRO_3P5A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                      1004     
                      1005     IF BESCNO == SUPERMICRO_3P5A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                      1009     
                      1010     IF BESCNO == TURNIGY_PLUSH_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                      1014     
                      1015     IF BESCNO == TURNIGY_PLUSH_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                      1019     
                      1020     IF BESCNO == TURNIGY_PLUSH_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                      1024     
                      1025     IF BESCNO == TURNIGY_PLUSH_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                      1029     
                      1030     IF BESCNO == TURNIGY_PLUSH_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                      1034     
                      1035     IF BESCNO == TURNIGY_PLUSH_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                      1039     
                      1040     IF BESCNO == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                      1044     
                      1045     IF BESCNO == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                      1049     
                      1050     IF BESCNO == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                      1054     
                      1055     IF BESCNO == TURNIGY_PLUSH_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                      1059     
                      1060     IF BESCNO == TURNIGY_PLUSH_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                      1064     
                      1065     IF BESCNO == TURNIGY_PLUSH_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                      1069     
                      1070     IF BESCNO == TURNIGY_PLUSH_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                      1074     
                      1075     IF BESCNO == TURNIGY_PLUSH_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                      1079     
                      1080     IF BESCNO == TURNIGY_PLUSH_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                      1084     
                      1085     IF BESCNO == TURNIGY_PLUSH_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                      1089     
                      1090     IF BESCNO == TURNIGY_PLUSH_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                      1094     
                      1095     IF BESCNO == TURNIGY_PLUSH_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                      1099     
                      1100     IF BESCNO == TURNIGY_PLUSH_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                      1104     
                      1105     IF BESCNO == TURNIGY_PLUSH_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                      1109     
                      1110     IF BESCNO == TURNIGY_PLUSH_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                      1114     
                      1115     IF BESCNO == TURNIGY_PLUSH_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                      1119     
                      1120     IF BESCNO == TURNIGY_PLUSH_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                      1124     
                      1125     IF BESCNO == TURNIGY_PLUSH_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                      1129     
                      1130     IF BESCNO == TURNIGY_PLUSH_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                      1134     
                      1135     IF BESCNO == TURNIGY_PLUSH_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                      1139     
                      1140     IF BESCNO == TURNIGY_PLUSH_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                      1144     
                      1145     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                      1149     
                      1150     IF BESCNO == TURNIGY_PLUSH_NFET_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                      1154     
                      1155     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                      1159     
                      1160     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1164     
                      1165     IF BESCNO == TURNIGY_PLUSH_NFET_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1169     
                      1170     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1174     
                      1175     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1179     
                      1180     IF BESCNO == TURNIGY_PLUSH_NFET_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1184     
                      1185     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1189     
                      1190     IF BESCNO == TURNIGY_AE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1194     
                      1195     IF BESCNO == TURNIGY_AE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1199     
                      1200     IF BESCNO == TURNIGY_AE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1204     
                      1205     IF BESCNO == TURNIGY_AE_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1209     
                      1210     IF BESCNO == TURNIGY_AE_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1214     
                      1215     IF BESCNO == TURNIGY_AE_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1219     
                      1220     IF BESCNO == TURNIGY_AE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1224     
                      1225     IF BESCNO == TURNIGY_AE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1229     
                      1230     IF BESCNO == TURNIGY_AE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1234     
                      1235     IF BESCNO == TURNIGY_AE_45A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1239     
                      1240     IF BESCNO == TURNIGY_AE_45A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1244     
                      1245     IF BESCNO == TURNIGY_AE_45A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1249     
                      1250     IF BESCNO == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1254     
                      1255     IF BESCNO == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1259     
                      1260     IF BESCNO == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1264     
                      1265     IF BESCNO == TURNIGY_KFORCE_70A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1269     
                      1270     IF BESCNO == TURNIGY_KFORCE_70A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1274     
                      1275     IF BESCNO == TURNIGY_KFORCE_70A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1279     
                      1280     IF BESCNO == TURNIGY_KFORCE_120A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1284     
                      1285     IF BESCNO == TURNIGY_KFORCE_120A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1289     
                      1290     IF BESCNO == TURNIGY_KFORCE_120A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1294     
                      1295     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1299     
                      1300     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1304     
                      1305     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1309     
                      1310     IF BESCNO == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1314     
                      1315     IF BESCNO == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1319     
                      1320     IF BESCNO == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1324     
                      1325     IF BESCNO == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1329     
                      1330     IF BESCNO == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1334     
                      1335     IF BESCNO == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1339     
                      1340     IF BESCNO == HIMODEL_COOL_22A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1344     
                      1345     IF BESCNO == HIMODEL_COOL_22A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1349     
                      1350     IF BESCNO == HIMODEL_COOL_22A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1354     
                      1355     IF BESCNO == HIMODEL_COOL_33A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1359     
                      1360     IF BESCNO == HIMODEL_COOL_33A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1364     
                      1365     IF BESCNO == HIMODEL_COOL_33A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1369     
                      1370     IF BESCNO == HIMODEL_COOL_41A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1374     
                      1375     IF BESCNO == HIMODEL_COOL_41A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1379     
                      1380     IF BESCNO == HIMODEL_COOL_41A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1384     
                      1385     IF BESCNO == RCTIMER_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1389     
                      1390     IF BESCNO == RCTIMER_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1394     
                      1395     IF BESCNO == RCTIMER_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1399     
                      1400     IF BESCNO == ALIGN_RCE_BL15X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1404     
                      1405     IF BESCNO == ALIGN_RCE_BL15X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1409     
                      1410     IF BESCNO == ALIGN_RCE_BL15X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1414     
                      1415     IF BESCNO == ALIGN_RCE_BL15P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1419     
                      1420     IF BESCNO == ALIGN_RCE_BL15P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1424     
                      1425     IF BESCNO == ALIGN_RCE_BL15P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1429     
                      1430     IF BESCNO == ALIGN_RCE_BL35X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1434     
                      1435     IF BESCNO == ALIGN_RCE_BL35X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1439     
                      1440     IF BESCNO == ALIGN_RCE_BL35X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1444     
                      1445     IF BESCNO == ALIGN_RCE_BL35P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1449     
                      1450     IF BESCNO == ALIGN_RCE_BL35P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1454     
                      1455     IF BESCNO == ALIGN_RCE_BL35P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1459     
                      1460     IF BESCNO == GAUI_GE_183_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1464     
                      1465     IF BESCNO == GAUI_GE_183_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1469     
                      1470     IF BESCNO == GAUI_GE_183_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1474     
                      1475     IF BESCNO == H_KING_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1479     
                      1480     IF BESCNO == H_KING_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1484     
                      1485     IF BESCNO == H_KING_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1489     
                      1490     IF BESCNO == H_KING_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1494     
                      1495     IF BESCNO == H_KING_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1499     
                      1500     IF BESCNO == H_KING_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1504     
                      1505     IF BESCNO == H_KING_35A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1509     
                      1510     IF BESCNO == H_KING_35A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1514     
                      1515     IF BESCNO == H_KING_35A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1519     
                      1520     IF BESCNO == H_KING_50A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1524     
                      1525     IF BESCNO == H_KING_50A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1529     
                      1530     IF BESCNO == H_KING_50A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1534     
                      1535     IF BESCNO == POLARIS_THUNDER_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1539     
                      1540     IF BESCNO == POLARIS_THUNDER_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1544     
                      1545     IF BESCNO == POLARIS_THUNDER_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1549     
                      1550     IF BESCNO == POLARIS_THUNDER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1554     
                      1555     IF BESCNO == POLARIS_THUNDER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1559     
                      1560     IF BESCNO == POLARIS_THUNDER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1564     
                      1565     IF BESCNO == POLARIS_THUNDER_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1569     
                      1570     IF BESCNO == POLARIS_THUNDER_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1574     
                      1575     IF BESCNO == POLARIS_THUNDER_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1579     
                      1580     IF BESCNO == POLARIS_THUNDER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1584     
                      1585     IF BESCNO == POLARIS_THUNDER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1589     
                      1590     IF BESCNO == POLARIS_THUNDER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1594     
                      1595     IF BESCNO == POLARIS_THUNDER_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1599     
                      1600     IF BESCNO == POLARIS_THUNDER_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1604     
                      1605     IF BESCNO == POLARIS_THUNDER_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1609     
                      1610     IF BESCNO == POLARIS_THUNDER_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1614     
                      1615     IF BESCNO == POLARIS_THUNDER_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1619     
                      1620     IF BESCNO == POLARIS_THUNDER_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1624     
                      1625     IF BESCNO == POLARIS_THUNDER_100A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1629     
                      1630     IF BESCNO == POLARIS_THUNDER_100A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1634     
                      1635     IF BESCNO == POLARIS_THUNDER_100A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1639     
                      1640     IF BESCNO == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1644     
                      1645     IF BESCNO == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1649     
                      1650     IF BESCNO == PLATINUM_PRO_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1654     
                      1655     IF BESCNO == PLATINUM_PRO_150A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1659     
                      1660     IF BESCNO == PLATINUM_PRO_150A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1664     
                      1665     IF BESCNO == PLATINUM_PRO_150A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1669     
                      1670     IF BESCNO == PLATINUM_50AV3_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1674     
                      1675     IF BESCNO == PLATINUM_50AV3_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1679     
                      1680     IF BESCNO == PLATINUM_50AV3_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1684     
                      1685     IF BESCNO == EAZY_3AV2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1689     
                      1690     IF BESCNO == EAZY_3AV2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1694     
                      1695     IF BESCNO == EAZY_3AV2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1699     
                      1700     IF BESCNO == TAROT_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1704     
                      1705     IF BESCNO == TAROT_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1709     
                      1710     IF BESCNO == TAROT_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1714     
                      1715     IF BESCNO == SKYIII_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1719     
                      1720     IF BESCNO == SKYIII_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1724     
                      1725     IF BESCNO == SKYIII_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1729     
                      1730     IF BESCNO == EMAX_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1734     
                      1735     IF BESCNO == EMAX_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1739     
                      1740     IF BESCNO == EMAX_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1744     
                      1745     IF BESCNO == EMAX_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1749     
                      1750     IF BESCNO == EMAX_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1754     
                      1755     IF BESCNO == EMAX_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1759     
                      1760     IF BESCNO == EMAX_NANO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1764     
                      1765     IF BESCNO == EMAX_NANO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1769     
                      1770     IF BESCNO == EMAX_NANO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1774     
                      1775     IF BESCNO == EMAX_LIGHTNING_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_LIGHTNING_20A.INC)	; Select EMAX Lightning 20A pinout
                               ENDIF
                      1779     
                      1780     IF BESCNO == EMAX_LIGHTNING_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_LIGHTNING_20A.INC)	; Select EMAX Lightning 20A pinout
                               ENDIF
                      1784     
                      1785     IF BESCNO == EMAX_LIGHTNING_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_LIGHTNING_20A.INC)	; Select EMAX Lightning 20A pinout
                               ENDIF
                      1789     
                      1790     IF BESCNO == XROTOR_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1794     
                      1795     IF BESCNO == XROTOR_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1799     
                      1800     IF BESCNO == XROTOR_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1804     
                      1805     IF BESCNO == XROTOR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1809     
                      1810     IF BESCNO == XROTOR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1814     
                      1815     IF BESCNO == XROTOR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1819     
                      1820     IF BESCNO == XROTOR_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      1824     
                      1825     IF BESCNO == XROTOR_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      1829     
                      1830     IF BESCNO == XROTOR_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      1834     
                      1835     IF BESCNO == MDRX62H_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      1839     
                      1840     IF BESCNO == MDRX62H_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      1844     
                      1845     IF BESCNO == MDRX62H_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      1849     
                      1850     IF BESCNO == ROTORGEEKS_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      1854     
                      1855     IF BESCNO == ROTORGEEKS_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      1859     
                      1860     IF BESCNO == ROTORGEEKS_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      1864     
                      1865     IF BESCNO == ROTORGEEKS_20A_PLUS_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ROTORGEEKS_20A_PLUS.INC)	; Select RotorGeeks 20A Plus pinout
                               ENDIF
                      1869     
                      1870     IF BESCNO == ROTORGEEKS_20A_PLUS_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ROTORGEEKS_20A_PLUS.INC)	; Select RotorGeeks 20A Plus pinout
                               ENDIF
                      1874     
                      1875     IF BESCNO == ROTORGEEKS_20A_PLUS_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ROTORGEEKS_20A_PLUS.INC)	; Select RotorGeeks 20A Plus pinout
                               ENDIF
                      1879     
                      1880     IF BESCNO == FLYCOLOR_FAIRY_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      1884     
                      1885     IF BESCNO == FLYCOLOR_FAIRY_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      1889     
                      1890     IF BESCNO == FLYCOLOR_FAIRY_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      1894     
                      1895     IF BESCNO == FLYCOLOR_FAIRY_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      1899     
                      1900     IF BESCNO == FLYCOLOR_FAIRY_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      1904     
                      1905     IF BESCNO == FLYCOLOR_FAIRY_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      1909     
                      1910     IF BESCNO == FLYCOLOR_FAIRY_V2_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_V2_30A.INC)	; Select Flycolor Fairy V2 30A pinout
                               ENDIF
                      1914     
                      1915     IF BESCNO == FLYCOLOR_FAIRY_V2_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_V2_30A.INC)	; Select Flycolor Fairy V2 30A pinout
                               ENDIF
                      1919     
                      1920     IF BESCNO == FLYCOLOR_FAIRY_V2_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_V2_30A.INC)	; Select Flycolor Fairy V2 30A pinout
                               ENDIF
                      1924     
                      1925     IF BESCNO == FLYCOLOR_RAPTOR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_RAPTOR_20A.INC)	; Select Flycolor Raptor 20A pinout
                               ENDIF
                      1929     
                      1930     IF BESCNO == FLYCOLOR_RAPTOR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_RAPTOR_20A.INC)	; Select Flycolor Raptor 20A pinout
                               ENDIF
                      1934     
                      1935     IF BESCNO == FLYCOLOR_RAPTOR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_RAPTOR_20A.INC)	; Select Flycolor Raptor 20A pinout
                               ENDIF
                      1939     
                      1940     IF BESCNO == FLYCOLOR_RAPTOR_390_20A_MAIN
                               MODE 	EQU 	0					; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_RAPTOR_390_20A.INC)	; Select Flycolor Raptor 390 20A pinout
                               ENDIF
                      1944     
                      1945     IF BESCNO == FLYCOLOR_RAPTOR_390_20A_TAIL
                               MODE 	EQU 	1					; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_RAPTOR_390_20A.INC)	; Select Flycolor Raptor 390 20A pinout
                               ENDIF
                      1949     
                      1950     IF BESCNO == FLYCOLOR_RAPTOR_390_20A_MULTI
                               MODE 	EQU 	2					; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_RAPTOR_390_20A.INC)	; Select Flycolor Raptor 390 20A pinout
                               ENDIF
                      1954     
                      1955     IF BESCNO == FVT_LITTLEBEE_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_12A.INC)	; Select Favourite Littlebee 12A pinout
                               ENDIF
                      1959     
                      1960     IF BESCNO == FVT_LITTLEBEE_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_12A.INC)	; Select Favourite Littlebee 12A pinout
                               ENDIF
                      1964     
                      1965     IF BESCNO == FVT_LITTLEBEE_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_12A.INC)	; Select Favourite Littlebee 12A pinout
                               ENDIF
                      1969     
                      1970     IF BESCNO == FVT_LITTLEBEE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      1974     
                      1975     IF BESCNO == FVT_LITTLEBEE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      1979     
                      1980     IF BESCNO == FVT_LITTLEBEE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      1984     
                      1985     IF BESCNO == FVT_LITTLEBEE_20A_PRO_MAIN
                               MODE 	EQU 	0					; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_20A_PRO.INC)	; Select Favourite Littlebee 20A Pro pinout
                               ENDIF
                      1989     
                      1990     IF BESCNO == FVT_LITTLEBEE_20A_PRO_TAIL
                               MODE 	EQU 	1					; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_20A_PRO.INC)	; Select Favourite Littlebee 20A Pro pinout
                               ENDIF
                      1994     
                      1995     IF BESCNO == FVT_LITTLEBEE_20A_PRO_MULTI
                               MODE 	EQU 	2					; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_20A_PRO.INC)	; Select Favourite Littlebee 20A Pro pinout
                               ENDIF
                      1999     
                      2000     IF BESCNO == FVT_LITTLEBEE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2004     
                      2005     IF BESCNO == FVT_LITTLEBEE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2009     
                      2010     IF BESCNO == FVT_LITTLEBEE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2014     
                      2015     IF BESCNO == GRAUPNER_ULTRA_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2019     
                      2020     IF BESCNO == GRAUPNER_ULTRA_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2024     
                      2025     IF BESCNO == GRAUPNER_ULTRA_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2029     
                      2030     IF BESCNO == F85_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2034     
                      2035     IF BESCNO == F85_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2039     
                      2040     IF BESCNO == F85_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2044     
                      2045     IF BESCNO == ZTW_SPIDER_PRO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2049     
                      2050     IF BESCNO == ZTW_SPIDER_PRO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2054     
                      2055     IF BESCNO == ZTW_SPIDER_PRO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2059     
                      2060     IF BESCNO == ZTW_SPIDER_PRO_20A_PREMIUM_MAIN
                               MODE 	EQU 	0						; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_PREMIUM.INC)	; Select ZTW Spider Pro 20A Premium pinout
                               ENDIF
                      2064     
                      2065     IF BESCNO == ZTW_SPIDER_PRO_20A_PREMIUM_TAIL
                               MODE 	EQU 	1						; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_PREMIUM.INC)	; Select ZTW Spider Pro 20A Premium pinout
                               ENDIF
                      2069     
                      2070     IF BESCNO == ZTW_SPIDER_PRO_20A_PREMIUM_MULTI
                               MODE 	EQU 	2						; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_PREMIUM.INC)	; Select ZTW Spider Pro 20A Premium pinout
                               ENDIF
                      2074     
                      2075     IF BESCNO == ZTW_SPIDER_PRO_20A_HV_MAIN
                               MODE 	EQU 	0					; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_HV.INC)	; Select ZTW Spider Pro 20A HV pinout
                               ENDIF
                      2079     
                      2080     IF BESCNO == ZTW_SPIDER_PRO_20A_HV_TAIL
                               MODE 	EQU 	1					; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_HV.INC)	; Select ZTW Spider Pro 20A HV pinout
                               ENDIF
                      2084     
                      2085     IF BESCNO == ZTW_SPIDER_PRO_20A_HV_MULTI
                               MODE 	EQU 	2					; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_HV.INC)	; Select ZTW Spider Pro 20A HV pinout
                               ENDIF
                      2089     
                      2090     IF BESCNO == ZTW_SPIDER_PRO_30A_HV_MAIN
                               MODE 	EQU 	0					; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_30A_HV.INC)	; Select ZTW Spider Pro 30A HV pinout
                               ENDIF
                      2094     
                      2095     IF BESCNO == ZTW_SPIDER_PRO_30A_HV_TAIL
                               MODE 	EQU 	1					; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_30A_HV.INC)	; Select ZTW Spider Pro 30A HV pinout
                               ENDIF
                      2099     
                      2100     IF BESCNO == ZTW_SPIDER_PRO_30A_HV_MULTI
                               MODE 	EQU 	2					; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_30A_HV.INC)	; Select ZTW Spider Pro 30A HV pinout
                               ENDIF
                      2104     
                      2105     IF BESCNO == DYS_XM20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DYS_XM20A.INC)			; Select DYS XM20A pinout
                               ENDIF
                      2109     
                      2110     IF BESCNO == DYS_XM20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DYS_XM20A.INC)			; Select DYS XM20A pinout
                               ENDIF
                      2114     
                      2115     IF BESCNO == DYS_XM20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DYS_XM20A.INC)			; Select DYS XM20A pinout
                               ENDIF
                      2119     
                      2120     IF BESCNO == OVERSKY_MR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (OVERSKY_MR_20A.INC)		; Select Oversky MR-20A pinout
                               ENDIF
                      2124     
                      2125     IF BESCNO == OVERSKY_MR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (OVERSKY_MR_20A.INC)		; Select Oversky MR-20A pinout
                               ENDIF
                      2129     
                      2130     IF BESCNO == OVERSKY_MR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (OVERSKY_MR_20A.INC)		; Select Oversky MR-20A pinout
                               ENDIF
                      2134     
                      2135     IF BESCNO == OVERSKY_MR_20A_PRO_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (OVERSKY_MR_20A_PRO.INC)	; Select Oversky MR-20A Pro pinout
                               ENDIF
                      2139     
                      2140     IF BESCNO == OVERSKY_MR_20A_PRO_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (OVERSKY_MR_20A_PRO.INC)	; Select Oversky MR-20A Pro pinout
                               ENDIF
                      2144     
                      2145     IF BESCNO == OVERSKY_MR_20A_PRO_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (OVERSKY_MR_20A_PRO.INC)	; Select Oversky MR-20A Pro pinout
                               ENDIF
                      2149     
                      2150     IF BESCNO == TBS_CUBE_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TBS_CUBE_12A.INC)		; Select TBS Cube 12A pinout
                               ENDIF
                      2154     
                      2155     IF BESCNO == TBS_CUBE_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TBS_CUBE_12A.INC)		; Select TBS Cube 12A pinout
                               ENDIF
                      2159     
                      2160     IF BESCNO == TBS_CUBE_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TBS_CUBE_12A.INC)		; Select TBS Cube 12A pinout
                               ENDIF
                      2164     
                      2165     IF BESCNO == DALRC_XR20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DALRC_XR20A.INC)		; Select DALRC 20A pinout
                               ENDIF
                      2169     
                      2170     IF BESCNO == DALRC_XR20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DALRC_XR20A.INC)		; Select DALRC 20A pinout
                               ENDIF
                      2174     
                      2175     IF BESCNO == DALRC_XR20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DALRC_XR20A.INC)		; Select DALRC 20A pinout
                               ENDIF
                      2179     
                      2180     IF BESCNO == AIKON_BOLTLITE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (AIKON_BOLTLITE_30A.INC)	; Select AIKON_Boltlite 30A pinout
                               ENDIF
                      2184     
                      2185     IF BESCNO == AIKON_BOLTLITE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (AIKON_BOLTLITE_30A.INC)	; Select AIKON_Boltlite 30A pinout
                               ENDIF
                      2189     
                      2190     IF BESCNO == AIKON_BOLTLITE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (AIKON_BOLTLITE_30A.INC)	; Select AIKON_Boltlite 30A pinout
                               ENDIF
                      2194     
                      2195     IF BESCNO == ALIGN_MR25_15A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_MR25_15A.INC)		; Select Align MR25 15A pinout
                               ENDIF
                      2199     
                      2200     IF BESCNO == ALIGN_MR25_15A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_MR25_15A.INC)		; Select Align MR25 15A pinout
                               ENDIF
                      2204     
                      2205     IF BESCNO == ALIGN_MR25_15A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_MR25_15A.INC)		; Select Align MR25 15A pinout
                               ENDIF
                      2209     
                      2210     IF BESCNO == SERVOKING_MONSTER_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SERVOKING_MONSTER_30A.INC)	; Select Servoking Monster 30A pinout
                               ENDIF
                      2214     
                      2215     IF BESCNO == SERVOKING_MONSTER_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SERVOKING_MONSTER_30A.INC)	; Select Servoking Monster 30A pinout
                               ENDIF
                      2219     
                      2220     IF BESCNO == SERVOKING_MONSTER_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SERVOKING_MONSTER_30A.INC)	; Select Servoking Monster 30A pinout
                               ENDIF
                      2224     
                      2225     IF BESCNO == SERVOKING_MONSTER_30A_PRO_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SERVOKING_MONSTER_30A_PRO.INC)	; Select Servoking Monster 30A Pro pinout
                               ENDIF
                      2229     
                      2230     IF BESCNO == SERVOKING_MONSTER_30A_PRO_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SERVOKING_MONSTER_30A_PRO.INC)	; Select Servoking Monster 30A Pro pinout
                               ENDIF
                      2234     
                      2235     IF BESCNO == SERVOKING_MONSTER_30A_PRO_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SERVOKING_MONSTER_30A_PRO.INC)	; Select Servoking Monster 30A Pro pinout
                               ENDIF
                      2239     
                      2240     IF BESCNO == SERVOKING_MONSTER_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SERVOKING_MONSTER_80A.INC)	; Select Servoking Monster 80A pinout
                               ENDIF
                      2244     
                      2245     IF BESCNO == SERVOKING_MONSTER_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SERVOKING_MONSTER_80A.INC)	; Select Servoking Monster 80A pinout
                               ENDIF
                      2249     
                      2250     IF BESCNO == SERVOKING_MONSTER_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SERVOKING_MONSTER_80A.INC)	; Select Servoking Monster 80A pinout
                               ENDIF
                      2254     
                      2255     IF BESCNO == HTIRC_HUMMINGBIRD_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_12A.INC)	; Select HTIRC Hummingbird 12A pinout
                               ENDIF
                      2259     
                      2260     IF BESCNO == HTIRC_HUMMINGBIRD_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_12A.INC)	; Select HTIRC Hummingbird 12A pinout
                               ENDIF
                      2264     
                      2265     IF BESCNO == HTIRC_HUMMINGBIRD_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HTIRC_HUMMINGBIRD_12A.INC)	; Select HTIRC Hummingbird 12A pinout
                               ENDIF
                      2269     
                      2270     IF BESCNO == HTIRC_HUMMINGBIRD_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_20A.INC)	; Select HTIRC Hummingbird 20A pinout
                               ENDIF
                      2274     
                      2275     IF BESCNO == HTIRC_HUMMINGBIRD_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_20A.INC)	; Select HTIRC Hummingbird 20A pinout
                               ENDIF
                      2279     
                      2280     IF BESCNO == HTIRC_HUMMINGBIRD_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HTIRC_HUMMINGBIRD_20A.INC)	; Select HTIRC Hummingbird 20A pinout
                               ENDIF
                      2284     
                      2285     IF BESCNO == HTIRC_HUMMINGBIRD_30A_PRO_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_30A_PRO.INC)	; Select HTIRC Hummingbird 30A Pro pinout
                               ENDIF
                      2289     
                      2290     IF BESCNO == HTIRC_HUMMINGBIRD_30A_PRO_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_30A_PRO.INC)	; Select HTIRC Hummingbird 30A Pro pinout
                               ENDIF
                      2294     
                      2295     IF BESCNO == HTIRC_HUMMINGBIRD_30A_PRO_MULTI
  0002                2296     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                      2297     $INCLUDE (HTIRC_HUMMINGBIRD_30A_PRO.INC)	; Select HTIRC Hummingbird 30A Pro pinout
                      2899     ENDIF
                      2900     
                      2901     
                      2902     
                      2903     ;**** **** **** **** ****
                      2904     ; TX programming defaults
                      2905     ;
                      2906     ; Parameter dependencies:
                      2907     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                      2908     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                      2909     ;
                      2910     ; MAIN
  0007                2911     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                2912     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                2913     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                2914     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                2915     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                2916     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2917     IF DAMPED_MODE_ENABLE == 1
  0002                2918     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
                      2919     ELSE
                               DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low	
                               ENDIF
  0001                2922     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2923     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                2924     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                2925     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                2926     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                2927     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                2928     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                2929     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                      2930     
                      2931     ; TAIL
  0003                2932     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                2933     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                2934     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2935     IF DAMPED_MODE_ENABLE == 1
  0003                2936     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low 		3=DampedLight 
                      2937     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		
                               ENDIF
  0001                2940     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2941     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2942     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                2943     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                2944     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                2945     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2946     DEFAULT_PGM_TAIL_PWM_DITHER		EQU 3 	; 1=Off		2=3			3=7			4=15			5=31
                      2947     
                      2948     ; MULTI
  0009                2949     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                2950     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                2951     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                2952     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0003                2953     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2954     IF DAMPED_MODE_ENABLE == 1
  0003                2955     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low 		3=DampedLight 
                      2956     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low
                               ENDIF
  0003                2959     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 3 	; 1=Disabled	2=Low		3=High
  0001                2960     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2961     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0050                2962     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 80	; Beep strength
  0050                2963     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 80	; Beacon strength
  0004                2964     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2965     DEFAULT_PGM_MULTI_PWM_DITHER		EQU 3 	; 1=Off		2=3			3=7			4=15			5=31
                      2966     
                      2967     ; COMMON
  0001                2968     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 1 	; 1=Enabled 	0=Disabled
  000A                2969     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 10	; 4*10+1000=1040
  00F0                2970     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 240	; 4*240+1000=1960
  007D                2971     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 125	; 4*125+1000=1500 (used in bidirectional mode)
  0000                2972     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0=Low		1+= High or higher	
  0001                2973     DEFAULT_PGM_ENABLE_TEMP_PROT	 	EQU 1 	; 1=Enabled 	0=Disabled
  0001                2974     DEFAULT_PGM_ENABLE_POWER_PROT 	EQU 1 	; 1=Enabled 	0=Disabled
  0000                2975     DEFAULT_PGM_ENABLE_PWM_INPUT	 	EQU 0 	; 1=Enabled 	0=Disabled
  0001                2976     DEFAULT_PGM_BRAKE_ON_STOP	 	EQU 1 	; 1=Enabled 	0=Disabled
                      2977     
                      2978     ;**** **** **** **** ****
                      2979     ; Constant definitions for main
                      2980     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2999     ; Constant definitions for tail
                      3000     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      3019     ; Constant definitions for multi
                      3020     IF MODE == 2
                      3021     
  0001                3022     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
  000A                3023     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                3024     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                3025     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                3026     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                3027     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                3028     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                3029     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                3030     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                      3031     
  0032                3032     PWM_START			EQU	50 	; PWM used as max power during start
                      3033     
  0001                3034     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                      3035     
  0008                3036     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                      3037     
                      3038     ENDIF
                      3039     
                      3040     ;**** **** **** **** ****
                      3041     ; Temporary register definitions
  REG                 3042     TEMP1		EQU	R0
  REG                 3043     TEMP2		EQU	R1
  REG                 3044     TEMP3		EQU	R2
  REG                 3045     TEMP4		EQU	R3
  REG                 3046     TEMP5		EQU	R4
  REG                 3047     TEMP6		EQU	R5
  REG                 3048     TEMP7		EQU	R6
  REG                 3049     TEMP8		EQU	R7
                      3050     
                      3051     ;**** **** **** **** ****
                      3052     ; Register definitions
------                3053     DSEG AT 20H					; Variables segment 
                      3054     
0020                  3055     BIT_ACCESS: 				DS	1		; MUST BE AT THIS ADDRESS. Variable at bit accessible address (for non interrupt routines)
0021                  3056     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                      3057     
0022                  3058     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                  3059     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                  3060     CURRENT_PWM: 				DS	1		; Current pwm
0025                  3061     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited
0026                  3062     CURRENT_PWM_LIM_DITH: 		DS	1		; Current pwm that is limited and dithered (applied to the motor output)
0027                  3063     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0028                  3064     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0029                  3065     RCP_OUTSIDE_RANGE_CNT: 		DS	1		; RC pulse outside range counter (incrementing) 
002A                  3066     RCP_TIMEOUT_CNTD: 			DS	1		; RC pulse timeout counter (decrementing) 
002B                  3067     RCP_SKIP_CNTD: 				DS	1		; RC pulse skip counter (decrementing) 
                      3068     
002C                  3069     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                3070     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                3071     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                3072     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                3073     PWM_TIMER0_OVERFLOW			EQU	3		; Set for 48MHz MCUs when PWM timer 0 overflows
  0004                3074     DEMAG_DETECTED				EQU 	4		; Set when excessive demag time is detected
  0005                3075     DEMAG_CUT_POWER			EQU 	5		; Set when demag compensation cuts power
  0006                3076     HIGH_RPM					EQU 	6		; Set when motor rpm is high (Comm_Period4x_H less than 2)
                      3077     ;						EQU 	7	
                      3078     
002D                  3079     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                3080     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                3081     STARTUP_PHASE				EQU 	1		; Set when in startup phase
  0002                3082     INITIAL_RUN_PHASE			EQU	2		; Set when in initial run phase, before synchronized run is achieved
  0003                3083     MOTOR_STARTED				EQU 	3		; Set when motor is started
  0004                3084     DIR_CHANGE_BRAKE			EQU 	4		; Set when braking before direction change
  0005                3085     COMP_TIMED_OUT				EQU 	5		; Set when comparator reading timed out
  0006                3086     GOV_ACTIVE				EQU 	6		; Set when governor is active (enabled when speed is above minimum)
  0007                3087     SKIP_DAMP_ON				EQU 	7 		; Set when turning damping fet on is skipped
                      3088     
002E                  3089     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                3090     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                3091     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                3092     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode
  0003                3093     PGM_PWM_HIGH_FREQ			EQU	3		; Progremmed pwm high frequency
  0004                3094     RCP_PPM					EQU 	4		; RC pulse ppm type input (set also when oneshot is set)
  0005                3095     RCP_PPM_ONESHOT125			EQU 	5		; RC pulse ppm type input is OneShot125
  0006                3096     RCP_DIR_REV				EQU 	6		; RC pulse direction in bidirectional mode
                      3097     ;						EQU 	7	
                      3098     
002F                  3099     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                3100     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                3101     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                3102     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                3103     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                3104     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                3105     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                3106     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                3107     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                      3108     
                      3109     
                      3110     ;**** **** **** **** ****
                      3111     ; RAM definitions
------                3112     DSEG AT 30H						; Ram data segment, direct addressing
                      3113     
0030                  3114     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                      3115     
0031                  3116     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                  3117     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                      3118     
0033                  3119     STARTUP_CNT: 				DS	1		; Startup phase commutations counter (incrementing)
0034                  3120     STARTUP_ZC_TIMEOUT_CNTD: 		DS	1		; Startup zero cross timeout counter (decrementing)
0035                  3121     INITIAL_RUN_ROT_CNTD: 		DS	1		; Initial run rotations counter (decrementing)
0036                  3122     STALL_CNT: 				DS	1		; Counts start/run attempts that resulted in stall. Reset upon a proper stop
0037                  3123     DEMAG_DETECTED_METRIC: 		DS	1		; Metric used to gauge demag event frequency
0038                  3124     DEMAG_PWR_OFF_THRESH: 		DS	1		; Metric threshold above which power is cut
0039                  3125     LOW_RPM_PWR_SLOPE: 			DS	1		; Sets the slope of power increase for low rpms
                      3126     
003A                  3127     TIMER2_X: 					DS	1		; Timer 2 extended byte
003B                  3128     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003C                  3129     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003D                  3130     PREV_COMM_X: 				DS	1		; Previous commutation timer3 timestamp (ext byte)
003E                  3131     PREV_PREV_COMM_L: 			DS	1		; Pre-previous commutation timer3 timestamp (lo byte)
003F                  3132     PREV_PREV_COMM_H: 			DS	1		; Pre-previous commutation timer3 timestamp (hi byte)
0040                  3133     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
0041                  3134     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
0042                  3135     COMM_PHASE: 				DS	1		; Current commutation phase
0043                  3136     COMPARATOR_READ_CNT:  		DS	1		; Number of comparator reads done
                      3137     
0044                  3138     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0045                  3139     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0046                  3140     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0047                  3141     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0048                  3142     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0049                  3143     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
004A                  3144     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
004B                  3145     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
004C                  3146     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
                      3147     
004D                  3148     WT_ADV_START_L: 			DS	1		; Timer3 start point for commutation advance timing (lo byte)
004E                  3149     WT_ADV_START_H: 			DS	1		; Timer3 start point for commutation advance timing (hi byte)
004F                  3150     WT_ZC_SCAN_START_L: 			DS	1		; Timer3 start point from commutation to zero cross scan (lo byte)
0050                  3151     WT_ZC_SCAN_START_H: 			DS	1		; Timer3 start point from commutation to zero cross scan (hi byte)
0051                  3152     WT_ZC_TOUT_START_L: 			DS	1		; Timer3 start point for zero cross scan timeout (lo byte)
0052                  3153     WT_ZC_TOUT_START_H: 			DS	1		; Timer3 start point for zero cross scan timeout (hi byte)
0053                  3154     WT_COMM_START_L: 			DS	1		; Timer3 start point from zero cross to commutation (lo byte)
0054                  3155     WT_COMM_START_H: 			DS	1		; Timer3 start point from zero cross to commutation (hi byte)
                      3156     
0055                  3157     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0056                  3158     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0057                  3159     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0058                  3160     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0059                  3161     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
005A                  3162     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
005B                  3163     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
005C                  3164     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005D                  3165     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005E                  3166     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005F                  3167     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
0060                  3168     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                      3169     
0061                  3170     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
0062                  3171     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup
0063                  3172     PWM_LIMIT_BY_RPM: 			DS	1		; Maximum allowed pwm for low or high rpms
0064                  3173     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0065                  3174     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0066                  3175     PWM_DITHER_DECODED: 			DS	1		; Decoded pwm dither value
0067                  3176     PWM_DITHER_EXCESS_POWER: 		DS	1		; Excess power (above max) from pwm dither
0068                  3177     RANDOM: 					DS	1		; Random number from LFSR 
                      3178     
0069                  3179     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
006A                  3180     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
006B                  3181     MAIN_SPOOLUP_TIME_3X: 		DS	1		; Main spoolup time x3
006C                  3182     MAIN_SPOOLUP_TIME_10X: 		DS	1		; Main spoolup time x10
006D                  3183     MAIN_SPOOLUP_TIME_15X: 		DS	1		; Main spoolup time x15
                      3184     
006E                  3185     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006F                  3186     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
0070                  3187     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                      3188     
0071                  3189     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                      3190     
0072                  3191     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
0073                  3192     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                      3193     
0074                  3194     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0075                  3195     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0076                  3196     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                      3197     
0077                  3198     SKIP_T2_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 interrupt shall be ignored 
0078                  3199     SKIP_T2H_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 high interrupt shall be ignored 
0079                  3200     TIMER0_OVERFLOW_VALUE: 		DS	1		; Remaining timer 0 wait time used with 48MHz MCUs
007A                  3201     CLOCK_SET_AT_48MHZ: 			DS	1		; Variable set if 48MHz MCUs run at 48MHz
007B                  3202     DAMPINGFET: 				DS	1		; Port position of fet used for damping
                      3203     
007C                  3204     FLASH_KEY_1: 				DS	1		; Flash key one
007D                  3205     FLASH_KEY_2: 				DS	1		; Flash key two
                      3206     
                      3207     ; Indirect addressing data segment. The variables below must be in this sequence
------                3208     ISEG AT 080H					
0080                  3209     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  3210     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  3211     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  3212     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  3213     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  3214     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  3215     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  3216     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  3217     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  3218     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  3219     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  3220     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  3221     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  3222     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  3223     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  3224     _PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm (unused - place holder)
0090                  3225     _PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration (unused - place holder)
0091                  3226     _PGM_VOLT_COMP: 			DS	1		; Place holder
0092                  3227     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  3228     _PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force (unused - place holder)
0094                  3229     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  3230     _PGM_STARTUP_METHOD: 		DS	1		; Programmed startup method (unused - place holder)
0096                  3231     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  3232     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  3233     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  3234     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  3235     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  3236     _PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate (unused - place holder)
009C                  3237     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  3238     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  3239     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
009F                  3240     PGM_MAIN_SPOOLUP_TIME: 		DS	1		; Programmed main spoolup time
00A0                  3241     PGM_ENABLE_TEMP_PROT: 		DS	1		; Programmed temperature protection enable
00A1                  3242     PGM_ENABLE_POWER_PROT: 		DS	1		; Programmed low rpm power protection enable
00A2                  3243     PGM_ENABLE_PWM_INPUT: 		DS	1		; Programmed PWM input signal enable
00A3                  3244     PGM_PWM_DITHER: 			DS	1		; Programmed output PWM dither
00A4                  3245     PGM_BRAKE_ON_STOP: 			DS	1		; Programmed braking when throttle is zero
                      3246     
                      3247     ; The sequence of the variables below is no longer of importance
00A5                  3248     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A6                  3249     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A7                  3250     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
                      3251     
                      3252     
                      3253     ; Indirect addressing data segment
------                3254     ISEG AT 0D0H					
00D0                  3255     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      3256     
                      3257     
                      3258     ;**** **** **** **** ****
------                3259     CSEG AT 1A00H            ; "Eeprom" segment
  000E                3260     EEPROM_FW_MAIN_REVISION		EQU	14		; Main revision of the firmware
  004B                3261     EEPROM_FW_SUB_REVISION		EQU	75		; Sub revision of the firmware
  0015                3262     EEPROM_LAYOUT_REVISION		EQU	21		; Revision of the EEPROM layout
                      3263     
1A00    0E            3264     EEP_FW_MAIN_REVISION:  DB 14 
1A01    4B            3265     EEP_FW_SUB_REVISION:  DB 75 
1A02    15            3266     EEP_LAYOUT_REVISION:  DB 21 
                      3267     
                      3268     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH	
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH	
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH						
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH	
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH	
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							
                               EEP_PGM_MAIN_SPOOLUP_TIME:	DB	DEFAULT_PGM_MAIN_SPOOLUP_TIME		; EEPROM copy of programmed main spoolup time
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               _EEP_PGM_PWM_DITHER:		DB	0FFH	
                               EEP_PGM_BRAKE_ON_STOP:		DB	DEFAULT_PGM_BRAKE_ON_STOP		; EEPROM copy of programmed braking when throttle is zero
                               ENDIF 
                      3307     
                      3308     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               _EEP_PGM_MAIN_SPOOLUP_TIME:	DB	0FFH
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               EEP_PGM_PWM_DITHER:			DB	DEFAULT_PGM_TAIL_PWM_DITHER		; EEPROM copy of programmed output PWM dither
                               EEP_PGM_BRAKE_ON_STOP:		DB	DEFAULT_PGM_BRAKE_ON_STOP		; EEPROM copy of programmed braking when throttle is zero
                               ENDIF
                      3347     
                      3348     IF MODE == 2
1A03    09            3349     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            3350     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            3351     EEP_PGM_GOV_MODE:  DB 4 
1A06    FF            3352     _EEP_PGM_LOW_VOLTAGE_LIM: 	DB	0FFH							
1A07    03            3353     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            3354     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    0A            3355     EEP_PGM_STARTUP_PWR:  DB 10 
1A0A    03            3356     EEP_PGM_PWM_FREQ:  DB 3 
1A0B    01            3357     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            3358     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            3359     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            3360     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    01            3361     EEP_ENABLE_TX_PROGRAM:  DB 1 
1A10    FF            3362     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            3363     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    FF            3364     _EEP_PGM_STARTUP_RPM: 		DB	0FFH
1A13    FF            3365     _EEP_PGM_STARTUP_ACCEL: 		DB	0FFH
1A14    FF            3366     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            3367     EEP_PGM_COMM_TIMING:  DB 3 
1A16    FF            3368     _EEP_PGM_DAMPING_FORCE: 		DB	0FFH
1A17    FF            3369     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    FF            3370     _EEP_PGM_STARTUP_METHOD: 		DB	0FFH
1A19    0A            3371     EEP_PGM_PPM_MIN_THROTTLE:  DB 10 
1A1A    F0            3372     EEP_PGM_PPM_MAX_THROTTLE:  DB 240 
1A1B    50            3373     EEP_PGM_BEEP_STRENGTH:  DB 80 
1A1C    50            3374     EEP_PGM_BEACON_STRENGTH:  DB 80 
1A1D    04            3375     EEP_PGM_BEACON_DELAY:  DB 4 
1A1E    FF            3376     _EEP_PGM_THROTTLE_RATE: 		DB	0FFH
1A1F    03            3377     EEP_PGM_DEMAG_COMP:  DB 3 
1A20    00            3378     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7D            3379     EEP_PGM_PPM_CENTER_THROTTLE:  DB 125 
1A22    FF            3380     _EEP_PGM_MAIN_SPOOLUP_TIME: 	DB	0FFH
1A23    01            3381     EEP_PGM_TEMP_PROT_ENABLE:  DB 1 
1A24    01            3382     EEP_PGM_ENABLE_POWER_PROT:  DB 1 
1A25    00            3383     EEP_PGM_ENABLE_PWM_INPUT:  DB 0 
1A26    03            3384     EEP_PGM_PWM_DITHER:  DB 3 
1A27    01            3385     EEP_PGM_BRAKE_ON_STOP:  DB 1 
                      3386     ENDIF
                      3387     
1A28    FF            3388     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      3389     
------                3390     CSEG AT 1A60H
1A60    20202020      3391     EEP_NAME: 					DB	"                "				; Name tag (16 Bytes)
1A64    20202020
1A68    20202020
1A6C    20202020
                      3392     
                      3393     ;**** **** **** **** ****
                      3394     		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                3394+1   CSEG AT 0  ; CODE SEGMENT START
0000    0219FD        3394+1   JMP RESET 
------                3394+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200AA        3394+1   JMP T0_INT 
------                3394+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    020187        3394+1   JMP T2_INT 
------                3394+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    02033B        3394+1   JMP PCA_INT 
------                3394+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    020328        3394+1   JMP T3_INT 
------                3395     CSEG AT 80H			; Code segment after interrupt vectors 
                      3396     
                      3397     ;**** **** **** **** ****
                      3398     
                      3399     ; Table definitions
0080    02030406      3400     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    0406080C      3401     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
0091    10182030
0095    406080A0
0099    C0
009A    0003070F      3402     PWM_DITHER_TABLE:   		DB 	00H, 03H, 07H, 0FH, 1FH
009E    1F
                      3403     IF MODE == 0
                                 IF DAMPED_MODE_ENABLE == 1
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 3, 3, 2, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 2, 3, 2, 2
                                 ENDIF
                               ENDIF
                      3411     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 3, 5, 3, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF
                               ENDIF
                      3419     IF MODE == 2
                      3420       IF DAMPED_MODE_ENABLE == 1
009F    0D0D0405      3421     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 13, 5, 3, 5, 3, 3, 2
00A3    0D050305
00A7    030302
                      3422       ENDIF
                      3423       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF 
                      3426     ENDIF
                      3427     
                      3428     
                      3429     
                      3430     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3431     ;
                      3432     ; Timer0 interrupt routine
                      3433     ;
                      3434     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      3435     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      3436     ;
                      3437     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3438     T0_INT: 	; Used for pwm control
00AA    C2AF          3439     	CLR 	EA			; Disable all interrupts
                      3440     IF MCU_48MHZ == 1
                      3441     	; Check overflow flag
00AC    306308        3442     JNB FLAGS0 . 3 , T0_INT_START 
                      3443     
00AF    C263          3444     CLR FLAGS0 . 3 
00B1    85798A        3445     	MOV	TL0, TIMER0_OVERFLOW_VALUE	; Set timer 
00B4    D2AF          3446     	SETB	EA			; Enable all interrupts
00B6    32            3447     	RETI
                      3448     
                      3449     T0_INT_START: 
                      3450     ENDIF
00B7    C0D0          3451     	PUSH	PSW			; Preserve registers through interrupt
00B9    C0E0          3452     	PUSH	ACC		
                      3453     	; Check if pwm is on
00BB    206221        3454     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      3455     
                      3456     	; Pwm on cycle
00BE    E525          3457     	MOV	A, CURRENT_PWM_LIMITED
00C0    6016          3458     	JZ	T0_INT_PWM_ON_RET
                      3459     
00C2    E4            3460     	CLR	A					
00C3    73            3461     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      3462     
                      3463     T0_INT_PWM_ON_EXIT: 
                      3464     	; Set timer for coming on cycle length
00C4    E525          3465     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
00C6    F4            3466     	CPL	A						; cpl is 255-x
                      3467     IF MCU_48MHZ == 0
                               	MOV	TL0, A					; Write start point for timer
                               ELSE
00C7    C3            3470     	CLR	C
00C8    33            3471     	RLC	A
00C9    4009          3472     	JC	T0_INT_PWM_ON_SET_TIMER
                      3473     
00CB    758A00        3474     	MOV	TL0, #0
00CE    D263          3475     SETB FLAGS0 . 3 
00D0    F579          3476     	MOV	TIMER0_OVERFLOW_VALUE, A
00D2    01D6          3477     	AJMP	T0_INT_PWM_ON_TIMER_SET
                      3478     
                      3479     T0_INT_PWM_ON_SET_TIMER: 
00D4    F58A          3480     	MOV	TL0, A
                      3481     T0_INT_PWM_ON_TIMER_SET: 
                      3482     ENDIF
                      3483     	; Set other variables
00D6    D262          3484     SETB FLAGS0 . 2 
                      3485     T0_INT_PWM_ON_RET: 
                      3486     	; Exit interrupt
00D8    D0E0          3487     	POP	ACC			; Restore preserved registers
00DA    D0D0          3488     	POP	PSW
00DC    D2AF          3489     	SETB	EA			; Enable all interrupts
00DE    32            3490     	RETI
                      3491     
                      3492     
                      3493     	; Pwm off cycle
                      3494     T0_INT_PWM_OFF: 
                      3495     IF MCU_48MHZ == 0
                               	MOV	TL0, CURRENT_PWM_LIM_DITH	; Load new timer setting
                               ELSE
00DF    C3            3498     	CLR	C
00E0    E526          3499     	MOV	A, CURRENT_PWM_LIM_DITH
00E2    33            3500     	RLC	A
00E3    4009          3501     	JC	T0_INT_PWM_OFF_SET_TIMER 
                      3502     
00E5    758A00        3503     	MOV	TL0, #0
00E8    D263          3504     SETB FLAGS0 . 3 
00EA    F579          3505     	MOV	TIMER0_OVERFLOW_VALUE, A
00EC    01F0          3506     	AJMP	T0_INT_PWM_OFF_TIMER_SET
                      3507     
                      3508     T0_INT_PWM_OFF_SET_TIMER: 
00EE    F58A          3509     	MOV	TL0, A
                      3510     T0_INT_PWM_OFF_TIMER_SET: 
                      3511     ENDIF
                      3512     	; Clear pwm on flag
00F0    C262          3513     CLR FLAGS0 . 2 
                      3514     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00F2    E526          3515     	MOV	A, CURRENT_PWM_LIM_DITH		; Load current pwm
00F4    F4            3516     	CPL	A						; Full pwm?
00F5    602F          3517     	JZ	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      3518     
                      3519     IF DAMPED_MODE_ENABLE == 1
                      3520     	; Do not execute pwm off when stopped
00F7    306825        3521     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_EXIT 
                      3522     
                      3523     	; If damped operation, set pFETs on in pwm_off
00FA    20720D        3524     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      3525     ENDIF
                      3526     
                      3527     T0_INT_PWM_OFF_EXIT_NFETS_OFF: 	
                      3528     	; Separate exit commands here for minimum delay
                      3529     IF NFETON_DELAY == 0
                               	EN_OFF			; For EN/PWM style drivers. Uses accumulator
                               ENDIF
00FD    D0E0          3532     	POP	ACC			; Restore preserved registers
00FF    D0D0          3533     	POP	PSW
                      3534     IF NFETON_DELAY NE 0
                      3535     	ALL_NFETS_OFF 		; Switch off all nfets
0101    C295          3535+1   CLR P1 . 5 
0103    C293          3535+1   CLR P1 . 3 
0105    C297          3535+1   CLR P1 . 7 
                      3536     ENDIF
0107    D2AF          3537     	SETB	EA			; Enable all interrupts
0109    32            3538     	RETI
                      3539     
                      3540     T0_INT_PWM_OFF_DAMPED: 
                      3541     IF PFETON_DELAY < 128
                      3542     IF PFETON_DELAY NE 0
                      3543     	ALL_NFETS_OFF 				; Switch off all nfets
010A    C295          3543+1   CLR P1 . 5 
010C    C293          3543+1   CLR P1 . 3 
010E    C297          3543+1   CLR P1 . 7 
                      3544     ELSE
                               	EN_OFF
                               ENDIF
0110    206F0C        3547     JB FLAGS1 . 7 , T0_INT_PWM_OFF_DAMP_DONE 
0113    206509        3548     JB FLAGS0 . 5 , T0_INT_PWM_OFF_DAMP_DONE 
                      3549     IF PFETON_DELAY NE 0
0116    7418          3550     MOV A , # 24 
0118    D5E0FD        3551     	DJNZ	ACC, $	
                      3552     ENDIF
                      3553     	DAMPING_FET_ON
011B    E57B          3553+1   MOV A , DAMPINGFET 
011D    4290          3553+1   ORL P1 , A 
                      3554     T0_INT_PWM_OFF_DAMP_DONE: 
                      3555     ENDIF
                      3556     IF PFETON_DELAY >= 128			; "Negative", 1's complement
                               	JB	FLAGS1.SKIP_DAMP_ON, T0_INT_PWM_OFF_DAMP_DONE
                               	JB	FLAGS0.DEMAG_CUT_POWER, T0_INT_PWM_OFF_DAMP_DONE 
                               	DAMPING_FET_ON				; Damping fet on
                               	MOV	A, #PFETON_DELAY
                               	CPL	A
                               	DJNZ	ACC, $	
                               T0_INT_PWM_OFF_DAMP_DONE:
                               	ALL_NFETS_OFF 				; Switch off all nfets
                               ENDIF
                      3566     T0_INT_PWM_OFF_EXIT: 	
011F    D0E0          3567     	POP	ACC			; Restore preserved registers
0121    D0D0          3568     	POP	PSW
0123    D2AF          3569     	SETB	EA			; Enable all interrupts
0125    32            3570     	RETI
                      3571     
                      3572     T0_INT_PWM_OFF_FULLPOWER_EXIT:  
0126    758A00        3573     	MOV	TL0, #0		; Set long time till next interrupt
                      3574     IF MCU_48MHZ == 1
0129    D263          3575     SETB FLAGS0 . 3 
012B    757900        3576     	MOV	TIMER0_OVERFLOW_VALUE, #0
                      3577     ENDIF
012E    C28D          3578     	CLR	TF0			; Clear interrupt flag
0130    D262          3579     SETB FLAGS0 . 2 
0132    211F          3580     	AJMP	T0_INT_PWM_OFF_EXIT
                      3581     
                      3582     
                      3583     PWM_NOFET: 	; Dummy pwm on cycle
0134    01C4          3584     	AJMP	T0_INT_PWM_ON_EXIT
                      3585     
                      3586     PWM_AFET: 		; Pwm on cycle afet on
0136    306805        3587     JNB FLAGS1 . 0 , PWM_AFET_EXIT 
0139    206502        3588     JB FLAGS0 . 5 , PWM_AFET_EXIT 
                      3589     	ANFET_ON	
013C    D295          3589+1   SETB P1 . 5 
                      3590     PWM_AFET_EXIT: 
013E    01C4          3591     	AJMP	T0_INT_PWM_ON_EXIT
                      3592     
                      3593     PWM_BFET: 		; Pwm on cycle bfet on
0140    306805        3594     JNB FLAGS1 . 0 , PWM_BFET_EXIT 
0143    206502        3595     JB FLAGS0 . 5 , PWM_BFET_EXIT 
                      3596     	BNFET_ON
0146    D297          3596+1   SETB P1 . 7 
                      3597     PWM_BFET_EXIT: 
0148    01C4          3598     	AJMP	T0_INT_PWM_ON_EXIT
                      3599     
                      3600     PWM_CFET: 		; Pwm on cycle cfet on
014A    306805        3601     JNB FLAGS1 . 0 , PWM_CFET_EXIT 
014D    206502        3602     JB FLAGS0 . 5 , PWM_CFET_EXIT 
                      3603     	CNFET_ON
0150    D293          3603+1   SETB P1 . 3 
                      3604     PWM_CFET_EXIT: 
0152    01C4          3605     	AJMP	T0_INT_PWM_ON_EXIT
                      3606     
                      3607     PWM_AFET_DAMPED: 	
                      3608     IF NFETON_DELAY NE 0
                      3609     	APFET_OFF
0154    C294          3609+1   CLR P1 . 4 
                      3610     ENDIF
0156    30680A        3611     JNB FLAGS1 . 0 , PWM_AFET_DAMPED_EXIT 
0159    206507        3612     JB FLAGS0 . 5 , PWM_AFET_DAMPED_EXIT 
                      3613     IF NFETON_DELAY NE 0
015C    7418          3614     MOV A , # 24 
015E    D5E0FD        3615     	DJNZ ACC,	$
                      3616     ENDIF
                      3617     PWM_AFET_DAMPED_DONE: 
                      3618     	ANFET_ON								; Switch nFET
0161    D295          3618+1   SETB P1 . 5 
                      3619     PWM_AFET_DAMPED_EXIT: 
0163    01C4          3620     	AJMP	T0_INT_PWM_ON_EXIT
                      3621     
                      3622     PWM_BFET_DAMPED: 
                      3623     IF NFETON_DELAY NE 0
                      3624     	BPFET_OFF
0165    C296          3624+1   CLR P1 . 6 
                      3625     ENDIF
0167    30680A        3626     JNB FLAGS1 . 0 , PWM_BFET_DAMPED_EXIT 
016A    206507        3627     JB FLAGS0 . 5 , PWM_BFET_DAMPED_EXIT 
                      3628     IF NFETON_DELAY NE 0
016D    7418          3629     MOV A , # 24 
016F    D5E0FD        3630     	DJNZ ACC,	$
                      3631     ENDIF
                      3632     PWM_BFET_DAMPED_DONE: 
                      3633     	BNFET_ON								; Switch nFET
0172    D297          3633+1   SETB P1 . 7 
                      3634     PWM_BFET_DAMPED_EXIT: 
0174    01C4          3635     	AJMP	T0_INT_PWM_ON_EXIT
                      3636     
                      3637     PWM_CFET_DAMPED: 	
                      3638     IF NFETON_DELAY NE 0
                      3639     	CPFET_OFF
0176    C292          3639+1   CLR P1 . 2 
                      3640     ENDIF
0178    30680A        3641     JNB FLAGS1 . 0 , PWM_CFET_DAMPED_EXIT 
017B    206507        3642     JB FLAGS0 . 5 , PWM_CFET_DAMPED_EXIT 
                      3643     IF NFETON_DELAY NE 0
017E    7418          3644     MOV A , # 24 
0180    D5E0FD        3645     	DJNZ ACC,	$
                      3646     ENDIF
                      3647     PWM_CFET_DAMPED_DONE: 
                      3648     	CNFET_ON								; Switch nFET
0183    D293          3648+1   SETB P1 . 3 
                      3649     PWM_CFET_DAMPED_EXIT:  
0185    01C4          3650     	AJMP	T0_INT_PWM_ON_EXIT
                      3651     
                      3652     
                      3653     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3654     ;
                      3655     ; Timer2 interrupt routine
                      3656     ;
                      3657     ; No assumptions
                      3658     ;
                      3659     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3660     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
0187    C2AF          3661     	CLR	EA
0189    C2AD          3662     	CLR	ET2			; Disable timer2 interrupts
018B    53E6EF        3663     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
018E    C0D0          3664     	PUSH	PSW			; Preserve registers through interrupt
0190    C0E0          3665     	PUSH	ACC
0192    D2D3          3666     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0194    D2AF          3667     	SETB	EA
                      3668     IF MCU_48MHZ == 1
0196    E57A          3669     	MOV	A, CLOCK_SET_AT_48MHZ
0198    6009          3670     	JZ 	T2_INT_START
                      3671     
                      3672     	; Check skip variable
019A    E577          3673     	MOV	A, SKIP_T2_INT
019C    6005          3674     	JZ	T2_INT_START				; Execute this interrupt
                      3675     
019E    757700        3676     	MOV	SKIP_T2_INT, #0
01A1    41D5          3677     	AJMP	T2_INT_EXIT
                      3678     
                      3679     T2_INT_START: 
01A3    757701        3680     	MOV	SKIP_T2_INT, #1			; Skip next interrupt
                      3681     ENDIF
                      3682     	; Clear low byte interrupt flag
01A6    C2CE          3683     	CLR	TF2L						; Clear interrupt flag
                      3684     	; Check RC pulse timeout counter
01A8    E52A          3685     	MOV	A, RCP_TIMEOUT_CNTD			; RC pulse timeout count zero?
01AA    6007          3686     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      3687     
                      3688     	; Decrement timeout counter (if PWM)
01AC    207449        3689     JB FLAGS2 . 4 , T2_INT_SKIP_START 
                      3690     
01AF    152A          3691     	DEC	RCP_TIMEOUT_CNTD			; No - decrement
01B1    21F8          3692     	AJMP	T2_INT_SKIP_START
                      3693     
                      3694     T2_INT_PULSES_ABSENT: 
                      3695     	; Timeout counter has reached zero, pulses are absent
01B3    7800          3696     MOV R0 , # 0 
01B5    7900          3697     MOV R1 , # 0 
01B7    20742E        3698     JB FLAGS2 . 4 , T2_INT_PULSES_ABSENT_NO_MAX 
                      3699     
                      3700     	READ_RCP_INT 					; Look at value of Rcp_In
01BA    E580          3700+1   MOV A , P0 
01BC    307E01        3700+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
01BF    F4            3700+1   CPL A  ; YES - INVERT
01C0    30E502        3701     JNB ACC . 5 , ( $+5 ) 
01C3    78FF          3702     MOV R0 , # 255 
                      3703     	RCP_INT_FIRST 					; Set interrupt trig to first again
01C5    53DACF        3703+1   ANL PCA0CPM0 , # 0CFH 
01C8    207E03        3703+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
01CB    43DA20        3703+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
01CE    307E03        3703+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
01D1    43DA10        3703+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3704     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
01D4    C2D8          3704+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
01D6    C271          3705     CLR FLAGS2 . 1 
                      3706     	READ_RCP_INT 					; Look once more at value of Rcp_In
01D8    E580          3706+1   MOV A , P0 
01DA    307E01        3706+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
01DD    F4            3706+1   CPL A  ; YES - INVERT
01DE    30E502        3707     JNB ACC . 5 , ( $+5 ) 
01E1    79FF          3708     MOV R1 , # 255 
01E3    C3            3709     	CLR	C
01E4    E8            3710     MOV A , R0 
01E5    99            3711     SUBB A , R1 
01E6    70CB          3712     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      3713     
                      3714     T2_INT_PULSES_ABSENT_NO_MAX: 
01E8    306103        3715     JNB FLAGS0 . 1 , ( $+6 ) 
                      3716     
01EB    752A18        3717     MOV RCP_TIMEOUT_CNTD , # 24 
                      3718     
01EE    207403        3719     JB FLAGS2 . 4 , T2_INT_PPM_TIMEOUT_SET 
                      3720     
01F1    752A18        3721     MOV RCP_TIMEOUT_CNTD , # 24 
                      3722     
                      3723     T2_INT_PPM_TIMEOUT_SET: 
01F4    885C          3724     MOV NEW_RCP , R0 
01F6    D270          3725     SETB FLAGS2 . 0 
                      3726     
                      3727     T2_INT_SKIP_START: 
01F8    20740D        3728     JB FLAGS2 . 4 , T2_INT_RCP_UPDATE_START 
                      3729     
                      3730     	; Check RC pulse skip counter
01FB    E52B          3731     	MOV	A, RCP_SKIP_CNTD			
01FD    6004          3732     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      3733     	
                      3734     	; Decrement skip counter (only if edge counter is zero)
01FF    152B          3735     	DEC	RCP_SKIP_CNTD				; Decrement
0201    4108          3736     	AJMP	T2_INT_RCP_UPDATE_START
                      3737     
                      3738     T2_INT_SKIP_END: 
                      3739     	; Skip counter has reached zero, start looking for RC pulses again
                      3740     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0203    43DA01        3740+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      3741     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0206    C2D8          3741+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3742     	
                      3743     T2_INT_RCP_UPDATE_START: 
                      3744     	; Process updated RC pulse
0208    207002        3745     JB FLAGS2 . 0 , ( $+5 ) 
020B    4177          3746     	AJMP	T2_INT_CURRENT_PWM_UPDATE	; No - update pwm limits and exit
                      3747     
020D    A85C          3748     MOV R0 , NEW_RCP 
020F    206102        3749     JB FLAGS0 . 1 , ( $+5 ) 
                      3750     
0212    C270          3751     CLR FLAGS2 . 0 
                      3752     
                      3753     	; Use a gain of 1.0625x for pwm input if not governor mode
0214    207436        3754     JB FLAGS2 . 4 , T2_INT_PWM_MIN_RUN 
                      3755     
                      3756     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ELSE
                      3759     
                      3760     IF MODE == 2	; Multi 
0217    7982          3761     MOV R1 , # PGM_GOV_MODE 
0219    B70431        3762     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      3763     ENDIF
                      3764     
                      3765     	; Limit the maximum value to avoid wrap when scaled to pwm range
021C    C3            3766     	CLR	C
021D    E8            3767     MOV A , R0 
021E    94F0          3768     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0220    4003          3769     	JC	T2_INT_RCP_UPDATE_MULT
                      3770     
0222    74F0          3771     	MOV	A, #240			; Set requested pwm to max
0224    F8            3772     MOV R0 , A 
                      3773     
                      3774     T2_INT_RCP_UPDATE_MULT: 	
                      3775     	; Multiply by 1.0625 (optional adjustment gyro gain)
0225    E8            3776     MOV A , R0 
0226    C4            3777     	SWAP	A			; After this "0.0625"
0227    540F          3778     	ANL	A, #0FH
0229    28            3779     ADD A , R0 
022A    F8            3780     MOV R0 , A 
                      3781     	; Adjust tail gain
022B    7984          3782     MOV R1 , # PGM_MOTOR_GAIN 
022D    B70302        3783     CJNE @ R1 , # 3 , ( $+5 ) 
0230    414D          3784     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      3785     
0232    C3            3786     	CLR	C
0233    13            3787     	RRC	A			; After this "0.5"
0234    C3            3788     	CLR	C
0235    13            3789     	RRC	A			; After this "0.25"
0236    8721          3790     MOV BIT_ACCESS_INT , @ R1 
0238    200802        3791     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      3792     
023B    C3            3793     	CLR	C
023C    13            3794     	RRC	A			; After this "0.125"
                      3795     
                      3796     T2_INT_RCP_GAIN_CORR: 
023D    200A06        3797     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      3798     
0240    C3            3799     	CLR	C
0241    C8            3800     XCH A , R0 
0242    98            3801     SUBB A , R0 
0243    F8            3802     MOV R0 , A 
0244    414D          3803     	AJMP	T2_INT_PWM_MIN_RUN
                      3804     
                      3805     T2_INT_RCP_GAIN_POS: 
0246    28            3806     ADD A , R0 
0247    F8            3807     MOV R0 , A 
0248    5003          3808     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      3809     
024A    74FF          3810     	MOV	A, #0FFH					; Yes - limit
024C    F8            3811     MOV R0 , A 
                      3812     ENDIF
                      3813     
                      3814     T2_INT_PWM_MIN_RUN:  
                      3815     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      3825     
                      3826     T2_INT_PWM_UPDATE:  
                      3827     	; Update requested_pwm
024D    8822          3828     MOV REQUESTED_PWM , R0 
                      3829     IF MODE >= 1	; Tail or multi
                      3830     	; Boost pwm during direct start
024F    E52D          3831     	MOV	A, FLAGS1
0251    5406          3832     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0253    6022          3833     	JZ	T2_INT_CURRENT_PWM_UPDATE
                      3834     
0255    206B1F        3835     JB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      3836     
0258    E536          3837     	MOV	A, STALL_CNT				; Add an extra power boost for each attempt
025A    C3            3838     	CLR	C
025B    33            3839     	RLC	A
025C    C3            3840     	CLR	C
025D    33            3841     	RLC	A
025E    F8            3842     MOV R0 , A 
025F    E564          3843     	MOV	A, PWM_SPOOLUP_BEG			; Set 25% of max startup power as minimum power
0261    C3            3844     	CLR	C
0262    13            3845     	RRC	A
0263    C3            3846     	CLR	C
0264    13            3847     	RRC	A
0265    F9            3848     MOV R1 , A 
0266    C3            3849     	CLR	C
0267    9522          3850     	SUBB	A, REQUESTED_PWM
0269    4002          3851     	JC	($+4)
                      3852     
026B    8922          3853     MOV REQUESTED_PWM , R1 
                      3854     
026D    E8            3855     MOV A , R0 
026E    2522          3856     	ADD	A, REQUESTED_PWM			
0270    F522          3857     	MOV	REQUESTED_PWM, A
0272    5003          3858     	JNC	($+5)
                      3859     
0274    7522FF        3860     	MOV	REQUESTED_PWM, #0FFH
                      3861     
                      3862     ENDIF
                      3863     T2_INT_CURRENT_PWM_UPDATE:  
                      3864     IF MODE == 0 OR MODE == 2	; Main or multi
0277    7882          3865     MOV R0 , # PGM_GOV_MODE 
0279    B60459        3866     CJNE @ R0 , # 4 , T2_INT_EXIT 
                      3867     ENDIF
                      3868     
027C    852224        3869     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      3870     IF MODE >= 1	; Tail or multi
                      3871     	; Set current_pwm_limited
027F    A824          3872     MOV R0 , CURRENT_PWM 
0281    C3            3873     	CLR	C
0282    E524          3874     	MOV	A, CURRENT_PWM				; Check against limit
0284    9561          3875     	SUBB	A, PWM_LIMIT
0286    4002          3876     	JC	($+4)					; If current pwm below limit - branch
                      3877     
0288    A861          3878     MOV R0 , PWM_LIMIT 
                      3879     
                      3880     IF MODE == 2	; Multi
                      3881     	; Limit pwm for low rpms
028A    C3            3882     	CLR	C
028B    E8            3883     MOV A , R0 
028C    9563          3884     	SUBB	A, PWM_LIMIT_BY_RPM
028E    4002          3885     	JC	($+4)					; If current pwm below limit - branch
                      3886     
0290    A863          3887     MOV R0 , PWM_LIMIT_BY_RPM 
                      3888     
                      3889     ENDIF
0292    8825          3890     MOV CURRENT_PWM_LIMITED , R0 
                      3891     	; Dither
0294    E566          3892     	MOV	A, PWM_DITHER_DECODED		; Load pwm dither
0296    7002          3893     	JNZ	($+4)					; If active - branch
0298    41C8          3894     	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                      3895     
029A    C3            3896     	CLR	C
029B    E8            3897     MOV A , R0 
029C    AA66          3898     MOV R2 , PWM_DITHER_DECODED 
029E    9A            3899     SUBB A , R2 
029F    5003          3900     	JNC	T2_INT_CURRENT_PWM_FULL_DITHER; If pwm more than dither value, then do full dither
                      3901     
02A1    E8            3902     MOV A , R0 
02A2    FA            3903     MOV R2 , A 
02A3    E4            3904     	CLR	A						; Set pwm minus dither
                      3905     
                      3906     T2_INT_CURRENT_PWM_FULL_DITHER: 
02A4    F9            3907     MOV R1 , A 
02A5    EA            3908     MOV A , R2 
02A6    C3            3909     	CLR	C
02A7    33            3910     	RLC	A						; Shift left once
02A8    FB            3911     MOV R3 , A 
02A9    E568          3912     	MOV	A, RANDOM					; Load random number
02AB    F4            3913     	CPL	A						; Invert to create proper DC bias in random code
02AC    5B            3914     ANL A , R3 
02AD    29            3915     ADD A , R1 
02AE    400D          3916     	JC	T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER	; If dither cause power above max - branch and increase excess 
                      3917     
02B0    2567          3918     	ADD	A, PWM_DITHER_EXCESS_POWER	; Add excess power from previous cycles
02B2    F8            3919     MOV R0 , A 
02B3    E567          3920     	MOV	A, PWM_DITHER_EXCESS_POWER	; Decrement excess power
02B5    6002          3921     	JZ	($+4)
02B7    1567          3922     	DEC	PWM_DITHER_EXCESS_POWER
02B9    400B          3923     	JC	T2_INT_CURRENT_PWM_DITHER_MAX_POWER; If dither cause power above max - branch
                      3924     
02BB    41C8          3925     	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                      3926     
                      3927     T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER: 
02BD    0A            3928     INC R2 
02BE    C3            3929     	CLR	C
02BF    E567          3930     	MOV	A, PWM_DITHER_EXCESS_POWER
02C1    9A            3931     SUBB A , R2 
02C2    5002          3932     	JNC	($+4)
02C4    0567          3933     	INC	PWM_DITHER_EXCESS_POWER
                      3934     
                      3935     T2_INT_CURRENT_PWM_DITHER_MAX_POWER: 
02C6    78FF          3936     MOV R0 , # 255 
                      3937     
                      3938     T2_INT_CURRENT_PWM_NO_DITHER: 
02C8    8826          3939     MOV CURRENT_PWM_LIM_DITH , R0 
                      3940     IF DAMPED_MODE_ENABLE == 1
                      3941     	; Skip damping fet switching for high throttle
02CA    C26F          3942     CLR FLAGS1 . 7 
02CC    C3            3943     	CLR	C
02CD    E526          3944     	MOV	A, CURRENT_PWM_LIM_DITH
02CF    94F8          3945     	SUBB	A, #248
02D1    4002          3946     	JC	T2_INT_EXIT
02D3    D26F          3947     SETB FLAGS1 . 7 
                      3948     ENDIF
                      3949     ENDIF
                      3950     T2_INT_EXIT: 	
                      3951     	; Check if high byte flag is set
02D5    20CF0A        3952     	JB	TF2H, T2H_INT		
02D8    D0E0          3953     	POP	ACC			; Restore preserved registers
02DA    D0D0          3954     	POP	PSW
02DC    43E610        3955     	ORL	EIE1, #10H	; Enable PCA0 interrupts
02DF    D2AD          3956     	SETB	ET2			; Enable timer2 interrupts
02E1    32            3957     	RETI
                      3958     
                      3959     T2H_INT: 
                      3960     	; High byte interrupt (happens every 32ms)
02E2    C2CF          3961     	CLR	TF2H					; Clear interrupt flag
02E4    053A          3962     	INC	TIMER2_X
                      3963     IF MCU_48MHZ == 1
02E6    E57A          3964     	MOV	A, CLOCK_SET_AT_48MHZ
02E8    6009          3965     	JZ 	T2H_INT_START
                      3966     
                      3967     	; Check skip variable
02EA    E578          3968     	MOV	A, SKIP_T2H_INT
02EC    6005          3969     	JZ	T2H_INT_START				; Execute this interrupt
                      3970     
02EE    757800        3971     	MOV	SKIP_T2H_INT, #0
02F1    611E          3972     	AJMP	T2H_INT_EXIT
                      3973     
                      3974     T2H_INT_START: 
02F3    757801        3975     	MOV	SKIP_T2H_INT, #1			; Skip next interrupt
                      3976     ENDIF
02F6    7801          3977     MOV R0 , # 1 
                      3978     	; Check RC pulse timeout counter (used here for PPM only)
02F8    E52A          3979     	MOV	A, RCP_TIMEOUT_CNTD			; RC pulse timeout count zero?
02FA    6005          3980     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      3981     
                      3982     	; Decrement timeout counter (if PPM)
02FC    307402        3983     JNB FLAGS2 . 4 , T2H_INT_RCP_STOP_CHECK 
                      3984     
02FF    152A          3985     	DEC	RCP_TIMEOUT_CNTD			; No flag set (PPM) - decrement
                      3986     
                      3987     T2H_INT_RCP_STOP_CHECK: 
                      3988     	; Check RC pulse against stop value
0301    C3            3989     	CLR	C
0302    E55C          3990     	MOV	A, NEW_RCP				; Load new pulse value
0304    9401          3991     SUBB A , # 1 
0306    4005          3992     	JC	T2H_INT_RCP_STOP
                      3993     
                      3994     	; RC pulse higher than stop value, reset stop counter
0308    755F00        3995     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
030B    611E          3996     	AJMP	T2H_INT_RCP_GOV_PWM
                      3997     
                      3998     T2H_INT_RCP_STOP: 	
                      3999     	; RC pulse less than stop value
030D    756000        4000     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
0310    756900        4001     	MOV	SPOOLUP_LIMIT_CNT, #0
0313    E55F          4002     	MOV	A, RCP_STOP_CNT			; Increment stop counter
0315    2401          4003     	ADD	A, #1
0317    F55F          4004     	MOV	RCP_STOP_CNT, A
0319    5003          4005     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      4006     
031B    755FFF        4007     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      4008     
                      4009     T2H_INT_RCP_GOV_PWM: 
                      4010     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	JNB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_GOV_BY_TX; If governor not active - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	JNB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_GOV_BY_TX; If governor not active - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #8						; Default fast increase for spoolup time of zero
                               	MOV	A, MAIN_SPOOLUP_TIME_3X
                               	JZ	T2H_INT_RCP_INC_LIMIT			; Jump for spoolup time of zero
                               
                               	MOV	TEMP1, #5						; Default fast increase
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_3X			; No spoolup until 3*N*32ms
                               
                               	JC	T2H_INT_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_10X			; Slow spoolup until "100"*N*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_15X			; Faster spoolup until "150"*N*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	JB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_INC_LIMIT	; If governor active - branch 
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, MAIN_SPOOLUP_TIME_3X	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_EXIT					; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      4140     T2H_INT_EXIT: 
031E    D0E0          4141     	POP	ACC			; Restore preserved registers
0320    D0D0          4142     	POP	PSW
0322    43E610        4143     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0325    D2AD          4144     	SETB	ET2			; Enable timer2 interrupts
0327    32            4145     	RETI
                      4146     
                      4147     
                      4148     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4149     ;
                      4150     ; Timer3 interrupt routine
                      4151     ;
                      4152     ; No assumptions
                      4153     ;
                      4154     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4155     T3_INT: 	; Used for commutation timing
0328    C2AF          4156     	CLR 	EA				; Disable all interrupts
032A    53E67F        4157     	ANL	EIE1, #7FH		; Disable timer3 interrupts
032D    7592FA        4158     	MOV	TMR3RLL, #0FAH		; Set a short delay before next interrupt
0330    7593FF        4159     	MOV	TMR3RLH, #0FFH
0333    C260          4160     CLR FLAGS0 . 0 
0335    759104        4161     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
0338    D2AF          4162     	SETB	EA				; Enable all interrupts
033A    32            4163     	RETI
                      4164     
                      4165     
                      4166     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4167     ;
                      4168     ; PCA interrupt routine
                      4169     ;
                      4170     ; No assumptions
                      4171     ;
                      4172     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4173     PCA_INT: 	; Used for RC pulse timing
033B    C2AF          4174     	CLR	EA
033D    53E6EF        4175     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
0340    C2AD          4176     	CLR	ET2			; Disable timer2 interrupts
0342    C0D0          4177     	PUSH	PSW			; Preserve registers through interrupt
0344    C0E0          4178     	PUSH	ACC
0346    C0F0          4179     	PUSH	B
0348    D2D3          4180     	SETB	PSW.3		; Select register bank 1 for interrupt routines
034A    D2AF          4181     	SETB	EA
                      4182     	; Get the PCA counter values
                      4183     	GET_RCP_CAPTURE_VALUES
034C    A8FB          4183+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
034E    A9FC          4183+1   MOV R1 , PCA0CPH0 
                      4183+1   IF 1 ==1 
0350    E57A          4183+1   MOV A , CLOCK_SET_AT_48MHZ 
0352    6007          4183+1   JZ GET_RCP_END 
0354    C3            4183+1   CLR C 
0355    E9            4183+1   MOV A , R1 
0356    13            4183+1   RRC A 
0357    F9            4183+1   MOV R1 , A 
0358    E8            4183+1   MOV A , R0 
0359    13            4183+1   RRC A 
035A    F8            4183+1   MOV R0 , A 
                      4183+1   GET_RCP_END:  
                      4184     	; Clear interrupt flag
                      4185     	RCP_CLEAR_INT_FLAG 				
035B    C2D8          4185+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      4186     	; Check which edge it is
035D    307102        4187     JNB FLAGS2 . 1 , ( $+5 ) 
0360    61AD          4188     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      4189     
                      4190     	RCP_INT_SECOND					; Yes - set second edge trig
0362    53DACF        4190+1   ANL PCA0CPM0 , # 0CFH 
0365    207E03        4190+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0368    43DA10        4190+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
036B    307E03        4190+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
036E    43DA20        4190+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0371    D271          4191     SETB FLAGS2 . 1 
                      4192     	; Read RC signal level
                      4193     	READ_RCP_INT			
0373    E580          4193+1   MOV A , P0 
0375    307E01        4193+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0378    F4            4193+1   CPL A  ; YES - INVERT
                      4194     	; Test RC signal level
0379    20E502        4195     JB ACC . 5 , ( $+5 ) 
037C    6184          4196     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      4197     
                      4198     	; RC pulse was high, store RC pulse start timestamp
037E    8827          4199     MOV RCP_PREV_EDGE_L , R0 
0380    8928          4200     MOV RCP_PREV_EDGE_H , R1 
0382    A1D2          4201     	AJMP	PCA_INT_EXIT				; Exit
                      4202     
                      4203     PCA_INT_FAIL_MINIMUM: 
                      4204     	; Prepare for next interrupt
                      4205     	RCP_INT_FIRST					; Set interrupt trig to first again
0384    53DACF        4205+1   ANL PCA0CPM0 , # 0CFH 
0387    207E03        4205+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
038A    43DA20        4205+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
038D    307E03        4205+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0390    43DA10        4205+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      4206     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0393    C2D8          4206+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0395    C271          4207     CLR FLAGS2 . 1 
0397    307402        4208     JNB FLAGS2 . 4 , ( $+5 ) 
                      4209     
039A    A1BE          4210     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      4211     
039C    7800          4212     MOV R0 , # 0 
                      4213     	READ_RCP_INT 					; Test RC signal level again
039E    E580          4213+1   MOV A , P0 
03A0    307E01        4213+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
03A3    F4            4213+1   CPL A  ; YES - INVERT
03A4    30E502        4214     JNB ACC . 5 , ( $+5 ) 
                      4215     
03A7    A1BE          4216     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      4217     
03A9    885C          4218     MOV NEW_RCP , R0 
03AB    A1A6          4219     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      4220     
                      4221     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      4222     	; Prepare for next interrupt
                      4223     	RCP_INT_FIRST 					; Set first edge trig
03AD    53DACF        4223+1   ANL PCA0CPM0 , # 0CFH 
03B0    207E03        4223+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03B3    43DA20        4223+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
03B6    307E03        4223+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03B9    43DA10        4223+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
03BC    C271          4224     CLR FLAGS2 . 1 
                      4225     	; Check if pwm frequency shall be measured
03BE    206102        4226     JB FLAGS0 . 1 , ( $+5 ) 
03C1    8186          4227     	AJMP	PCA_INT_FALL				; No - skip measurements
                      4228     
                      4229     	; Set second edge trig only during pwm frequency measurement
                      4230     	RCP_INT_SECOND 				; Set second edge trig
03C3    53DACF        4230+1   ANL PCA0CPM0 , # 0CFH 
03C6    207E03        4230+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03C9    43DA10        4230+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
03CC    307E03        4230+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03CF    43DA20        4230+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      4231     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
03D2    C2D8          4231+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
03D4    D271          4232     SETB FLAGS2 . 1 
                      4233     	; Store edge data to RAM
03D6    8857          4234     MOV RCP_EDGE_L , R0 
03D8    8958          4235     MOV RCP_EDGE_H , R1 
                      4236     	; Calculate pwm frequency
03DA    C3            4237     	CLR	C
03DB    E8            4238     MOV A , R0 
03DC    9555          4239     	SUBB	A, RCP_PREPREV_EDGE_L	
03DE    F8            4240     MOV R0 , A 
03DF    E9            4241     MOV A , R1 
03E0    9556          4242     	SUBB	A, RCP_PREPREV_EDGE_H
03E2    F9            4243     MOV R1 , A 
03E3    7B00          4244     MOV R3 , # 0 
03E5    7E08          4245     MOV R6 , # 8 
03E7    7A00          4246     MOV R2 , # 0 
                      4247     	; Check if pulse is too short
03E9    C3            4248     	CLR	C
03EA    E8            4249     MOV A , R0 
03EB    948C          4250     	SUBB	A, #LOW(140)				; If pulse below 70us, not accepted
03ED    E9            4251     MOV A , R1 
03EE    9400          4252     	SUBB	A, #HIGH(140)
03F0    5005          4253     	JNC	PCA_INT_CHECK_12KHZ
                      4254     
03F2    755B00        4255     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0	; Set not accepted 
03F5    8178          4256     	AJMP	PCA_INT_STORE_DATA
                      4257     
                      4258     PCA_INT_CHECK_12KHZ: 
03F7    8821          4259     MOV BIT_ACCESS_INT , R0 
03F9    78A2          4260     MOV R0 , # PGM_ENABLE_PWM_INPUT 
03FB    E6            4261     MOV A , @ R0 
03FC    A821          4262     MOV R0 , BIT_ACCESS_INT 
03FE    6055          4263     	JZ	PCA_INT_RESTORE_EDGE		; If it is not - branch
                      4264     
                      4265     	; Check if pwm frequency is 12kHz
0400    C3            4266     	CLR	C
0401    E8            4267     MOV A , R0 
0402    94C8          4268     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
0404    E9            4269     MOV A , R1 
0405    9400          4270     	SUBB	A, #HIGH(200)
0407    5008          4271     	JNC	PCA_INT_CHECK_8KHZ
                      4272     
0409    E4            4273     	CLR	A
040A    D2E4          4274     SETB ACC . 4 
040C    FB            4275     MOV R3 , A 
040D    7A0A          4276     MOV R2 , # 10 
040F    8153          4277     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      4278     
                      4279     PCA_INT_CHECK_8KHZ: 
                      4280     	; Check if pwm frequency is 8kHz
0411    C3            4281     	CLR	C
0412    E8            4282     MOV A , R0 
0413    9468          4283     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0415    E9            4284     MOV A , R1 
0416    9401          4285     	SUBB	A, #HIGH(360)
0418    5008          4286     	JNC	PCA_INT_CHECK_4KHZ
                      4287     
041A    E4            4288     	CLR	A
041B    D2E3          4289     SETB ACC . 3 
041D    FB            4290     MOV R3 , A 
041E    7A0F          4291     MOV R2 , # 15 
0420    8153          4292     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      4293     
                      4294     PCA_INT_CHECK_4KHZ: 
                      4295     	; Check if pwm frequency is 4kHz
0422    C3            4296     	CLR	C
0423    E8            4297     MOV A , R0 
0424    94D0          4298     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0426    E9            4299     MOV A , R1 
0427    9402          4300     	SUBB	A, #HIGH(720)
0429    5008          4301     	JNC	PCA_INT_CHECK_2KHZ
                      4302     
042B    E4            4303     	CLR	A
042C    D2E2          4304     SETB ACC . 2 
042E    FB            4305     MOV R3 , A 
042F    7A1E          4306     MOV R2 , # 30 
0431    8153          4307     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      4308     
                      4309     PCA_INT_CHECK_2KHZ: 
                      4310     	; Check if pwm frequency is 2kHz
0433    C3            4311     	CLR	C
0434    E8            4312     MOV A , R0 
0435    94A0          4313     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0437    E9            4314     MOV A , R1 
0438    9405          4315     	SUBB	A, #HIGH(1440)
043A    5008          4316     	JNC	PCA_INT_CHECK_1KHZ
                      4317     
043C    E4            4318     	CLR	A
043D    D2E1          4319     SETB ACC . 1 
043F    FB            4320     MOV R3 , A 
0440    7A3C          4321     MOV R2 , # 60 
0442    8153          4322     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      4323     
                      4324     PCA_INT_CHECK_1KHZ: 
                      4325     	; Check if pwm frequency is 1kHz
0444    C3            4326     	CLR	C
0445    E8            4327     MOV A , R0 
0446    9498          4328     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0448    E9            4329     MOV A , R1 
0449    9408          4330     	SUBB	A, #HIGH(2200)
044B    5008          4331     	JNC	PCA_INT_RESTORE_EDGE
                      4332     
044D    E4            4333     	CLR	A
044E    D2E0          4334     SETB ACC . 0 
0450    FB            4335     MOV R3 , A 
0451    7A78          4336     MOV R2 , # 120 
                      4337     
                      4338     PCA_INT_RESTORE_EDGE_SET_MSB: 
0453    7E00          4339     MOV R6 , # 0 
                      4340     PCA_INT_RESTORE_EDGE: 
                      4341     	; Calculate difference between this period and previous period
0455    C3            4342     	CLR	C
0456    E8            4343     MOV A , R0 
0457    9559          4344     	SUBB	A, RCP_PREV_PERIOD_L
0459    FC            4345     MOV R4 , A 
045A    E9            4346     MOV A , R1 
045B    955A          4347     	SUBB	A, RCP_PREV_PERIOD_H
045D    FD            4348     MOV R5 , A 
                      4349     	; Make positive
045E    30E70A        4350     	JNB	ACC.7, PCA_INT_CHECK_DIFF
0461    EC            4351     MOV A , R4 
0462    F4            4352     	CPL	A
0463    2401          4353     	ADD	A, #1
0465    FC            4354     MOV R4 , A 
0466    ED            4355     MOV A , R5 
0467    F4            4356     	CPL	A
0468    3400          4357     	ADDC	A, #0
046A    FD            4358     MOV R5 , A 
                      4359     
                      4360     PCA_INT_CHECK_DIFF: 
                      4361     	; Check difference
046B    755B00        4362     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
046E    C3            4363     	CLR	C
046F    EC            4364     MOV A , R4 
0470    9A            4365     SUBB A , R2 
0471    ED            4366     MOV A , R5 
0472    9E            4367     SUBB A , R6 
0473    5003          4368     	JNC	PCA_INT_STORE_DATA
                      4369     
0475    755B01        4370     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      4371     
                      4372     PCA_INT_STORE_DATA: 
                      4373     	; Store previous period
0478    8859          4374     MOV RCP_PREV_PERIOD_L , R0 
047A    895A          4375     MOV RCP_PREV_PERIOD_H , R1 
                      4376     	; Store pre previous edge
047C    855755        4377     	MOV	RCP_PREPREV_EDGE_L, RCP_EDGE_L
047F    855856        4378     	MOV	RCP_PREPREV_EDGE_H, RCP_EDGE_H
0482    7802          4379     MOV R0 , # 2 
0484    A1A6          4380     	AJMP	PCA_INT_LIMITED
                      4381     
                      4382     PCA_INT_FALL: 
                      4383     	; RC pulse edge was second, calculate new pulse length
0486    C3            4384     	CLR	C
0487    E8            4385     MOV A , R0 
0488    9527          4386     	SUBB	A, RCP_PREV_EDGE_L	
048A    F8            4387     MOV R0 , A 
048B    E9            4388     MOV A , R1 
048C    9528          4389     	SUBB	A, RCP_PREV_EDGE_H
048E    F9            4390     MOV R1 , A 
                      4391     	
                      4392     	; Rescale our Multishot signal to a Oneshot125 Signal range		
                      4393     	
048F    C3            4394     	CLR	C						; clear carry flag		
0490    E9            4395     MOV A , R1 
0491    13            4396     	RRC	A						; rotate right through the carry flag		
0492    F9            4397     MOV R1 , A 
0493    E8            4398     MOV A , R0 
0494    13            4399     	RRC	A						; rotate right through the carry flag		
0495    F8            4400     MOV R0 , A 
                      4401     									;60-300; 61-306		
0496    C3            4402     	CLR	C						; clear carry flag		
0497    E8            4403     MOV A , R0 
0498    24B4          4404       ADD A,	#180    ;Add the second low-byte to the accumulator		
049A    FC            4405     MOV R4 , A 
049B    E9            4406     MOV A , R1 
049C    3400          4407       ADDC A,	#0     	;Add the second high-byte to the accumulator, plus carry.		
049E    FD            4408     MOV R5 , A 
                      4409     									;240 - 480		
049F    81C0          4410     	AJMP	PCA_INT_FALL_CHECK_RANGE 	; consider this a valid MS signal - move to I_Temp5/6 		
                      4411     					
                      4412     	; End Multishot to Oneshot Signal Scaling		
                      4413     
                      4414     PCA_INT_FALL_NOT_ONESHOT: 
04A1    E9            4415     MOV A , R1 
04A2    C3            4416     	CLR	C
04A3    13            4417     	RRC	A
04A4    F9            4418     MOV R1 , A 
04A5    E8            4419     MOV A , R0 
04A6    13            4420     	RRC	A
04A7    F8            4421     MOV R0 , A 
                      4422     
04A8    307902        4423     JNB FLAGS3 . 1 , ( $+5 ) 
04AB    A183          4424     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      4425     
04AD    E9            4426     MOV A , R1 
04AE    C3            4427     	CLR	C
04AF    13            4428     	RRC	A
04B0    F9            4429     MOV R1 , A 
04B1    E8            4430     MOV A , R0 
04B2    13            4431     	RRC	A
04B3    F8            4432     MOV R0 , A 
                      4433     
04B4    307802        4434     JNB FLAGS3 . 0 , ( $+5 ) 
04B7    A183          4435     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      4436     
04B9    E9            4437     MOV A , R1 
04BA    C3            4438     	CLR	C
04BB    13            4439     	RRC	A
04BC    FD            4440     MOV R5 , A 
04BD    E8            4441     MOV A , R0 
04BE    13            4442     	RRC	A
04BF    FC            4443     MOV R4 , A 
                      4444     PCA_INT_FALL_CHECK_RANGE: 
                      4445     	; Skip range limitation if pwm frequency measurement
04C0    20612C        4446     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      4447     
                      4448     	; Check if 2160us or above (in order to ignore false pulses)
04C3    C3            4449     	CLR	C
04C4    EC            4450     MOV A , R4 
04C5    9482          4451     	SUBB	A, #130						; Multishot Re-scale
04C7    ED            4452     MOV A , R5 
04C8    9402          4453     	SUBB A, #2
04CA    4002          4454     	JC	($+4)						; No - proceed
                      4455     
04CC    81D7          4456     	AJMP	PCA_INT_PPM_OUTSIDE_RANGE		; Yes - ignore pulse
                      4457     
                      4458     PCA_INT_PPM_BELOW_FULL_RANGE: 
                      4459     	; Check if below 800us (in order to ignore false pulses)
04CE    ED            4460     MOV A , R5 
04CF    701E          4461     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      4462     
04D1    C3            4463     	CLR	C
04D2    EC            4464     MOV A , R4 
04D3    94C8          4465     	SUBB	A, #200
04D5    5018          4466     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      4467     
                      4468     PCA_INT_PPM_OUTSIDE_RANGE: 
04D7    0529          4469     	INC	RCP_OUTSIDE_RANGE_CNT
04D9    E529          4470     	MOV	A, RCP_OUTSIDE_RANGE_CNT
04DB    7002          4471     	JNZ	($+4)
                      4472     
04DD    1529          4473     	DEC	RCP_OUTSIDE_RANGE_CNT
                      4474     
04DF    C3            4475     	CLR	C
04E0    E529          4476     	MOV	A, RCP_OUTSIDE_RANGE_CNT
04E2    940A          4477     	SUBB	A, #10						; Allow a given number of outside pulses
04E4    5002          4478     	JNC	($+4)			
04E6    A1BE          4479     	AJMP	PCA_INT_SET_TIMEOUT				; If below limit - ignore pulse
                      4480     
04E8    755C00        4481     	MOV	NEW_RCP, #0					; Set pulse length to zero
04EB    D270          4482     SETB FLAGS2 . 0 
04ED    A1BE          4483     	AJMP	PCA_INT_SET_TIMEOUT			
                      4484     
                      4485     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      4486     	; Decrement outside range counter
04EF    E529          4487     	MOV	A, RCP_OUTSIDE_RANGE_CNT
04F1    6002          4488     	JZ	($+4)
                      4489     
04F3    1529          4490     	DEC	RCP_OUTSIDE_RANGE_CNT
                      4491     
                      4492     	; Calculate "1000us" plus throttle minimum
                      4493     IF MODE >= 1	; Tail or multi
04F5    7888          4494     MOV R0 , # PGM_DIRECTION 
04F7    E6            4495     MOV A , @ R0 
04F8    F9            4496     MOV R1 , A 
                      4497     ENDIF
04F9    7400          4498     	MOV	A, #0						; Set 1000us as default minimum
04FB    207F08        4499     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      4500     
04FE    7896          4501     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      4502     IF MODE >= 1	; Tail or multi
0500    B90302        4503     CJNE R1 , # 3 , ( $+5 ) 
                      4504     
0503    789E          4505     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      4506     ENDIF
0505    E6            4507     MOV A , @ R0 
                      4508     
                      4509     PCA_INT_PPM_CALCULATE: 
0506    24FA          4510     	ADD	A, #250						; Add 1000us to minimum
0508    FE            4511     MOV R6 , A 
0509    E4            4512     	CLR	A
050A    3400          4513     	ADDC	A, #0
050C    FF            4514     MOV R7 , A 
                      4515     
050D    C3            4516     	CLR	C
050E    EC            4517     MOV A , R4 
050F    9E            4518     SUBB A , R6 
0510    FC            4519     MOV R4 , A 
0511    ED            4520     MOV A , R5 
0512    9F            4521     SUBB A , R7 
0513    FD            4522     MOV R5 , A 
                      4523     IF MODE >= 1	; Tail or multi
0514    9208          4524     	MOV	BIT_ACCESS_INT.0, C
0516    B90310        4525     CJNE R1 , # 3 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4526     
0519    A208          4527     	MOV	C, BIT_ACCESS_INT.0
051B    5007          4528     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      4529     
                      4530     PCA_INT_PPM_BIDIR_REV: 
051D    207609        4531     JB FLAGS2 . 6 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4532     
0520    D276          4533     SETB FLAGS2 . 6 
0522    A129          4534     	AJMP	PCA_INT_PPM_BIDIR_DIR_SET
                      4535     
                      4536     PCA_INT_PPM_BIDIR_FWD: 
0524    307602        4537     JNB FLAGS2 . 6 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4538     
0527    C276          4539     CLR FLAGS2 . 6 
                      4540     
                      4541     PCA_INT_PPM_BIDIR_DIR_SET: 
0529    A208          4542     	MOV	C, BIT_ACCESS_INT.0
                      4543     ENDIF
052B    5016          4544     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      4545     
                      4546     IF MODE >= 1	; Tail or multi
052D    B9030D        4547     CJNE R1 , # 3 , PCA_INT_PPM_UNIDIR_NEG 
                      4548     
0530    EC            4549     MOV A , R4 
0531    F4            4550     	CPL	A
0532    2401          4551     	ADD	A, #1
0534    FC            4552     MOV R4 , A 
0535    ED            4553     MOV A , R5 
0536    F4            4554     	CPL	A
0537    3400          4555     	ADDC	A, #0
0539    FD            4556     MOV R5 , A 
053A    020543        4557     	JMP	PCA_INT_PPM_NEG_CHECKED
                      4558     
                      4559     PCA_INT_PPM_UNIDIR_NEG: 
                      4560     ENDIF
053D    7800          4561     MOV R0 , # 0 
053F    7900          4562     MOV R1 , # 0 
0541    A18A          4563     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4564     
                      4565     PCA_INT_PPM_NEG_CHECKED: 
                      4566     IF MODE >= 1	; Tail or multi
0543    B90315        4567     CJNE R1 , # 3 , PCA_INT_PPM_BIDIR_DONE 
                      4568     
0546    EC            4569     MOV A , R4 
0547    33            4570     	RLC	A
0548    FC            4571     MOV R4 , A 
0549    ED            4572     MOV A , R5 
054A    33            4573     	RLC	A
054B    FD            4574     MOV R5 , A 
054C    C3            4575     	CLR	C							; Subtract deadband
054D    EC            4576     MOV A , R4 
054E    940A          4577     	SUBB	A, #10		
0550    FC            4578     MOV R4 , A 
0551    ED            4579     MOV A , R5 
0552    9400          4580     	SUBB	A, #0
0554    FD            4581     MOV R5 , A 
0555    5004          4582     	JNC	PCA_INT_PPM_BIDIR_DONE
                      4583     
0557    7C00          4584     MOV R4 , # 0 
0559    7D00          4585     MOV R5 , # 0 
                      4586     
                      4587     PCA_INT_PPM_BIDIR_DONE: 
                      4588     ENDIF
055B    C3            4589     	CLR	C							; Check that RC pulse is within legal range (max 255)
055C    EC            4590     MOV A , R4 
055D    94FF          4591     SUBB A , # 255 
055F    ED            4592     MOV A , R5 
0560    9400          4593     	SUBB	A, #0
0562    4006          4594     	JC	PCA_INT_PPM_MAX_CHECKED
                      4595     
0564    78FF          4596     MOV R0 , # 255 
0566    7900          4597     MOV R1 , # 0 
0568    A18A          4598     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4599     
                      4600     PCA_INT_PPM_MAX_CHECKED: 
056A    EC            4601     MOV A , R4 
056B    8572F0        4602     	MOV	B, PPM_THROTTLE_GAIN
056E    A4            4603     	MUL	AB
056F    C5F0          4604     	XCH	A, B
0571    A2F7          4605     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0573    33            4606     	RLC	A
0574    F8            4607     MOV R0 , A 
0575    7900          4608     MOV R1 , # 0 
0577    4003          4609     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      4610     	
0579    0205A6        4611     	JMP	PCA_INT_LIMITED			
                      4612     
                      4613     PCA_INT_PPM_LIMIT_AFTER_MULT: 
057C    78FF          4614     MOV R0 , # 255 
057E    7900          4615     MOV R1 , # 0 
0580    0205A6        4616     	JMP	PCA_INT_LIMITED			
                      4617     
                      4618     PCA_INT_PWM_DIVIDE: 
0583    E9            4619     MOV A , R1 
0584    C3            4620     	CLR	C
0585    13            4621     	RRC	A
0586    F9            4622     MOV R1 , A 
0587    E8            4623     MOV A , R0 
0588    13            4624     	RRC	A
0589    F8            4625     MOV R0 , A 
                      4626     
                      4627     PCA_INT_PWM_DIVIDE_DONE: 
058A    307C0E        4628     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
058D    E9            4629     MOV A , R1 
058E    6002          4630     	JZ	($+4)
                      4631     
0590    78FF          4632     MOV R0 , # 255 
                      4633     
0592    C3            4634     	CLR	C
0593    E8            4635     MOV A , R0 
0594    13            4636     	RRC	A
0595    38            4637     ADDC A , R0 
0596    F8            4638     MOV R0 , A 
0597    E4            4639     	CLR	A
0598    3400          4640     	ADDC	A, #0
059A    F9            4641     MOV R1 , A 
                      4642     
                      4643     PCA_INT_CHECK_LEGAL_RANGE: 
                      4644     	; Check that RC pulse is within legal range
059B    C3            4645     	CLR	C
059C    E8            4646     MOV A , R0 
059D    94FF          4647     SUBB A , # 255 
059F    E9            4648     MOV A , R1 
05A0    9400          4649     	SUBB	A, #0
05A2    4002          4650     	JC	PCA_INT_LIMITED
                      4651     
05A4    78FF          4652     MOV R0 , # 255 
                      4653     
                      4654     PCA_INT_LIMITED: 
                      4655     	; RC pulse value accepted
05A6    885C          4656     MOV NEW_RCP , R0 
05A8    D270          4657     SETB FLAGS2 . 0 
05AA    206102        4658     JB FLAGS0 . 1 , ( $+5 ) 
                      4659     
05AD    A1BE          4660     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      4661     
05AF    741F          4662     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
05B1    F4            4663     	CPL	A
05B2    552F          4664     	ANL	A, FLAGS3					; Clear all pwm frequency flags
05B4    4B            4665     ORL A , R3 
05B5    F52F          4666     	MOV	FLAGS3, A
05B7    C274          4667     CLR FLAGS2 . 4 
05B9    EB            4668     MOV A , R3 
05BA    7002          4669     	JNZ	PCA_INT_SET_TIMEOUT
                      4670     
05BC    D274          4671     SETB FLAGS2 . 4 
                      4672     
                      4673     PCA_INT_SET_TIMEOUT: 
05BE    752A18        4674     MOV RCP_TIMEOUT_CNTD , # 24 
05C1    307403        4675     JNB FLAGS2 . 4 , PCA_INT_PPM_TIMEOUT_SET 
                      4676     
05C4    752A0A        4677     MOV RCP_TIMEOUT_CNTD , # 10 
                      4678     
                      4679     PCA_INT_PPM_TIMEOUT_SET: 
05C7    306102        4680     JNB FLAGS0 . 1 , ( $+5 ) 
                      4681     
05CA    A1D2          4682     	AJMP PCA_INT_EXIT				; Yes - exit
                      4683     
05CC    207403        4684     JB FLAGS2 . 4 , PCA_INT_EXIT 
                      4685     
                      4686     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
05CF    53DAFE        4686+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      4687     
                      4688     PCA_INT_EXIT: 	; Exit interrupt routine	
05D2    207403        4689     JB FLAGS2 . 4 , ( $+6 ) 
                      4690     
05D5    752B06        4691     MOV RCP_SKIP_CNTD , # 6 
                      4692     
05D8    D0F0          4693     	POP	B			; Restore preserved registers
05DA    D0E0          4694     	POP	ACC			
05DC    D0D0          4695     	POP	PSW
05DE    D2AD          4696     	SETB	ET2			; Enable timer2 interrupts
05E0    43E610        4697     	ORL	EIE1, #10H	; Enable PCA0 interrupts
05E3    32            4698     	RETI
                      4699     
                      4700     
                      4701     
                      4702     
                      4703     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4704     ;
                      4705     ; Wait xms ~(x*4*250)  (Different entry points)	
                      4706     ;
                      4707     ; No assumptions
                      4708     ;
                      4709     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4710     WAIT1MS: 	
05E4    7901          4711     MOV R1 , # 1 
05E6    020602        4712     	JMP	WAITXMS_O
                      4713     
                      4714     WAIT3MS: 	
05E9    7903          4715     MOV R1 , # 3 
05EB    020602        4716     	JMP	WAITXMS_O
                      4717     
                      4718     WAIT10MS: 	
05EE    790A          4719     MOV R1 , # 10 
05F0    020602        4720     	JMP	WAITXMS_O
                      4721     
                      4722     WAIT30MS: 	
05F3    791E          4723     MOV R1 , # 30 
05F5    020602        4724     	JMP	WAITXMS_O
                      4725     
                      4726     WAIT100MS: 	
05F8    7964          4727     MOV R1 , # 100 
05FA    020602        4728     	JMP	WAITXMS_O
                      4729     
                      4730     WAIT200MS: 	
05FD    79C8          4731     MOV R1 , # 200 
05FF    020602        4732     	JMP	WAITXMS_O
                      4733     
                      4734     WAITXMS_O: 	; Outer loop
0602    7817          4735     MOV R0 , # 23 
                      4736     WAITXMS_M: 	; Middle loop
0604    E4            4737     	CLR	A
0605    D5E0FD        4738      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
0608    D8FA          4739     DJNZ R0 , WAITXMS_M 
060A    D9F6          4740     DJNZ R1 , WAITXMS_O 
060C    22            4741     	RET
                      4742     
                      4743     
                      4744     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4745     ;
                      4746     ; Beeper routines (4 different entry points) 
                      4747     ;
                      4748     ; No assumptions
                      4749     ;
                      4750     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4751     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
060D    7A14          4752     MOV R2 , # 20 
060F    7B78          4753     MOV R3 , # 120 
0611    020629        4754     	JMP	BEEP
                      4755     
                      4756     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
0614    7A10          4757     MOV R2 , # 16 
0616    7B8C          4758     MOV R3 , # 140 
0618    020629        4759     	JMP	BEEP
                      4760     
                      4761     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
061B    7A0D          4762     MOV R2 , # 13 
061D    7BB4          4763     MOV R3 , # 180 
061F    020629        4764     	JMP	BEEP
                      4765     
                      4766     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
0622    7A0B          4767     MOV R2 , # 11 
0624    7BC8          4768     MOV R3 , # 200 
0626    020629        4769     	JMP	BEEP
                      4770     
                      4771     BEEP: 	; Beep loop start
0629    E573          4772     	MOV	A, BEEP_STRENGTH
062B    D5E001        4773     	DJNZ	ACC, BEEP_START 
062E    22            4774     	RET
                      4775     
                      4776     BEEP_START:     
062F    7902          4777     MOV R1 , # 2 
                      4778     BEEP_ONOFF: 
0631    E4            4779     	CLR	A
                      4780     	BPFET_OFF			; BpFET off
0632    C296          4780+1   CLR P1 . 6 
0634    D5E0FD        4781     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      4782     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
0637    D297          4782+1   SETB P1 . 7 
0639    D5E0FD        4783     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      4784     	BNFET_OFF			; BnFET off again
063C    C297          4784+1   CLR P1 . 7 
063E    D5E0FD        4785     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      4786     	BPFET_ON			; BpFET on
0641    D296          4786+1   SETB P1 . 6 
0643    D5E0FD        4787     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      4788     	; Turn on nfet
0646    E9            4789     MOV A , R1 
0647    20E002        4790     	JB	ACC.0, BEEP_ANFET_ON
                      4791     	ANFET_ON			; AnFET on
064A    D295          4791+1   SETB P1 . 5 
                      4792     BEEP_ANFET_ON: 
064C    30E002        4793     	JNB	ACC.0, BEEP_CNFET_ON
                      4794     	CNFET_ON			; CnFET on
064F    D293          4794+1   SETB P1 . 3 
                      4795     BEEP_CNFET_ON: 
0651    E573          4796     	MOV	A, BEEP_STRENGTH
0653    D5E0FD        4797     	DJNZ	ACC, $		
                      4798     	; Turn off nfet
0656    E9            4799     MOV A , R1 
0657    20E002        4800     	JB	ACC.0, BEEP_ANFET_OFF
                      4801     	ANFET_OFF			; AnFET off
065A    C295          4801+1   CLR P1 . 5 
                      4802     BEEP_ANFET_OFF: 
065C    30E002        4803     	JNB	ACC.0, BEEP_CNFET_OFF
                      4804     	CNFET_OFF			; CnFET off
065F    C293          4804+1   CLR P1 . 3 
                      4805     BEEP_CNFET_OFF: 
0661    7496          4806     	MOV	A, #150		; 25s off
0663    D5E0FD        4807     	DJNZ	ACC, $		
0666    D9C9          4808     DJNZ R1 , BEEP_ONOFF 
                      4809     	; Copy variable
0668    EA            4810     MOV A , R2 
0669    F8            4811     MOV R0 , A 
                      4812     BEEP_OFF: 		; Fets off loop
066A    D5E0FD        4813     	DJNZ	ACC, $
066D    D8FB          4814     DJNZ R0 , BEEP_OFF 
066F    DBB8          4815     DJNZ R3 , BEEP 
                      4816     	BPFET_OFF			; BpFET off
0671    C296          4816+1   CLR P1 . 6 
0673    22            4817     	RET
                      4818     
                      4819     
                      4820     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4821     ;
                      4822     ; Division 16bit unsigned by 16bit unsigned
                      4823     ;
                      4824     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      4825     ; Result will be in Temp2/Temp1
                      4826     ;
                      4827     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4828     DIV_U16_BY_U16: 	
0674    C3            4829     	CLR	C       
0675    7C00          4830     MOV R4 , # 0 
0677    7D00          4831     MOV R5 , # 0 
0679    75F000        4832     	MOV	B, #0
                      4833     DIV_U16_BY_U16_DIV1: 
067C    05F0          4834     	INC	B      			; Increment counter for each left shift
067E    EA            4835     MOV A , R2 
067F    33            4836     	RLC	A      		
0680    FA            4837     MOV R2 , A 
0681    EB            4838     MOV A , R3 
0682    33            4839     	RLC	A      	  	
0683    FB            4840     MOV R3 , A 
0684    50F6          4841     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      4842     DIV_U16_BY_U16_DIV2:         
0686    EB            4843     MOV A , R3 
0687    13            4844     	RRC	A      
0688    FB            4845     MOV R3 , A 
0689    EA            4846     MOV A , R2 
068A    13            4847     	RRC	A      
068B    FA            4848     MOV R2 , A 
068C    C3            4849     	CLR	C      
068D    E9            4850     MOV A , R1 
068E    FF            4851     MOV R7 , A 
068F    E8            4852     MOV A , R0 
0690    FE            4853     MOV R6 , A 
0691    E8            4854     MOV A , R0 
0692    9A            4855     SUBB A , R2 
0693    F8            4856     MOV R0 , A 
0694    E9            4857     MOV A , R1 
0695    9B            4858     SUBB A , R3 
0696    F9            4859     MOV R1 , A 
0697    5004          4860     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
0699    EF            4861     MOV A , R7 
069A    F9            4862     MOV R1 , A 
069B    EE            4863     MOV A , R6 
069C    F8            4864     MOV R0 , A 
                      4865     DIV_U16_BY_U16_DIV3: 
069D    B3            4866     	CPL	C      			; Invert carry, so it can be directly copied into result
069E    EC            4867     MOV A , R4 
069F    33            4868     	RLC	A      			; Shift carry flag into temporary result
06A0    FC            4869     MOV R4 , A 
06A1    ED            4870     MOV A , R5 
06A2    33            4871     	RLC	A
06A3    FD            4872     MOV R5 , A 
06A4    D5F0DF        4873     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
06A7    ED            4874     MOV A , R5 
06A8    F9            4875     MOV R1 , A 
06A9    EC            4876     MOV A , R4 
06AA    F8            4877     MOV R0 , A 
06AB    22            4878     	RET
                      4879     
                      4880     
                      4881     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4882     ;
                      4883     ; Multiplication 16bit signed by 8bit unsigned
                      4884     ;
                      4885     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      4886     ; Result will be in Temp2/Temp1. Result will divided by 16
                      4887     ;
                      4888     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4889     MULT_S16_BY_U8_DIV_16: 
06AC    E8            4890     MOV A , R0 
06AD    89F0          4891     MOV B , R1 
06AF    8A20          4892     MOV BIT_ACCESS , R2 
06B1    D2D4          4893     	SETB	PSW.4		; Select register bank 2 for math routines
06B3    F8            4894     MOV R0 , A 
06B4    A9F0          4895     MOV R1 , B 
06B6    7B00          4896     MOV R3 , # 0 
06B8    30F70B        4897     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      4898     
06BB    7BFF          4899     MOV R3 , # 0FFH 
06BD    F4            4900     	CPL	A
06BE    2401          4901     	ADD	A, #1
06C0    F8            4902     MOV R0 , A 
06C1    E9            4903     MOV A , R1 
06C2    F4            4904     	CPL	A
06C3    3400          4905     	ADDC	A, #0
06C5    F9            4906     MOV R1 , A 
                      4907     MULT_S16_BY_U8_POSITIVE: 
06C6    E8            4908     MOV A , R0 
06C7    8520F0        4909     	MOV	B, BIT_ACCESS
06CA    A4            4910     	MUL	AB
06CB    ADF0          4911     MOV R5 , B 
06CD    F8            4912     MOV R0 , A 
06CE    E9            4913     MOV A , R1 
06CF    8520F0        4914     	MOV	B, BIT_ACCESS
06D2    A4            4915     	MUL	AB
06D3    AFF0          4916     MOV R7 , B 
06D5    FE            4917     MOV R6 , A 
06D6    ED            4918     MOV A , R5 
06D7    2E            4919     ADD A , R6 
06D8    F9            4920     MOV R1 , A 
06D9    7400          4921     	MOV	A, #0
06DB    3F            4922     ADDC A , R7 
06DC    FA            4923     MOV R2 , A 
06DD    7C04          4924     MOV R4 , # 4 
                      4925     MULT_S16_BY_U8_DIV_LOOP: 
06DF    C3            4926     	CLR	C			; Rotate right 
06E0    EA            4927     MOV A , R2 
06E1    13            4928     	RRC	A
06E2    FA            4929     MOV R2 , A 
06E3    E9            4930     MOV A , R1 
06E4    13            4931     	RRC	A
06E5    F9            4932     MOV R1 , A 
06E6    E8            4933     MOV A , R0 
06E7    13            4934     	RRC	A
06E8    F8            4935     MOV R0 , A 
06E9    DCF4          4936     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      4937     
06EB    8BF0          4938     MOV B , R3 
06ED    30F70A        4939     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      4940     
06F0    E8            4941     MOV A , R0 
06F1    F4            4942     	CPL	A
06F2    2401          4943     	ADD	A, #1
06F4    F8            4944     MOV R0 , A 
06F5    E9            4945     MOV A , R1 
06F6    F4            4946     	CPL	A
06F7    3400          4947     	ADDC	A, #0
06F9    F9            4948     MOV R1 , A 
                      4949     
                      4950     MULT_S16_BY_U8_EXIT: 
06FA    E8            4951     MOV A , R0 
06FB    89F0          4952     MOV B , R1 
06FD    C2D4          4953     	CLR	PSW.4		; Select normal register bank
06FF    F8            4954     MOV R0 , A 
0700    A9F0          4955     MOV R1 , B 
0702    22            4956     	RET
                      4957     
                      4958     
                      4959     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4960     ;
                      4961     ; Calculate governor routines
                      4962     ;
                      4963     ; No assumptions
                      4964     ;
                      4965     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      4966     ; The governor task is split into several routines in order to distribute processing time
                      4967     ;
                      4968     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4969     ; First governor routine - calculate governor target
                      4970     IF MODE == 0	; Main
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	JB	FLAGS1.GOV_ACTIVE, GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	JNB	FLAGS1.GOV_ACTIVE, GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                                
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	CLR	FLAGS1.GOV_ACTIVE
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	SETB	FLAGS1.GOV_ACTIVE
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      5108     IF MODE == 1	; Tail
                               CALC_GOVERNOR_TARGET:
                               	RET						
                               ENDIF
                      5112     IF MODE == 2	; Multi
                      5113     CALC_GOVERNOR_TARGET: 
0703    7882          5114     MOV R0 , # PGM_GOV_MODE 
0705    B60403        5115     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
0708    02075E        5116     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      5117     
                      5118     GOVERNOR_TARGET_CALC: 
                      5119     	; Stop governor for stop RC pulse	
070B    C3            5120     	CLR	C
070C    E55C          5121     	MOV	A, NEW_RCP				; Check RC pulse against stop value
070E    9401          5122     SUBB A , # 1 
0710    4003          5123     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      5124     
0712    020728        5125     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      5126     
                      5127     GOVERNOR_DEACTIVATE: 
0715    852224        5128     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
0718    E4            5129     	CLR	A
0719    F544          5130     	MOV	GOV_TARGET_L, A			; Set target to zero
071B    F545          5131     	MOV	GOV_TARGET_H, A
071D    F546          5132     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
071F    F547          5133     	MOV	GOV_INTEGRAL_H, A
0721    F548          5134     	MOV	GOV_INTEGRAL_X, A
0723    C26E          5135     CLR FLAGS1 . 6 
0725    02075E        5136     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      5137     
                      5138     GOVERNOR_ACTIVATE: 
0728    7882          5139     MOV R0 , # PGM_GOV_MODE 
072A    E6            5140     MOV A , @ R0 
072B    FC            5141     MOV R4 , A 
072C    D26E          5142     SETB FLAGS1 . 6 
072E    E522          5143     	MOV	A, REQUESTED_PWM			; Load requested pwm
0730    F523          5144     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      5145     	; Calculate comm period target 2*(51000/Requested_Pwm)
0732    7838          5146     MOV R0 , # 38H 
0734    79C7          5147     MOV R1 , # 0C7H 
0736    AA40          5148     MOV R2 , COMM_PERIOD4X_L 
0738    AB41          5149     MOV R3 , COMM_PERIOD4X_H 
                      5150     	; Set speed range 
073A    C3            5151     	CLR	C
073B    EB            5152     MOV A , R3 
073C    13            5153     	RRC	A
073D    FB            5154     MOV R3 , A 
073E    EA            5155     MOV A , R2 
073F    13            5156     	RRC	A
0740    FA            5157     MOV R2 , A 
                      5158     	; Check range
0741    EC            5159     MOV A , R4 
0742    14            5160     	DEC	A
0743    6013          5161     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      5162     GOVERNOR_ACTIVATE_100K: 
0745    C3            5163     	CLR	C
0746    EB            5164     MOV A , R3 
0747    13            5165     	RRC	A
0748    FB            5166     MOV R3 , A 
0749    EA            5167     MOV A , R2 
074A    13            5168     	RRC	A
074B    FA            5169     MOV R2 , A 
074C    EC            5170     MOV A , R4 
074D    14            5171     	DEC	A
074E    14            5172     	DEC	A
074F    6007          5173     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      5174     GOVERNOR_ACTIVATE_50K: 
0751    C3            5175     	CLR	C
0752    EB            5176     MOV A , R3 
0753    13            5177     	RRC	A
0754    FB            5178     MOV R3 , A 
0755    EA            5179     MOV A , R2 
0756    13            5180     	RRC	A
0757    FA            5181     MOV R2 , A 
                      5182     GOVERNOR_ACTIVATE_RANGE_SET: 
0758    D174          5183     	CALL	DIV_U16_BY_U16
                      5184     	; Store governor target
075A    8844          5185     MOV GOV_TARGET_L , R0 
075C    8945          5186     MOV GOV_TARGET_H , R1 
                      5187     CALC_GOVERNOR_TARGET_EXIT: 
075E    22            5188     	RET						
                      5189     ENDIF
                      5190     
                      5191     
                      5192     ; Second governor routine - calculate governor proportional error
                      5193     CALC_GOVERNOR_PROP_ERROR: 
                      5194     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      5212     IF MODE == 2	; Multi
                      5213     	; Calculate error
075F    C3            5214     	CLR	C
0760    E544          5215     	MOV	A, GOV_TARGET_L
0762    9523          5216     	SUBB	A, GOVERNOR_REQ_PWM
0764    F8            5217     MOV R0 , A 
0765    E545          5218     	MOV	A, GOV_TARGET_H
0767    9400          5219     	SUBB	A, #0
0769    F9            5220     MOV R1 , A 
                      5221     ENDIF
                      5222     	; Check error and limit
076A    500C          5223     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      5224     
076C    C3            5225     	CLR	C
076D    E8            5226     MOV A , R0 
076E    9480          5227     	SUBB	A, #80H					; Is error too negative?
0770    E9            5228     MOV A , R1 
0771    94FF          5229     	SUBB	A, #0FFH
0773    4016          5230     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
0775    02078F        5231     	JMP	GOVERNOR_STORE_PROP_ERROR
                      5232     
                      5233     GOVERNOR_CHECK_PROP_LIMIT_POS: 
0778    C3            5234     	CLR	C
0779    E8            5235     MOV A , R0 
077A    947F          5236     	SUBB	A, #7FH					; Is error too positive?
077C    E9            5237     MOV A , R1 
077D    9400          5238     	SUBB	A, #00H
077F    5003          5239     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
0781    02078F        5240     	JMP	GOVERNOR_STORE_PROP_ERROR
                      5241     
                      5242     GOVERNOR_LIMIT_PROP_ERROR_POS: 
0784    787F          5243     MOV R0 , # 7FH 
0786    7900          5244     MOV R1 , # 00H 
0788    02078F        5245     	JMP	GOVERNOR_STORE_PROP_ERROR
                      5246     
                      5247     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
078B    7880          5248     MOV R0 , # 80H 
078D    79FF          5249     MOV R1 , # 0FFH 
                      5250     
                      5251     GOVERNOR_STORE_PROP_ERROR: 
                      5252     	; Store proportional
078F    8849          5253     MOV GOV_PROPORTIONAL_L , R0 
0791    894A          5254     MOV GOV_PROPORTIONAL_H , R1 
                      5255     CALC_GOVERNOR_PROP_ERROR_EXIT: 
0793    22            5256     	RET						
                      5257     
                      5258     
                      5259     ; Third governor routine - calculate governor integral error
                      5260     CALC_GOVERNOR_INT_ERROR: 
                      5261     	; Add proportional to integral
0794    E549          5262     	MOV	A, GOV_PROPORTIONAL_L
0796    2546          5263     	ADD	A, GOV_INTEGRAL_L
0798    F8            5264     MOV R0 , A 
0799    E54A          5265     	MOV	A, GOV_PROPORTIONAL_H
079B    3547          5266     	ADDC	A, GOV_INTEGRAL_H
079D    F9            5267     MOV R1 , A 
079E    854A20        5268     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
07A1    E4            5269     	CLR	A
07A2    300701        5270     	JNB	BIT_ACCESS.7, ($+4)			
07A5    F4            5271     	CPL	A
07A6    3548          5272     	ADDC	A, GOV_INTEGRAL_X
07A8    FA            5273     MOV R2 , A 
                      5274     	; Check integral and limit
07A9    30E709        5275     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      5276     
07AC    C3            5277     	CLR	C
07AD    EA            5278     MOV A , R2 
07AE    94F0          5279     	SUBB	A, #0F0H					; Is error too negative?
07B0    4015          5280     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
07B2    0207CD        5281     	JMP	GOVERNOR_CHECK_PWM
                      5282     
                      5283     GOVERNOR_CHECK_INT_LIMIT_POS: 
07B5    C3            5284     	CLR	C
07B6    EA            5285     MOV A , R2 
07B7    940F          5286     	SUBB	A, #0FH					; Is error too positive?
07B9    5003          5287     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
07BB    0207CD        5288     	JMP	GOVERNOR_CHECK_PWM
                      5289     
                      5290     GOVERNOR_LIMIT_INT_ERROR_POS: 
07BE    78FF          5291     MOV R0 , # 0FFH 
07C0    79FF          5292     MOV R1 , # 0FFH 
07C2    7A0F          5293     MOV R2 , # 0FH 
07C4    0207CD        5294     	JMP	GOVERNOR_CHECK_PWM
                      5295     
                      5296     GOVERNOR_LIMIT_INT_ERROR_NEG: 
07C7    7800          5297     MOV R0 , # 00H 
07C9    7900          5298     MOV R1 , # 00H 
07CB    7AF0          5299     MOV R2 , # 0F0H 
                      5300     
                      5301     GOVERNOR_CHECK_PWM: 
                      5302     	; Check current pwm
07CD    C3            5303     	CLR	C
07CE    E524          5304     	MOV	A, CURRENT_PWM
07D0    9561          5305     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
07D2    500A          5306     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      5307     
07D4    C3            5308     	CLR	C
07D5    7401          5309     	MOV	A, #1
07D7    9524          5310     	SUBB	A, CURRENT_PWM				; Is current pwm at minimum?
07D9    500B          5311     	JNC	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      5312     
07DB    0207EB        5313     	JMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      5314     
                      5315     GOVERNOR_INT_MAX_PWM: 
07DE    E54A          5316     	MOV	A, GOV_PROPORTIONAL_H
07E0    20E70E        5317     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      5318     
07E3    0207EB        5319     	JMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      5320     
                      5321     GOVERNOR_INT_MIN_PWM: 
07E6    E54A          5322     	MOV	A, GOV_PROPORTIONAL_H
07E8    30E706        5323     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      5324     
                      5325     GOVERNOR_STORE_INT_ERROR: 
                      5326     	; Store integral
07EB    8846          5327     MOV GOV_INTEGRAL_L , R0 
07ED    8947          5328     MOV GOV_INTEGRAL_H , R1 
07EF    8A48          5329     MOV GOV_INTEGRAL_X , R2 
                      5330     CALC_GOVERNOR_INT_ERROR_EXIT: 
07F1    22            5331     	RET						
                      5332     
                      5333     
                      5334     ; Fourth governor routine - calculate governor proportional correction
                      5335     CALC_GOVERNOR_PROP_CORRECTION: 
                      5336     	; Load proportional gain
07F2    78A5          5337     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
07F4    E6            5338     MOV A , @ R0 
07F5    FA            5339     MOV R2 , A 
                      5340     	; Load proportional
07F6    C3            5341     	CLR	C
07F7    E549          5342     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
07F9    33            5343     	RLC	A
07FA    F8            5344     MOV R0 , A 
07FB    E54A          5345     	MOV	A, GOV_PROPORTIONAL_H
07FD    33            5346     	RLC	A
07FE    F9            5347     MOV R1 , A 
                      5348     	; Apply gain
07FF    1206AC        5349     	CALL	MULT_S16_BY_U8_DIV_16
                      5350     	; Check error and limit (to low byte)
0802    E9            5351     MOV A , R1 
0803    30E70B        5352     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      5353     
0806    C3            5354     	CLR	C
0807    E8            5355     MOV A , R0 
0808    9480          5356     	SUBB	A, #80H					; Is error too negative?
080A    E9            5357     MOV A , R1 
080B    94FF          5358     	SUBB	A, #0FFH
080D    4013          5359     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
080F    0126          5360     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      5361     
                      5362     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0811    C3            5363     	CLR	C
0812    E8            5364     MOV A , R0 
0813    947F          5365     	SUBB	A, #7FH					; Is error too positive?
0815    E9            5366     MOV A , R1 
0816    9400          5367     	SUBB	A, #00H
0818    5002          5368     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
081A    0126          5369     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      5370     
                      5371     GOVERNOR_LIMIT_PROP_CORR_POS: 
081C    787F          5372     MOV R0 , # 7FH 
081E    7900          5373     MOV R1 , # 00H 
0820    0126          5374     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      5375     
                      5376     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0822    7880          5377     MOV R0 , # 80H 
0824    79FF          5378     MOV R1 , # 0FFH 
                      5379     
                      5380     GOVERNOR_APPLY_PROP_CORR: 
                      5381     	; Test proportional sign
0826    E8            5382     MOV A , R0 
0827    20E715        5383     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      5384     
                      5385     	; Subtract positive proportional
082A    C3            5386     	CLR	C
082B    E523          5387     	MOV	A, GOVERNOR_REQ_PWM
082D    98            5388     SUBB A , R0 
082E    F8            5389     MOV R0 , A 
                      5390     	; Check result
082F    4009          5391     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      5392     
0831    C3            5393     	CLR	C
0832    E8            5394     MOV A , R0 
0833    9401          5395     	SUBB	A, #1
0835    4003          5396     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0837    02084D        5397     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      5398     
                      5399     GOVERNOR_CORR_PROP_MIN_PWM: 
083A    7801          5400     MOV R0 , # 1 
083C    02084D        5401     	JMP	GOVERNOR_STORE_PROP_CORR
                      5402     
                      5403     GOVERNOR_CORR_NEG_PROP: 
                      5404     	; Add negative proportional
083F    E8            5405     MOV A , R0 
0840    F4            5406     	CPL	A
0841    2401          5407     	ADD	A, #1
0843    2523          5408     	ADD	A, GOVERNOR_REQ_PWM
0845    F8            5409     MOV R0 , A 
                      5410     	; Check result
0846    4003          5411     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0848    02084D        5412     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      5413     
                      5414     GOVERNOR_CORR_PROP_MAX_PWM: 
084B    78FF          5415     MOV R0 , # 255 
                      5416     GOVERNOR_STORE_PROP_CORR: 
                      5417     	; Store proportional pwm
084D    884B          5418     MOV GOV_PROP_PWM , R0 
                      5419     CALC_GOVERNOR_PROP_CORR_EXIT: 
084F    22            5420     	RET
                      5421     
                      5422     
                      5423     ; Fifth governor routine - calculate governor integral correction
                      5424     CALC_GOVERNOR_INT_CORRECTION: 
                      5425     	; Load integral gain
0850    78A6          5426     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0852    E6            5427     MOV A , @ R0 
0853    FA            5428     MOV R2 , A 
                      5429     	; Load integral
0854    A847          5430     MOV R0 , GOV_INTEGRAL_H 
0856    A948          5431     MOV R1 , GOV_INTEGRAL_X 
                      5432     	; Apply gain
0858    1206AC        5433     	CALL	MULT_S16_BY_U8_DIV_16
                      5434     	; Check integral and limit
085B    E9            5435     MOV A , R1 
085C    30E70C        5436     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      5437     
085F    C3            5438     	CLR	C
0860    E8            5439     MOV A , R0 
0861    9401          5440     	SUBB	A, #01H					; Is integral too negative?
0863    E9            5441     MOV A , R1 
0864    94FF          5442     	SUBB	A, #0FFH
0866    4016          5443     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0868    020882        5444     	JMP	GOVERNOR_APPLY_INT_CORR
                      5445     
                      5446     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
086B    C3            5447     	CLR	C
086C    E8            5448     MOV A , R0 
086D    94FF          5449     	SUBB	A, #0FFH					; Is integral too positive?
086F    E9            5450     MOV A , R1 
0870    9400          5451     	SUBB	A, #00H
0872    5003          5452     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0874    020882        5453     	JMP	GOVERNOR_APPLY_INT_CORR
                      5454     
                      5455     GOVERNOR_LIMIT_INT_CORR_POS: 
0877    78FF          5456     MOV R0 , # 0FFH 
0879    7900          5457     MOV R1 , # 00H 
087B    020882        5458     	JMP	GOVERNOR_APPLY_INT_CORR
                      5459     
                      5460     GOVERNOR_LIMIT_INT_CORR_NEG: 
087E    7801          5461     MOV R0 , # 01H 
0880    79FF          5462     MOV R1 , # 0FFH 
                      5463     
                      5464     GOVERNOR_APPLY_INT_CORR: 
                      5465     	; Test integral sign
0882    E9            5466     MOV A , R1 
0883    20E715        5467     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      5468     
                      5469     	; Subtract positive integral
0886    C3            5470     	CLR	C
0887    E54B          5471     	MOV	A, GOV_PROP_PWM
0889    98            5472     SUBB A , R0 
088A    F8            5473     MOV R0 , A 
                      5474     	; Check result
088B    4009          5475     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      5476     
088D    C3            5477     	CLR	C
088E    E8            5478     MOV A , R0 
088F    9401          5479     	SUBB	A, #1
0891    4003          5480     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0893    0208A9        5481     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      5482     
                      5483     GOVERNOR_CORR_INT_MIN_PWM: 
0896    7801          5484     MOV R0 , # 1 
0898    0208A9        5485     	JMP	GOVERNOR_STORE_INT_CORR
                      5486     
                      5487     GOVERNOR_CORR_NEG_INT: 
                      5488     	; Add negative integral
089B    E8            5489     MOV A , R0 
089C    F4            5490     	CPL	A
089D    2401          5491     	ADD	A, #1
089F    254B          5492     	ADD	A, GOV_PROP_PWM
08A1    F8            5493     MOV R0 , A 
                      5494     	; Check result
08A2    4003          5495     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
08A4    0208A9        5496     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      5497     
                      5498     GOVERNOR_CORR_INT_MAX_PWM: 
08A7    78FF          5499     MOV R0 , # 255 
                      5500     GOVERNOR_STORE_INT_CORR: 
                      5501     	; Store current pwm
08A9    8824          5502     MOV CURRENT_PWM , R0 
                      5503     CALC_GOVERNOR_INT_CORR_EXIT: 
08AB    22            5504     	RET
                      5505     
                      5506     
                      5507     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5508     ;
                      5509     ; Set pwm limit low rpm
                      5510     ;
                      5511     ; No assumptions
                      5512     ;
                      5513     ; Sets power limit for low rpms and disables demag for low rpms
                      5514     ;
                      5515     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5516     SET_PWM_LIMIT_LOW_RPM: 
                      5517     	; Set pwm limit and demag disable for low rpms
08AC    78FF          5518     MOV R0 , # 0FFH 
08AE    206928        5519     JB FLAGS1 . 1 , SET_PWM_LIMIT_LOW_RPM_EXIT 
                      5520     
08B1    79A1          5521     MOV R1 , # PGM_ENABLE_POWER_PROT 
08B3    E7            5522     MOV A , @ R1 
08B4    6023          5523     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Exit if disabled
                      5524     
08B6    E541          5525     	MOV	A, COMM_PERIOD4X_H
08B8    601F          5526     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Avoid divide by zero
                      5527     
08BA    74FF          5528     	MOV	A, #255						; Divide 255 by Comm_Period4x_H
08BC    8541F0        5529     	MOV	B, COMM_PERIOD4X_H
08BF    84            5530     	DIV	AB
08C0    8539F0        5531     	MOV	B, LOW_RPM_PWR_SLOPE			; Multiply by slope
08C3    306A03        5532     JNB FLAGS1 . 2 , ( $+6 ) 
08C6    75F005        5533     	MOV	B, #5
08C9    A4            5534     	MUL	AB
08CA    F8            5535     MOV R0 , A 
08CB    C5F0          5536     	XCH	A, B
08CD    6002          5537     	JZ	($+4)						; Limit to max
                      5538     	
08CF    78FF          5539     MOV R0 , # 0FFH 
                      5540     
08D1    C3            5541     	CLR	C
08D2    E8            5542     MOV A , R0 
08D3    9564          5543     	SUBB	A, PWM_SPOOLUP_BEG
08D5    5002          5544     	JNC	SET_PWM_LIMIT_LOW_RPM_EXIT
                      5545     
08D7    A864          5546     MOV R0 , PWM_SPOOLUP_BEG 
                      5547     
                      5548     SET_PWM_LIMIT_LOW_RPM_EXIT: 
08D9    8863          5549     MOV PWM_LIMIT_BY_RPM , R0 
08DB    22            5550     	RET
                      5551     	
                      5552     
                      5553     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5554     ;
                      5555     ; Set pwm limit high rpm
                      5556     ;
                      5557     ; No assumptions
                      5558     ;
                      5559     ; Sets power limit for high rpms
                      5560     ;
                      5561     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5562     SET_PWM_LIMIT_HIGH_RPM: 
                      5563     IF MCU_48MHZ == 1
08DC    C3            5564     	CLR	C
08DD    E540          5565     	MOV	A, COMM_PERIOD4X_L
08DF    94C8          5566     	SUBB	A, #0C8H				; Limit Comm_Period to 200, which is 400k erpm
08E1    E541          5567     	MOV	A, COMM_PERIOD4X_H
08E3    9400          5568     	SUBB	A, #00H
                      5569     ELSE
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_L
                               	SUBB	A, #40H				; Limit Comm_Period to 320, which is 250k erpm
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, #01H
                               ENDIF
08E5    E563          5576     	MOV	A, PWM_LIMIT_BY_RPM
08E7    5003          5577     	JNC	SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT
                      5578     	
08E9    14            5579     	DEC	A
08EA    01ED          5580     	AJMP	SET_PWM_LIMIT_HIGH_RPM_STORE
                      5581     	
                      5582     SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT: 
08EC    04            5583     	INC	A
                      5584     SET_PWM_LIMIT_HIGH_RPM_STORE: 
08ED    6002          5585     	JZ	($+4)
                      5586     
08EF    F563          5587     	MOV	PWM_LIMIT_BY_RPM, A
                      5588     
08F1    22            5589     	RET
                      5590     
                      5591     
                      5592     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5593     ;
                      5594     ; Measure lipo cells
                      5595     ;
                      5596     ; No assumptions
                      5597     ;
                      5598     ; Measure voltage and calculate lipo cells
                      5599     ;
                      5600     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5601     MEASURE_LIPO_CELLS: 
                      5602     IF MODE >= 1	; Tail or multi
                      5603     	; If not supported, then exit
08F2    0208F5        5604     	JMP	MEASURE_LIPO_EXIT
                      5605     ENDIF
                      5606     IF MODE == 0	; Main
                               	; Load programmed low voltage limit
                               	MOV	TEMP1, #PGM_LOW_VOLTAGE_LIM	; Load limit
                               	MOV	A, @TEMP1				
                               	MOV	BIT_ACCESS, A				; Store in Bit_Access
                               	; Set commutation to BpFET on
                               	CALL	COMM5COMM6			
                               	; Start adc
                               	START_ADC 
                               	; Wait for ADC reference to settle, and then start again
                               	CALL	WAIT1MS
                               	START_ADC
                               	; Wait for ADC conversion to complete
                               MEASURE_LIPO_WAIT_ADC:
                               	JNB	AD0INT, MEASURE_LIPO_WAIT_ADC
                               	; Read ADC result
                               	READ_ADC_RESULT
                               	; Stop ADC
                               	STOP_ADC
                               	; Switch power off
                               	CALL	SWITCH_POWER_OFF		
                               	; Set limit step
                               	MOV	LIPO_ADC_LIMIT_L, #ADC_LIMIT_L
                               	MOV	LIPO_ADC_LIMIT_H, #ADC_LIMIT_H
                               	CLR	C
                               	MOV	A, #ADC_LIMIT_H		; Divide 3.0V value by 2
                               	RRC	A
                               	MOV	TEMP6, A
                               	MOV	A, #ADC_LIMIT_L
                               	JZ	MEASURE_LIPO_EXIT		; Exit if disabled
                               
                               	RRC	A
                               	MOV	TEMP5, A
                               	MOV	A, #ADC_LIMIT_L		; Calculate 1.5*3.0V=4.5V value
                               	ADD	A, TEMP5
                               	MOV	TEMP5, A
                               	MOV	A, #ADC_LIMIT_H		
                               	ADDC	A, TEMP6
                               	MOV	TEMP6, A
                               	MOV	A, TEMP5				; Copy step
                               	MOV	TEMP3, A
                               	MOV	A, TEMP6	
                               	MOV	TEMP4, A
                               MEASURE_LIPO_CELL_LOOP:
                               	; Check voltage against xS lower limit
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, TEMP3				; Voltage above limit?
                               	MOV	A, TEMP2
                               	SUBB A, TEMP4
                               	JC	MEASURE_LIPO_ADJUST		; No - branch
                               
                               	; Set xS voltage limit
                               	MOV	A, LIPO_ADC_LIMIT_L		
                               	ADD	A, #ADC_LIMIT_L
                               	MOV	LIPO_ADC_LIMIT_L, A
                               	MOV	A, LIPO_ADC_LIMIT_H		
                               	ADDC	A, #ADC_LIMIT_H
                               	MOV	LIPO_ADC_LIMIT_H, A
                               	; Set (x+1)S lower limit
                               	MOV	A, TEMP3
                               	ADD	A, TEMP5				; Add step
                               	MOV	TEMP3, A
                               	MOV	A, TEMP4
                               	ADDC	A, TEMP6
                               	MOV	TEMP4, A
                               	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                               
                               MEASURE_LIPO_ADJUST:
                               	MOV	TEMP7, LIPO_ADC_LIMIT_L
                               	MOV	TEMP8, LIPO_ADC_LIMIT_H
                               	; Calculate 3.125%
                               	CLR	C
                               	MOV	A, LIPO_ADC_LIMIT_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, LIPO_ADC_LIMIT_L	
                               	RRC	A
                               	MOV	TEMP1, A			; After this 50%
                               	CLR	C
                               	MOV	A, TEMP2
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1	
                               	RRC	A
                               	MOV	TEMP1, A			; After this 25%
                               	; Divide three times to get to 3.125%
                               	MOV	TEMP3, #3
                               MEASURE_LIPO_DIVIDE_LOOP:
                               	CLR	C
                               	MOV	A, TEMP2
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1	
                               	RRC	A
                               	MOV	TEMP1, A			
                               	DJNZ	TEMP3, MEASURE_LIPO_DIVIDE_LOOP
                               
                               	; Add the programmed number of 0.1V (or 3.125% increments)
                               	MOV	TEMP3, BIT_ACCESS		; Load programmed limit (Bit_Access has Pgm_Low_Voltage_Lim)
                               	DEC	TEMP3
                               	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                               
                               	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
                               	MOV	LIPO_ADC_LIMIT_H, #0
                               	JMP	MEASURE_LIPO_EXIT	
                               
                               MEASURE_LIPO_LIMIT_ON:
                               	DEC	TEMP3
                               	MOV	A, TEMP3
                               	JZ	MEASURE_LIPO_UPDATE
                               
                               MEASURE_LIPO_ADD_LOOP:
                               	MOV	A, TEMP7			; Add 3.125%
                               	ADD	A, TEMP1
                               	MOV	TEMP7, A
                               	MOV	A, TEMP8
                               	ADDC	A, TEMP2
                               	MOV	TEMP8, A
                               	DJNZ	TEMP3, MEASURE_LIPO_ADD_LOOP
                               
                               MEASURE_LIPO_UPDATE:
                               	; Set ADC limit
                               	MOV	LIPO_ADC_LIMIT_L, TEMP7
                               	MOV	LIPO_ADC_LIMIT_H, TEMP8
                               ENDIF
                      5732     MEASURE_LIPO_EXIT: 
08F5    22            5733     	RET
                      5734     
                      5735     
                      5736     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5737     ;
                      5738     ; Start ADC conversion
                      5739     ;
                      5740     ; No assumptions
                      5741     ;
                      5742     ; Start conversion used for measuring power supply voltage
                      5743     ;
                      5744     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5745     START_ADC_CONVERSION: 
                      5746     	; Start adc
                      5747     	START_ADC 
08F6    75E890        5747+1   MOV ADC0CN , # 90H  ; ADC START
08F9    22            5748     	RET
                      5749     
                      5750     
                      5751     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5752     ;
                      5753     ; Check temperature, power supply voltage and limit power
                      5754     ;
                      5755     ; No assumptions
                      5756     ;
                      5757     ; Used to limit main motor power in order to maintain the required voltage
                      5758     ;
                      5759     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5760     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      5761     	; Load programmed low voltage limit
08FA    7883          5762     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
08FC    E6            5763     MOV A , @ R0 
08FD    FF            5764     MOV R7 , A 
                      5765     	; Wait for ADC conversion to complete
08FE    30EDF9        5766     	JNB	AD0INT, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      5767     	; Read ADC result
                      5768     	READ_ADC_RESULT
0901    A8BD          5768+1   MOV R0 , ADC0L 
0903    A9BE          5768+1   MOV R1 , ADC0H 
                      5769     	; Stop ADC
                      5770     	STOP_ADC
                      5771     
0905    0570          5772     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0907    C3            5773     	CLR	C
0908    E570          5774     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
090A    9408          5775     SUBB A , # 8 
090C    4052          5776     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      5777     
090E    757000        5778     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0911    E9            5779     MOV A , R1 
0912    FA            5780     MOV R2 , A 
0913    79A0          5781     MOV R1 , # PGM_ENABLE_TEMP_PROT 
0915    E7            5782     MOV A , @ R1 
0916    6044          5783     	JZ	TEMP_CHECK_EXIT			; No - branch
                      5784     
0918    EA            5785     MOV A , R2 
0919    7007          5786     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      5787     
091B    E571          5788     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
091D    601B          5789     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
091F    02092E        5790     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      5791     
                      5792     TEMP_AVERAGE_INC_DEC: 
0922    C3            5793     	CLR	C
0923    E8            5794     MOV A , R0 
0924    9571          5795     	SUBB	A, CURRENT_AVERAGE_TEMP
0926    6010          5796     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      5797     
0928    E571          5798     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
092A    5006          5799     	JNC	TEMP_AVERAGE_INC				
                      5800     
092C    600C          5801     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      5802     TEMP_AVERAGE_DEC: 
092E    14            5803     	DEC	A						; Decrement average
092F    02093A        5804     	JMP	TEMP_AVERAGE_UPDATED
                      5805     
                      5806     TEMP_AVERAGE_INC: 
0932    04            5807     	INC	A						; Increment average
0933    60F9          5808     	JZ	TEMP_AVERAGE_DEC
0935    02093A        5809     	JMP	TEMP_AVERAGE_UPDATED
                      5810     
                      5811     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0938    E571          5812     	MOV	A, CURRENT_AVERAGE_TEMP
                      5813     TEMP_AVERAGE_UPDATED: 
093A    F571          5814     	MOV	CURRENT_AVERAGE_TEMP, A
093C    C3            5815     	CLR	C
093D    9472          5816     SUBB A , # 114 
093F    401B          5817     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5818     
0941    7561C0        5819     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      5820     
0944    C3            5821     	CLR	C
0945    9404          5822     SUBB A , # 4 
0947    4013          5823     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5824     
0949    756180        5825     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      5826     
094C    C3            5827     	CLR	C
094D    9404          5828     SUBB A , # 4 
094F    400B          5829     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5830     
0951    756140        5831     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      5832     
0954    C3            5833     	CLR	C
0955    9404          5834     SUBB A , # 4 
0957    4003          5835     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5836     
0959    756100        5837     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      5838     
                      5839     TEMP_CHECK_EXIT: 
                      5840     	SET_ADC_IP_VOLT				; Select adc input for next conversion
095C    75BB08        5840+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
095F    22            5841     	RET
                      5842     
                      5843     CHECK_VOLTAGE_START: 
                      5844     IF MODE == 0	; Main 
                               	; Check if low voltage limiting is enabled
                               	MOV	A, TEMP8
                               	CLR	C
                               	SUBB	A, #1					; Is low voltage limit disabled?
                               	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                               
                               	MOV	A, #ADC_LIMIT_L			; Is low voltage limit zero (ESC does not support it)?
                               	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                               
                               	; Check if ADC is saturated
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, #0FFH
                               	MOV	A, TEMP2
                               	SUBB	A, #03H
                               	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                               
                               	; Check voltage against limit
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, LIPO_ADC_LIMIT_L
                               	MOV	A, TEMP2
                               	SUBB	A, LIPO_ADC_LIMIT_H
                               	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                               
                               	; Decrease pwm limit
                               	MOV  A, PWM_LIMIT
                               	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                               
                               	DEC	PWM_LIMIT					; Decrement limit
                               	JMP	CHECK_VOLTAGE_LIM
                               
                               CHECK_VOLTAGE_GOOD:
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	CPL	A			
                               	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                               
                               	INC	PWM_LIMIT					; Increment limit
                               
                               CHECK_VOLTAGE_LIM:
                               	MOV	TEMP1, PWM_LIMIT			; Set limit
                               	CLR	C
                               	MOV	A, CURRENT_PWM
                               	SUBB	A, TEMP1
                               	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                               
                               	MOV	TEMP1, CURRENT_PWM			; Set current pwm (no limiting)
                               
                               CHECK_VOLTAGE_SPOOLUP_LIM:
                               	; Slow spoolup
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_LIMIT_SPOOLUP
                               	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                               
                               	MOV	TEMP1, PWM_LIMIT_SPOOLUP
                               	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
                               	CPL	A
                               	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                                
                               	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                               
                               CHECK_VOLTAGE_EXIT:
                               	MOV  CURRENT_PWM_LIMITED, TEMP1
                               	MOV	CURRENT_PWM_LIM_DITH, TEMP1
                               ENDIF
                      5912     IF MODE == 1	; Tail
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	CPL	A			
                               	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                               
                               	INC	PWM_LIMIT					; Increment limit
                               
                               CHECK_VOLTAGE_LIM:
                               ENDIF
                      5922     IF MODE == 2	; Multi
                      5923     	; Increase pwm limit
0960    E561          5924     	MOV  A, PWM_LIMIT
0962    2410          5925     	ADD	A, #16			
0964    5002          5926     	JNC	($+4)					; If not max - branch
                      5927     
0966    74FF          5928     	MOV	A, #255
                      5929     
0968    F561          5930     	MOV	PWM_LIMIT, A				; Increment limit 
                      5931     	; Set current pwm limited if closed loop mode
096A    7982          5932     MOV R1 , # PGM_GOV_MODE 
096C    B70402        5933     CJNE @ R1 , # 4 , ( $+5 ) 
096F    2187          5934     	AJMP	CHECK_VOLTAGE_PWM_DONE		; No - branch
                      5935     
0971    C3            5936     	CLR	C
0972    A861          5937     MOV R0 , PWM_LIMIT 
0974    E524          5938     	MOV	A, CURRENT_PWM
0976    98            5939     SUBB A , R0 
0977    5002          5940     	JNC	CHECK_VOLTAGE_LOW_RPM		; If current pwm above limit - branch and limit	
                      5941     
0979    A824          5942     MOV R0 , CURRENT_PWM 
                      5943     
                      5944     CHECK_VOLTAGE_LOW_RPM: 
                      5945     	; Limit pwm for low rpms
097B    C3            5946     	CLR	C
097C    E8            5947     MOV A , R0 
097D    9563          5948     	SUBB	A, PWM_LIMIT_BY_RPM
097F    4002          5949     	JC	($+4)					; If current pwm below limit - branch
                      5950     
0981    A863          5951     MOV R0 , PWM_LIMIT_BY_RPM 
                      5952     
0983    8825          5953     MOV CURRENT_PWM_LIMITED , R0 
0985    8826          5954     MOV CURRENT_PWM_LIM_DITH , R0 
                      5955     CHECK_VOLTAGE_PWM_DONE: 
                      5956     ENDIF
                      5957     	; Set adc mux for next conversion
0987    E570          5958     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0989    B40703        5959     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      5960     
                      5961     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
098C    75BB10        5961+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5962     
                      5963     CHECK_VOLTAGE_RET: 
098F    22            5964     	RET
                      5965     
                      5966     
                      5967     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5968     ;
                      5969     ; Set startup PWM routine
                      5970     ;
                      5971     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      5972     ;
                      5973     ; Used for pwm control during startup
                      5974     ;
                      5975     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5976     SET_STARTUP_PWM: 	
                      5977     	; Adjust startup power
0990    7432          5978     MOV A , # 50 
0992    79A7          5979     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0994    87F0          5980     MOV B , @ R1 
0996    A4            5981     	MUL	AB
0997    C5F0          5982     	XCH	A, B
0999    A2F7          5983     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
099B    33            5984     	RLC	A
099C    F8            5985     MOV R0 , A 
099D    C3            5986     	CLR	C
099E    E8            5987     MOV A , R0 
099F    9561          5988     	SUBB	A, PWM_LIMIT	
09A1    4002          5989     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      5990     
09A3    A861          5991     MOV R0 , PWM_LIMIT 
                      5992     
                      5993     STARTUP_PWM_SET_PWM: 
                      5994     	; Set pwm variables
09A5    8822          5995     MOV REQUESTED_PWM , R0 
09A7    8824          5996     MOV CURRENT_PWM , R0 
09A9    8825          5997     MOV CURRENT_PWM_LIMITED , R0 
09AB    8826          5998     MOV CURRENT_PWM_LIM_DITH , R0 
09AD    8864          5999     MOV PWM_SPOOLUP_BEG , R0 
09AF    22            6000     	RET
                      6001     
                      6002     
                      6003     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6004     ;
                      6005     ; Initialize timing routine
                      6006     ;
                      6007     ; No assumptions
                      6008     ;
                      6009     ; Part of initialization before motor start
                      6010     ;
                      6011     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6012     INITIALIZE_TIMING:  
09B0    754000        6013     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
09B3    7541F0        6014     	MOV	COMM_PERIOD4X_H, #0F0H
09B6    22            6015     	RET
                      6016     
                      6017     
                      6018     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6019     ;
                      6020     ; Calculate next commutation timing routine
                      6021     ;
                      6022     ; No assumptions
                      6023     ;
                      6024     ; Called immediately after each commutation
                      6025     ; Also sets up timer 3 to wait advance timing
                      6026     ; Two entry points are used
                      6027     ;
                      6028     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6029     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
                      6030     	; Read commutation time
09B7    C2AF          6031     	CLR	EA
09B9    75C820        6032     	MOV	TMR2CN, #20H		; Timer2 disabled
09BC    A8CC          6033     MOV R0 , TMR2L 
09BE    A9CD          6034     MOV R1 , TMR2H 
09C0    AA3A          6035     MOV R2 , TIMER2_X 
09C2    30CF01        6036     	JNB	TF2H, ($+4)		; Check if interrupt is pending
09C5    0A            6037     INC R2 
09C6    75C824        6038     	MOV	TMR2CN, #24H		; Timer2 enabled
09C9    D2AF          6039     	SETB	EA
                      6040     IF MCU_48MHZ == 1
09CB    C3            6041     	CLR	C
09CC    EA            6042     MOV A , R2 
09CD    13            6043     	RRC	A
09CE    FA            6044     MOV R2 , A 
09CF    E9            6045     MOV A , R1 
09D0    13            6046     	RRC	A
09D1    F9            6047     MOV R1 , A 
09D2    E8            6048     MOV A , R0 
09D3    13            6049     	RRC	A
09D4    F8            6050     MOV R0 , A 
                      6051     ENDIF
                      6052     	; Calculate this commutation time
09D5    AB3B          6053     MOV R3 , PREV_COMM_L 
09D7    AC3C          6054     MOV R4 , PREV_COMM_H 
09D9    883B          6055     MOV PREV_COMM_L , R0 
09DB    893C          6056     MOV PREV_COMM_H , R1 
09DD    C3            6057     	CLR	C
09DE    E8            6058     MOV A , R0 
09DF    9B            6059     SUBB A , R3 
09E0    F8            6060     MOV R0 , A 
09E1    E9            6061     MOV A , R1 
09E2    9C            6062     SUBB A , R4 
09E3    20690A        6063     JB FLAGS1 . 1 , CALC_NEXT_COMM_STARTUP 
                      6064     
                      6065     IF MCU_48MHZ == 1
09E6    547F          6066     	ANL	A, #7FH
                      6067     ENDIF
09E8    F9            6068     MOV R1 , A 
09E9    306602        6069     JNB FLAGS0 . 6 , ( $+5 ) 
09EC    41D4          6070     	AJMP	CALC_NEXT_COMM_TIMING_FAST
                      6071     
09EE    412E          6072     	AJMP	CALC_NEXT_COMM_NORMAL
                      6073     
                      6074     CALC_NEXT_COMM_STARTUP: 
09F0    AD3D          6075     MOV R5 , PREV_COMM_X 
09F2    8A3D          6076     MOV PREV_COMM_X , R2 
09F4    F9            6077     MOV R1 , A 
09F5    EA            6078     MOV A , R2 
09F6    9D            6079     SUBB A , R5 
                      6080     IF MCU_48MHZ == 1
09F7    547F          6081     	ANL	A, #7FH
                      6082     ENDIF
09F9    FA            6083     MOV R2 , A 
09FA    6004          6084     	JZ	($+6)
                      6085     
09FC    78FF          6086     MOV R0 , # 0FFH 
09FE    79FF          6087     MOV R1 , # 0FFH 
                      6088     
0A00    AE3E          6089     MOV R6 , PREV_PREV_COMM_L 
0A02    AF3F          6090     MOV R7 , PREV_PREV_COMM_H 
0A04    8B3E          6091     MOV PREV_PREV_COMM_L , R3 
0A06    8C3F          6092     MOV PREV_PREV_COMM_H , R4 
0A08    A83B          6093     MOV R0 , PREV_COMM_L 
0A0A    A93C          6094     MOV R1 , PREV_COMM_H 
0A0C    C3            6095     	CLR	C
0A0D    E8            6096     MOV A , R0 
0A0E    9E            6097     SUBB A , R6 
0A0F    F8            6098     MOV R0 , A 
0A10    E9            6099     MOV A , R1 
0A11    9F            6100     SUBB A , R7 
0A12    F9            6101     MOV R1 , A 
0A13    C3            6102     	CLR	C
0A14    E541          6103     	MOV	A, COMM_PERIOD4X_H		; Average with previous and save
0A16    13            6104     	RRC	A
0A17    FB            6105     MOV R3 , A 
0A18    E540          6106     	MOV	A, COMM_PERIOD4X_L
0A1A    13            6107     	RRC	A
0A1B    FA            6108     MOV R2 , A 
0A1C    E8            6109     MOV A , R0 
0A1D    2A            6110     ADD A , R2 
0A1E    F540          6111     	MOV	COMM_PERIOD4X_L, A
0A20    E9            6112     MOV A , R1 
0A21    3B            6113     ADDC A , R3 
0A22    F541          6114     	MOV	COMM_PERIOD4X_H, A
0A24    5006          6115     	JNC	($+8)
                      6116     
0A26    7540FF        6117     	MOV	COMM_PERIOD4X_L, #0FFH
0A29    7541FF        6118     	MOV	COMM_PERIOD4X_H, #0FFH
                      6119     
0A2C    417B          6120     	AJMP	CALC_NEW_WAIT_TIMES_SETUP
                      6121     
                      6122     CALC_NEXT_COMM_NORMAL: 
                      6123     	; Calculate new commutation time 
0A2E    AA40          6124     MOV R2 , COMM_PERIOD4X_L 
0A30    AB41          6125     MOV R3 , COMM_PERIOD4X_H 
0A32    AC40          6126     MOV R4 , COMM_PERIOD4X_L 
0A34    AD41          6127     MOV R5 , COMM_PERIOD4X_H 
0A36    7E04          6128     MOV R6 , # 4 
0A38    7F02          6129     MOV R7 , # 2 
0A3A    C3            6130     	CLR	C
0A3B    EB            6131     MOV A , R3 
0A3C    9404          6132     	SUBB	A, #04H
0A3E    400D          6133     	JC	CALC_NEXT_COMM_AVG_PERIOD_DIV
                      6134     
0A40    1E            6135     DEC R6 
0A41    1F            6136     DEC R7 
                      6137     
0A42    C3            6138     	CLR	C
0A43    EB            6139     MOV A , R3 
0A44    9408          6140     	SUBB	A, #08H
0A46    4005          6141     	JC	CALC_NEXT_COMM_AVG_PERIOD_DIV
                      6142     
0A48    206A02        6143     JB FLAGS1 . 2 , CALC_NEXT_COMM_AVG_PERIOD_DIV 
                      6144     
0A4B    1E            6145     DEC R6 
0A4C    1F            6146     DEC R7 
                      6147     
                      6148     CALC_NEXT_COMM_AVG_PERIOD_DIV: 
0A4D    C3            6149     	CLR	C
0A4E    ED            6150     MOV A , R5 
0A4F    13            6151     	RRC	A					; Divide by 2
0A50    FD            6152     MOV R5 , A 
0A51    EC            6153     MOV A , R4 
0A52    13            6154     	RRC	A
0A53    FC            6155     MOV R4 , A 
0A54    DEF7          6156     DJNZ R6 , CALC_NEXT_COMM_AVG_PERIOD_DIV 
                      6157     
0A56    C3            6158     	CLR	C
0A57    EA            6159     MOV A , R2 
0A58    9C            6160     SUBB A , R4 
0A59    FA            6161     MOV R2 , A 
0A5A    EB            6162     MOV A , R3 
0A5B    9D            6163     SUBB A , R5 
0A5C    FB            6164     MOV R3 , A 
0A5D    EF            6165     MOV A , R7 
0A5E    6009          6166     	JZ	CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE
                      6167     
                      6168     CALC_NEXT_COMM_NEW_PERIOD_DIV: 
0A60    C3            6169     	CLR	C
0A61    E9            6170     MOV A , R1 
0A62    13            6171     	RRC	A					; Divide by 2
0A63    F9            6172     MOV R1 , A 
0A64    E8            6173     MOV A , R0 
0A65    13            6174     	RRC	A
0A66    F8            6175     MOV R0 , A 
0A67    DFF7          6176     DJNZ R7 , CALC_NEXT_COMM_NEW_PERIOD_DIV 
                      6177     
                      6178     CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE: 
0A69    EA            6179     MOV A , R2 
0A6A    28            6180     ADD A , R0 
0A6B    FA            6181     MOV R2 , A 
0A6C    EB            6182     MOV A , R3 
0A6D    39            6183     ADDC A , R1 
0A6E    FB            6184     MOV R3 , A 
0A6F    8A40          6185     MOV COMM_PERIOD4X_L , R2 
0A71    8B41          6186     MOV COMM_PERIOD4X_H , R3 
0A73    5006          6187     	JNC	CALC_NEW_WAIT_TIMES_SETUP; If period larger than 0xffff - go to slow case
                      6188     
0A75    7BFF          6189     MOV R3 , # 0FFH 
0A77    8B40          6190     MOV COMM_PERIOD4X_L , R3 
0A79    8B41          6191     MOV COMM_PERIOD4X_H , R3 
                      6192     
                      6193     CALC_NEW_WAIT_TIMES_SETUP: 	
                      6194     	; Set high rpm bit (if above 156k erpm)
0A7B    C3            6195     	CLR	C
0A7C    EB            6196     MOV A , R3 
0A7D    9402          6197     	SUBB	A, #2
0A7F    5002          6198     	JNC	($+4)
                      6199     
0A81    D266          6200     SETB FLAGS0 . 6 
                      6201     	
                      6202     	; Load programmed commutation timing
0A83    306904        6203     JNB FLAGS1 . 1 , CALC_NEW_WAIT_PER_STARTUP_DONE 
                      6204     
0A86    7F03          6205     MOV R7 , # 3 
0A88    41A6          6206     	AJMP	CALC_NEW_WAIT_PER_DEMAG_DONE
                      6207     
                      6208     CALC_NEW_WAIT_PER_STARTUP_DONE: 
0A8A    7892          6209     MOV R0 , # PGM_COMM_TIMING 
0A8C    E6            6210     MOV A , @ R0 
0A8D    FF            6211     MOV R7 , A 
0A8E    C3            6212     	CLR	C
0A8F    E537          6213     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0A91    9482          6214     	SUBB	A, #130
0A93    4011          6215     	JC	CALC_NEW_WAIT_PER_DEMAG_DONE
                      6216     
0A95    0F            6217     INC R7 
                      6218     
0A96    C3            6219     	CLR	C
0A97    E537          6220     	MOV	A, DEMAG_DETECTED_METRIC
0A99    94A0          6221     	SUBB	A, #160
0A9B    4001          6222     	JC	($+3)
                      6223     
0A9D    0F            6224     INC R7 
                      6225     
0A9E    C3            6226     	CLR	C
0A9F    EF            6227     MOV A , R7 
0AA0    9406          6228     	SUBB	A, #6
0AA2    4002          6229     	JC	($+4)
                      6230     
0AA4    7F05          6231     MOV R7 , # 5 
                      6232     
                      6233     CALC_NEW_WAIT_PER_DEMAG_DONE: 
0AA6    7E02          6234     MOV R6 , # 2 
                      6235     	; Load current commutation timing
0AA8    E541          6236     	MOV	A, COMM_PERIOD4X_H		; Divide 4 times
0AAA    C4            6237     	SWAP	A
0AAB    540F          6238     	ANL	A, #00FH
0AAD    F9            6239     MOV R1 , A 
0AAE    E541          6240     	MOV	A, COMM_PERIOD4X_H
0AB0    C4            6241     	SWAP	A
0AB1    54F0          6242     	ANL	A, #0F0H
0AB3    F8            6243     MOV R0 , A 
0AB4    E540          6244     	MOV	A, COMM_PERIOD4X_L
0AB6    C4            6245     	SWAP	A
0AB7    540F          6246     	ANL	A, #00FH
0AB9    28            6247     ADD A , R0 
0ABA    F8            6248     MOV R0 , A 
                      6249     
0ABB    C3            6250     	CLR	C
0ABC    E8            6251     MOV A , R0 
0ABD    9E            6252     SUBB A , R6 
0ABE    FA            6253     MOV R2 , A 
0ABF    E9            6254     MOV A , R1 
0AC0    9400          6255     	SUBB	A, #0
0AC2    FB            6256     MOV R3 , A 
0AC3    4009          6257     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      6258     
0AC5    C3            6259     	CLR	C
0AC6    EA            6260     MOV A , R2 
0AC7    9402          6261     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0AC9    EB            6262     MOV A , R3 
0ACA    9400          6263     	SUBB	A, #0
0ACC    5004          6264     	JNC	CALC_NEW_WAIT_TIMES_EXIT	; Check that result is still above minumum
                      6265     
                      6266     LOAD_MIN_TIME: 
0ACE    7A02          6267     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0AD0    E4            6268     	CLR	A
0AD1    FB            6269     MOV R3 , A 
                      6270     
                      6271     CALC_NEW_WAIT_TIMES_EXIT: 	
0AD2    6120          6272     	AJMP	WAIT_ADVANCE_TIMING
                      6273     
                      6274     
                      6275     ; Fast calculation (Comm_Period4x_H less than 2)
                      6276     CALC_NEXT_COMM_TIMING_FAST: 			
                      6277     	; Calculate new commutation time
0AD4    AA40          6278     MOV R2 , COMM_PERIOD4X_L 
0AD6    AB41          6279     MOV R3 , COMM_PERIOD4X_H 
0AD8    EB            6280     MOV A , R3 
0AD9    C4            6281     	SWAP	A
0ADA    FE            6282     MOV R6 , A 
0ADB    EA            6283     MOV A , R2 
0ADC    C4            6284     	SWAP A
0ADD    540F          6285     	ANL	A, #0FH
0ADF    4E            6286     ORL A , R6 
0AE0    FC            6287     MOV R4 , A 
0AE1    C3            6288     	CLR	C
0AE2    EA            6289     MOV A , R2 
0AE3    9C            6290     SUBB A , R4 
0AE4    FA            6291     MOV R2 , A 
0AE5    EB            6292     MOV A , R3 
0AE6    9400          6293     	SUBB	A, #0
0AE8    FB            6294     MOV R3 , A 
0AE9    C3            6295     	CLR	C
0AEA    E8            6296     MOV A , R0 
0AEB    13            6297     	RRC	A					; Divide by 2 2 times
0AEC    C3            6298     	CLR	C
0AED    13            6299     	RRC	A
0AEE    F8            6300     MOV R0 , A 
0AEF    EA            6301     MOV A , R2 
0AF0    28            6302     ADD A , R0 
0AF1    FA            6303     MOV R2 , A 
0AF2    EB            6304     MOV A , R3 
0AF3    3400          6305     	ADDC	A, #0
0AF5    FB            6306     MOV R3 , A 
0AF6    8A40          6307     MOV COMM_PERIOD4X_L , R2 
0AF8    8B41          6308     MOV COMM_PERIOD4X_H , R3 
0AFA    C3            6309     	CLR	C
0AFB    EB            6310     MOV A , R3 
0AFC    9402          6311     	SUBB	A, #2
0AFE    4002          6312     	JC	($+4)
                      6313     
0B00    C266          6314     CLR FLAGS0 . 6 
                      6315     	
0B02    7802          6316     MOV R0 , # 2 
0B04    EB            6317     MOV A , R3 
0B05    C4            6318     	SWAP	A
0B06    FE            6319     MOV R6 , A 
0B07    7B00          6320     MOV R3 , # 0 
0B09    EA            6321     MOV A , R2 
0B0A    C4            6322     	SWAP A
0B0B    540F          6323     	ANL	A, #0FH
0B0D    4E            6324     ORL A , R6 
0B0E    FA            6325     MOV R2 , A 
0B0F    C3            6326     	CLR	C
0B10    EA            6327     MOV A , R2 
0B11    98            6328     SUBB A , R0 
0B12    FA            6329     MOV R2 , A 
0B13    4005          6330     	JC	LOAD_MIN_TIME_FAST		; Check that result is still positive
                      6331     
0B15    C3            6332     	CLR	C
0B16    9402          6333     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0B18    5002          6334     	JNC	CALC_NEW_WAIT_TIMES_FAST_DONE	; Check that result is still above minumum
                      6335     
                      6336     LOAD_MIN_TIME_FAST: 
0B1A    7A02          6337     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
                      6338     
                      6339     CALC_NEW_WAIT_TIMES_FAST_DONE: 	
0B1C    7892          6340     MOV R0 , # PGM_COMM_TIMING 
0B1E    E6            6341     MOV A , @ R0 
0B1F    FF            6342     MOV R7 , A 
                      6343     
                      6344     
                      6345     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6346     ;
                      6347     ; Wait advance timing routine
                      6348     ;
                      6349     ; No assumptions
                      6350     ; NOTE: Be VERY careful if using temp registers. They are passed over this routine
                      6351     ;
                      6352     ; Waits for the advance timing to elapse and sets up the next zero cross wait
                      6353     ;
                      6354     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6355     WAIT_ADVANCE_TIMING: 	
0B20    306002        6356     JNB FLAGS0 . 0 , ( $+5 ) 
0B23    6120          6357     	AJMP	WAIT_ADVANCE_TIMING
                      6358     
                      6359     	; Setup next wait time
0B25    855192        6360     	MOV	TMR3RLL, WT_ZC_TOUT_START_L
0B28    855293        6361     	MOV	TMR3RLH, WT_ZC_TOUT_START_H
0B2B    D260          6362     SETB FLAGS0 . 0 
0B2D    43E680        6363     	ORL	EIE1, #80H	; Enable timer3 interrupts
                      6364     
                      6365     
                      6366     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6367     ;
                      6368     ; Calculate new wait times routine
                      6369     ;
                      6370     ; No assumptions
                      6371     ;
                      6372     ; Calculates new wait times
                      6373     ;
                      6374     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6375     CALC_NEW_WAIT_TIMES: 	
0B30    C3            6376     	CLR	C
0B31    E4            6377     	CLR	A
0B32    9A            6378     SUBB A , R2 
0B33    F8            6379     MOV R0 , A 
0B34    E4            6380     	CLR	A
0B35    9B            6381     SUBB A , R3 
0B36    F9            6382     MOV R1 , A 
                      6383     IF MCU_48MHZ == 1
0B37    C3            6384     	CLR	C
0B38    E8            6385     MOV A , R0 
0B39    33            6386     	RLC	A
0B3A    F8            6387     MOV R0 , A 
0B3B    E9            6388     MOV A , R1 
0B3C    33            6389     	RLC	A
0B3D    F9            6390     MOV R1 , A 
                      6391     ENDIF
0B3E    306602        6392     JNB FLAGS0 . 6 , ( $+5 ) 
0B41    61B3          6393     	AJMP	CALC_NEW_WAIT_TIMES_FAST
                      6394     
0B43    E8            6395     MOV A , R0 
0B44    FA            6396     MOV R2 , A 
0B45    E9            6397     MOV A , R1 
0B46    FB            6398     MOV R3 , A 
0B47    D3            6399     	SETB	C					; Negative numbers - set carry
0B48    E9            6400     MOV A , R1 
0B49    13            6401     	RRC	A					; Divide by 2
0B4A    FD            6402     MOV R5 , A 
0B4B    E8            6403     MOV A , R0 
0B4C    13            6404     	RRC	A
0B4D    FC            6405     MOV R4 , A 
0B4E    8851          6406     MOV WT_ZC_TOUT_START_L , R0 
0B50    8952          6407     MOV WT_ZC_TOUT_START_H , R1 
0B52    C3            6408     	CLR	C
0B53    EF            6409     MOV A , R7 
0B54    9403          6410     	SUBB	A, #3				; Is timing normal?
0B56    6038          6411     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      6412     
0B58    EF            6413     MOV A , R7 
0B59    20E00D        6414     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      6415     
0B5C    E8            6416     MOV A , R0 
0B5D    2C            6417     ADD A , R4 
0B5E    F8            6418     MOV R0 , A 
0B5F    E9            6419     MOV A , R1 
0B60    3D            6420     ADDC A , R5 
0B61    F9            6421     MOV R1 , A 
0B62    EC            6422     MOV A , R4 
0B63    FA            6423     MOV R2 , A 
0B64    ED            6424     MOV A , R5 
0B65    FB            6425     MOV R3 , A 
0B66    020B7C        6426     	JMP	STORE_TIMES_UP_OR_DOWN
                      6427     
                      6428     ADJUST_TIMING_TWO_STEPS: 
0B69    E8            6429     MOV A , R0 
0B6A    28            6430     ADD A , R0 
0B6B    F8            6431     MOV R0 , A 
0B6C    E9            6432     MOV A , R1 
0B6D    39            6433     ADDC A , R1 
0B6E    F9            6434     MOV R1 , A 
0B6F    C3            6435     	CLR	C
0B70    E8            6436     MOV A , R0 
0B71    2402          6437     	ADD	A, #(COMM_TIME_MIN SHL 1)
0B73    F8            6438     MOV R0 , A 
0B74    E9            6439     MOV A , R1 
0B75    3400          6440     	ADDC	A, #0
0B77    F9            6441     MOV R1 , A 
0B78    7AFE          6442     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
0B7A    7BFF          6443     MOV R3 , # 0FFH 
                      6444     
                      6445     STORE_TIMES_UP_OR_DOWN: 
0B7C    C3            6446     	CLR	C
0B7D    EF            6447     MOV A , R7 
0B7E    9403          6448     	SUBB	A, #3					; Is timing higher than normal?
0B80    400E          6449     	JC	STORE_TIMES_DECREASE		; No - branch
                      6450     
                      6451     STORE_TIMES_INCREASE: 
0B82    8A53          6452     MOV WT_COMM_START_L , R2 
0B84    8B54          6453     MOV WT_COMM_START_H , R3 
0B86    884D          6454     MOV WT_ADV_START_L , R0 
0B88    894E          6455     MOV WT_ADV_START_H , R1 
0B8A    8C4F          6456     MOV WT_ZC_SCAN_START_L , R4 
0B8C    8D50          6457     MOV WT_ZC_SCAN_START_H , R5 
0B8E    61E7          6458     	AJMP	WAIT_BEFORE_ZC_SCAN
                      6459     
                      6460     STORE_TIMES_DECREASE: 
0B90    8853          6461     MOV WT_COMM_START_L , R0 
0B92    8954          6462     MOV WT_COMM_START_H , R1 
0B94    8A4D          6463     MOV WT_ADV_START_L , R2 
0B96    8B4E          6464     MOV WT_ADV_START_H , R3 
0B98    8C4F          6465     MOV WT_ZC_SCAN_START_L , R4 
0B9A    8D50          6466     MOV WT_ZC_SCAN_START_H , R5 
0B9C    306912        6467     JNB FLAGS1 . 1 , STORE_TIMES_EXIT 
                      6468     
0B9F    7553F0        6469     	MOV	WT_COMM_START_L, #0F0H		; Set very short delays for all but advance time during startup, in order to widen zero cross capture range
0BA2    7554FF        6470     	MOV	WT_COMM_START_H, #0FFH
0BA5    754FF0        6471     	MOV	WT_ZC_SCAN_START_L, #0F0H
0BA8    7550FF        6472     	MOV	WT_ZC_SCAN_START_H, #0FFH
0BAB    7551F0        6473     	MOV	WT_ZC_TOUT_START_L, #0F0H
0BAE    7552FF        6474     	MOV	WT_ZC_TOUT_START_H, #0FFH
                      6475     
                      6476     STORE_TIMES_EXIT: 
0BB1    61E7          6477     	AJMP	WAIT_BEFORE_ZC_SCAN
                      6478     
                      6479     
                      6480     CALC_NEW_WAIT_TIMES_FAST: 	
0BB3    E8            6481     MOV A , R0 
0BB4    FA            6482     MOV R2 , A 
0BB5    D3            6483     	SETB	C					; Negative numbers - set carry
0BB6    E8            6484     MOV A , R0 
0BB7    13            6485     	RRC	A
0BB8    FC            6486     MOV R4 , A 
0BB9    8851          6487     MOV WT_ZC_TOUT_START_L , R0 
0BBB    C3            6488     	CLR	C
0BBC    EF            6489     MOV A , R7 
0BBD    9403          6490     	SUBB	A, #3				; Is timing normal?
0BBF    6020          6491     	JZ	STORE_TIMES_DECREASE_FAST; Yes - branch
                      6492     
0BC1    EF            6493     MOV A , R7 
0BC2    20E007        6494     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS_FAST	; If an odd number - branch
                      6495     
0BC5    E8            6496     MOV A , R0 
0BC6    2C            6497     ADD A , R4 
0BC7    F8            6498     MOV R0 , A 
0BC8    EC            6499     MOV A , R4 
0BC9    FA            6500     MOV R2 , A 
0BCA    61D3          6501     	AJMP	STORE_TIMES_UP_OR_DOWN_FAST
                      6502     
                      6503     ADJUST_TIMING_TWO_STEPS_FAST: 
0BCC    E8            6504     MOV A , R0 
0BCD    28            6505     ADD A , R0 
0BCE    2402          6506     	ADD	A, #(COMM_TIME_MIN SHL 1)
0BD0    F8            6507     MOV R0 , A 
0BD1    7AFE          6508     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
                      6509     
                      6510     STORE_TIMES_UP_OR_DOWN_FAST: 
0BD3    C3            6511     	CLR	C
0BD4    EF            6512     MOV A , R7 
0BD5    9403          6513     	SUBB	A, #3				; Is timing higher than normal?
0BD7    4008          6514     	JC	STORE_TIMES_DECREASE_FAST; No - branch
                      6515     
                      6516     STORE_TIMES_INCREASE_FAST: 
0BD9    8A53          6517     MOV WT_COMM_START_L , R2 
0BDB    884D          6518     MOV WT_ADV_START_L , R0 
0BDD    8C4F          6519     MOV WT_ZC_SCAN_START_L , R4 
0BDF    61E7          6520     	AJMP	WAIT_BEFORE_ZC_SCAN
                      6521     
                      6522     STORE_TIMES_DECREASE_FAST: 
0BE1    8853          6523     MOV WT_COMM_START_L , R0 
0BE3    8A4D          6524     MOV WT_ADV_START_L , R2 
0BE5    8C4F          6525     MOV WT_ZC_SCAN_START_L , R4 
                      6526     
                      6527     
                      6528     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6529     ;
                      6530     ; Wait before zero cross scan routine
                      6531     ;
                      6532     ; No assumptions
                      6533     ;
                      6534     ; Waits for the zero cross scan wait time to elapse
                      6535     ; Also sets up timer 3 for the zero cross scan timeout time
                      6536     ;
                      6537     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6538     WAIT_BEFORE_ZC_SCAN: 	
                      6539     	; Calculate random number
0BE7    E568          6540     	MOV	A, RANDOM
0BE9    C3            6541     	CLR	C
0BEA    33            6542     	RLC	A
0BEB    5002          6543     	JNC	WAIT_BEFORE_ZC_SCAN_RAND
                      6544     
0BED    646B          6545     	XRL	A, #06BH		; Sequence length of 35, when initialized to 1
                      6546     
                      6547     WAIT_BEFORE_ZC_SCAN_RAND:           
0BEF    F568          6548     	MOV	RANDOM, A
                      6549     
                      6550     WAIT_BEFORE_ZC_SCAN_WAIT:           
0BF1    306002        6551     JNB FLAGS0 . 0 , ( $+5 ) 
0BF4    61F1          6552     	AJMP	WAIT_BEFORE_ZC_SCAN_WAIT
                      6553     
0BF6    753402        6554     	MOV	STARTUP_ZC_TIMEOUT_CNTD, #2
                      6555     SETUP_ZC_SCAN_TIMEOUT: 
0BF9    D260          6556     SETB FLAGS0 . 0 
0BFB    43E680        6557     	ORL	EIE1, #80H			; Enable timer3 interrupts
0BFE    E52D          6558     	MOV	A, FLAGS1
0C00    5406          6559     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0C02    602D          6560     	JZ	WAIT_BEFORE_ZC_SCAN_EXIT		
                      6561     
0C04    A840          6562     MOV R0 , COMM_PERIOD4X_L 
0C06    A941          6563     MOV R1 , COMM_PERIOD4X_H 
0C08    C3            6564     	CLR	C
0C09    E9            6565     MOV A , R1 
0C0A    13            6566     	RRC	A
0C0B    F9            6567     MOV R1 , A 
0C0C    E8            6568     MOV A , R0 
0C0D    13            6569     	RRC	A
0C0E    F8            6570     MOV R0 , A 
                      6571     IF MCU_48MHZ == 0
                               	CLR	C
                               	MOV	A, TEMP2
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	RRC	A
                               	MOV	TEMP1, A
                               ENDIF
0C0F    306904        6580     JNB FLAGS1 . 1 , SETUP_ZC_SCAN_TIMEOUT_STARTUP_DONE 
                      6581     	
0C12    E9            6582     MOV A , R1 
0C13    2440          6583     	ADD	A, #40H				; Increase timeout somewhat to avoid false wind up
0C15    F9            6584     MOV R1 , A 
                      6585     
                      6586     SETUP_ZC_SCAN_TIMEOUT_STARTUP_DONE: 
0C16    C2AF          6587     	CLR	EA
0C18    53E67F        6588     	ANL	EIE1, #7FH			; Disable timer3 interrupts
0C1B    759100        6589     	MOV	TMR3CN, #00H			; Timer3 disabled and interrupt flag cleared
0C1E    C3            6590     	CLR	C
0C1F    E4            6591     	CLR	A
0C20    98            6592     SUBB A , R0 
0C21    F594          6593     	MOV	TMR3L, A
0C23    E4            6594     	CLR	A
0C24    99            6595     SUBB A , R1 
0C25    F595          6596     	MOV	TMR3H, A
0C27    759104        6597     	MOV	TMR3CN, #04H			; Timer3 enabled and interrupt flag cleared
0C2A    D260          6598     SETB FLAGS0 . 0 
0C2C    43E680        6599     	ORL	EIE1, #80H			; Enable timer3 interrupts
0C2F    D2AF          6600     	SETB	EA
                      6601     
                      6602     WAIT_BEFORE_ZC_SCAN_EXIT:           
0C31    22            6603     	RET
                      6604     
                      6605     
                      6606     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6607     ;
                      6608     ; Wait for comparator to go low/high routines
                      6609     ;
                      6610     ; No assumptions
                      6611     ;
                      6612     ; Waits for the zero cross scan wait time to elapse
                      6613     ; Then scans for comparator going low/high
                      6614     ;
                      6615     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6616     WAIT_FOR_COMP_OUT_LOW: 
0C32    D264          6617     SETB FLAGS0 . 4 
0C34    754300        6618     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0C37    752000        6619     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0C3A    306C03        6620     JNB FLAGS1 . 4 , ( $+6 ) 
0C3D    752040        6621     	MOV	BIT_ACCESS, #40H		
0C40    020C51        6622     	JMP	WAIT_FOR_COMP_OUT_START
                      6623     
                      6624     WAIT_FOR_COMP_OUT_HIGH: 
0C43    D264          6625     SETB FLAGS0 . 4 
0C45    754300        6626     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0C48    752040        6627     	MOV	BIT_ACCESS, #40H			; Desired comparator output
0C4B    306C03        6628     JNB FLAGS1 . 4 , ( $+6 ) 
0C4E    752000        6629     	MOV	BIT_ACCESS, #00H		
                      6630     
                      6631     WAIT_FOR_COMP_OUT_START: 
                      6632     	; Set number of comparator readings
0C51    7801          6633     MOV R0 , # 1 
0C53    7901          6634     MOV R1 , # 1 
0C55    206620        6635     JB FLAGS0 . 6 , COMP_SCALE_SAMPLES 
                      6636     
0C58    E52D          6637     	MOV	A, FLAGS1					; Clear demag detected flag if start phases
0C5A    5406          6638     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0C5C    6002          6639     	JZ	($+4)
                      6640     		
0C5E    C264          6641     CLR FLAGS0 . 4 
                      6642     
0C60    7914          6643     MOV R1 , # 20 
0C62    E541          6644     	MOV 	A, COMM_PERIOD4X_H			; Set number of readings higher for lower speeds	
0C64    C3            6645     	CLR	C
0C65    13            6646     	RRC	A
0C66    7001          6647     	JNZ	($+3)
0C68    04            6648     	INC	A
0C69    F8            6649     MOV R0 , A 
0C6A    C3            6650     	CLR	C						
0C6B    9414          6651     	SUBB	A, #20			
0C6D    4002          6652     	JC	($+4)
                      6653     
0C6F    7814          6654     MOV R0 , # 20 
                      6655     	
0C71    306904        6656     JNB FLAGS1 . 1 , COMP_SCALE_SAMPLES 
                      6657     
0C74    781B          6658     MOV R0 , # 27 
0C76    791B          6659     MOV R1 , # 27 
                      6660     
                      6661     COMP_SCALE_SAMPLES: 
                      6662     IF MCU_48MHZ == 1
0C78    C3            6663     	CLR	C
0C79    E8            6664     MOV A , R0 
0C7A    33            6665     	RLC	A
0C7B    F8            6666     MOV R0 , A 
0C7C    C3            6667     	CLR	C
0C7D    E9            6668     MOV A , R1 
0C7E    33            6669     	RLC	A
0C7F    F9            6670     MOV R1 , A 
                      6671     ENDIF
                      6672     
                      6673     COMP_CHECK_TIMEOUT: 
0C80    206010        6674     JB FLAGS0 . 0 , COMP_CHECK_TIMEOUT_NOT_TIMED_OUT 
                      6675     
0C83    E543          6676     	MOV	A, COMPARATOR_READ_CNT				; Check that comparator has been read
0C85    600C          6677     	JZ	COMP_CHECK_TIMEOUT_NOT_TIMED_OUT		; If not read - branch
                      6678     
0C87    306903        6679     JNB FLAGS1 . 1 , COMP_CHECK_TIMEOUT_TIMEOUT_EXTENDED 
                      6680     
0C8A    D53404        6681     	DJNZ	STARTUP_ZC_TIMEOUT_CNTD, COMP_CHECK_TIMEOUT_EXTEND_TIMEOUT
                      6682     
                      6683     COMP_CHECK_TIMEOUT_TIMEOUT_EXTENDED: 
0C8D    D26D          6684     SETB FLAGS1 . 5 
0C8F    A107          6685     	AJMP	SETUP_COMM_WAIT
                      6686     
                      6687     COMP_CHECK_TIMEOUT_EXTEND_TIMEOUT: 
0C91    71F9          6688     	CALL	SETUP_ZC_SCAN_TIMEOUT
                      6689     COMP_CHECK_TIMEOUT_NOT_TIMED_OUT: 
0C93    0543          6690     	INC	COMPARATOR_READ_CNT			; Increment comparator read count
                      6691     	READ_COMP_OUT					; Read comparator output
0C95    E59B          6691+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0C97    5440          6692     	ANL	A, #40H
0C99    B52002        6693     	CJNE	A, BIT_ACCESS, COMP_READ_WRONG
0C9C    81F1          6694     	AJMP	COMP_READ_OK
                      6695     	
                      6696     COMP_READ_WRONG: 
0C9E    306909        6697     JNB FLAGS1 . 1 , COMP_READ_WRONG_NOT_STARTUP 
                      6698     
0CA1    08            6699     INC R0 
0CA2    C3            6700     	CLR	C
0CA3    E8            6701     MOV A , R0 
0CA4    99            6702     SUBB A , R1 
0CA5    4001          6703     	JC	($+3)
0CA7    18            6704     DEC R0 
                      6705     
0CA8    8180          6706     	AJMP	COMP_CHECK_TIMEOUT			; Continue to look for good ones
                      6707     
                      6708     COMP_READ_WRONG_NOT_STARTUP: 
0CAA    20640A        6709     JB FLAGS0 . 4 , COMP_READ_WRONG_EXTEND_TIMEOUT 
                      6710     
0CAD    08            6711     INC R0 
0CAE    C3            6712     	CLR	C
0CAF    E8            6713     MOV A , R0 
0CB0    99            6714     SUBB A , R1 
0CB1    4002          6715     	JC	($+4)
0CB3    8151          6716     	AJMP	WAIT_FOR_COMP_OUT_START		; If above initial requirement - go back and restart
                      6717     
0CB5    8180          6718     	AJMP	COMP_CHECK_TIMEOUT			; Otherwise - take another reading
                      6719     
                      6720     COMP_READ_WRONG_EXTEND_TIMEOUT: 
0CB7    C264          6721     CLR FLAGS0 . 4 
0CB9    C2AF          6722     	CLR	EA
0CBB    53E67F        6723     	ANL	EIE1, #7FH				; Disable timer3 interrupts
0CBE    759100        6724     	MOV	TMR3CN, #00H				; Timer3 disabled and interrupt flag cleared
0CC1    306612        6725     JNB FLAGS0 . 6 , COMP_READ_WRONG_LOW_RPM 
                      6726     
0CC4    759400        6727     	MOV	TMR3L, #00H				; Set timeout to ~1ms
                      6728     IF MCU_48MHZ == 1
0CC7    7595F0        6729     	MOV	TMR3H, #0F0H
                      6730     ELSE
                               	MOV	TMR3H, #0F8H
                               ENDIF
                      6733     COMP_READ_WRONG_TIMEOUT_SET: 
0CCA    759104        6734     	MOV	TMR3CN, #04H				; Timer3 enabled and interrupt flag cleared
0CCD    D260          6735     SETB FLAGS0 . 0 
0CCF    43E680        6736     	ORL	EIE1, #80H				; Enable timer3 interrupts
0CD2    D2AF          6737     	SETB	EA
0CD4    8151          6738     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      6739     
                      6740     COMP_READ_WRONG_LOW_RPM: 
0CD6    E541          6741     	MOV	A, COMM_PERIOD4X_H			; Set timeout to ~4x comm period 4x value
0CD8    7EFF          6742     MOV R6 , # 0FFH 
                      6743     IF MCU_48MHZ == 1
0CDA    C3            6744     	CLR	C
0CDB    33            6745     	RLC	A
0CDC    4009          6746     	JC	COMP_READ_WRONG_LOAD_TIMEOUT
                      6747     
                      6748     ENDIF
0CDE    C3            6749     	CLR	C
0CDF    33            6750     	RLC	A
0CE0    4005          6751     	JC	COMP_READ_WRONG_LOAD_TIMEOUT
                      6752     
0CE2    C3            6753     	CLR	C
0CE3    33            6754     	RLC	A
0CE4    4001          6755     	JC	COMP_READ_WRONG_LOAD_TIMEOUT
                      6756     
0CE6    FE            6757     MOV R6 , A 
                      6758     
                      6759     COMP_READ_WRONG_LOAD_TIMEOUT: 
0CE7    C3            6760     	CLR	C
0CE8    E4            6761     	CLR	A
0CE9    9E            6762     SUBB A , R6 
0CEA    759400        6763     	MOV	TMR3L, #0
0CED    F595          6764     	MOV	TMR3H, A
0CEF    81CA          6765     	AJMP	COMP_READ_WRONG_TIMEOUT_SET
                      6766     
                      6767     COMP_READ_OK: 
0CF1    C3            6768     	CLR	C
0CF2    E533          6769     	MOV	A, STARTUP_CNT				; Force a timeout for the first commutation		
0CF4    9401          6770     	SUBB	A, #1
0CF6    5002          6771     	JNC	($+4)
0CF8    8151          6772     	AJMP	WAIT_FOR_COMP_OUT_START
                      6773     
0CFA    306402        6774     JNB FLAGS0 . 4 , ( $+5 ) 
0CFD    8151          6775     	AJMP	WAIT_FOR_COMP_OUT_START
                      6776     
0CFF    D802          6777     DJNZ R0 , COMP_READ_OK_JMP 
0D01    A105          6778     	AJMP	($+4)
                      6779     
                      6780     COMP_READ_OK_JMP: 
0D03    8180          6781     	AJMP	COMP_CHECK_TIMEOUT	
                      6782     
0D05    C26D          6783     CLR FLAGS1 . 5 
                      6784     
                      6785     
                      6786     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6787     ;
                      6788     ; Setup commutation timing routine
                      6789     ;
                      6790     ; No assumptions
                      6791     ;
                      6792     ; Sets up and starts wait from commutation to zero cross
                      6793     ;
                      6794     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6795     SETUP_COMM_WAIT:  
0D07    C2AF          6796     	CLR	EA
0D09    53E67F        6797     	ANL	EIE1, #7FH		; Disable timer3 interrupts
0D0C    759100        6798     	MOV	TMR3CN, #00H		; Timer3 disabled and interrupt flag cleared
0D0F    855394        6799     	MOV	TMR3L, WT_COMM_START_L
0D12    855495        6800     	MOV	TMR3H, WT_COMM_START_H
0D15    759104        6801     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
                      6802     	; Setup next wait time
0D18    854D92        6803     	MOV	TMR3RLL, WT_ADV_START_L
0D1B    854E93        6804     	MOV	TMR3RLH, WT_ADV_START_H
0D1E    D260          6805     SETB FLAGS0 . 0 
0D20    43E680        6806     	ORL	EIE1, #80H		; Enable timer3 interrupts
0D23    D2AF          6807     	SETB	EA				; Enable interrupts again
                      6808     
                      6809     
                      6810     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6811     ;
                      6812     ; Evaluate comparator integrity
                      6813     ;
                      6814     ; No assumptions
                      6815     ;
                      6816     ; Checks comparator signal behaviour versus expected behaviour
                      6817     ;
                      6818     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6819     EVALUATE_COMPARATOR_INTEGRITY: 
0D25    E52D          6820     	MOV	A, FLAGS1
0D27    5406          6821     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0D29    6008          6822     	JZ	EVAL_COMP_CHECK_TIMEOUT
                      6823     
0D2B    206A02        6824     JB FLAGS1 . 2 , ( $+5 ) 
0D2E    0533          6825     	INC	STARTUP_CNT					; Increment counter
0D30    020D43        6826     	JMP	EVAL_COMP_EXIT
                      6827     
                      6828     EVAL_COMP_CHECK_TIMEOUT: 
0D33    306D0D        6829     JNB FLAGS1 . 5 , EVAL_COMP_EXIT 
0D36    206C0A        6830     JB FLAGS1 . 4 , EVAL_COMP_EXIT 
0D39    206407        6831     JB FLAGS0 . 4 , EVAL_COMP_EXIT 
0D3C    1581          6832     	DEC	SP								; Routine exit without "ret" command
0D3E    1581          6833     	DEC	SP
0D40    021683        6834     	LJMP	RUN_TO_WAIT_FOR_POWER_ON_FAIL			; Yes - exit run mode
                      6835     
                      6836     EVAL_COMP_EXIT: 
0D43    22            6837     	RET
                      6838     
                      6839     
                      6840     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6841     ;
                      6842     ; Wait for commutation routine
                      6843     ;
                      6844     ; No assumptions
                      6845     ;
                      6846     ; Waits from zero cross to commutation 
                      6847     ;
                      6848     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6849     WAIT_FOR_COMM:  
                      6850     	; Update demag metric
0D44    7800          6851     MOV R0 , # 0 
0D46    306402        6852     JNB FLAGS0 . 4 , ( $+5 ) 
                      6853     
0D49    7801          6854     MOV R0 , # 1 
                      6855     
0D4B    E537          6856     	MOV	A, DEMAG_DETECTED_METRIC	; Sliding average of 8, 256 when demag and 0 when not. Limited to minimum 120
0D4D    75F007        6857     	MOV	B, #7
0D50    A4            6858     	MUL	AB					; Multiply by 7
0D51    F9            6859     MOV R1 , A 
0D52    E5F0          6860     	MOV	A, B					; Add new value for current demag status
0D54    28            6861     ADD A , R0 
0D55    F5F0          6862     	MOV	B, A
0D57    E9            6863     MOV A , R1 
0D58    A2F0          6864     	MOV	C, B.0				; Divide by 8
0D5A    13            6865     	RRC	A					
0D5B    A2F1          6866     	MOV	C, B.1
0D5D    13            6867     	RRC	A
0D5E    A2F2          6868     	MOV	C, B.2
0D60    13            6869     	RRC	A
0D61    F537          6870     	MOV	DEMAG_DETECTED_METRIC, A
0D63    C3            6871     	CLR	C
0D64    9478          6872     	SUBB	A, #120				; Limit to minimum 120
0D66    5003          6873     	JNC	($+5)
                      6874     
0D68    753778        6875     	MOV	DEMAG_DETECTED_METRIC, #120
                      6876     
0D6B    C3            6877     	CLR	C
0D6C    E537          6878     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0D6E    9538          6879     	SUBB	A, DEMAG_PWR_OFF_THRESH
0D70    4008          6880     	JC	WAIT_FOR_COMM_WAIT		; Cut power if many consecutive demags. This will help retain sync during hard accelerations
                      6881     
0D72    D265          6882     SETB FLAGS0 . 5 
                      6883     IF NFETON_DELAY NE 0
                      6884     	ALL_NFETS_OFF
0D74    C295          6884+1   CLR P1 . 5 
0D76    C293          6884+1   CLR P1 . 3 
0D78    C297          6884+1   CLR P1 . 7 
                      6885     ELSE
                               	EN_OFF					; For EN/PWM style drivers
                               ENDIF
                      6888     
                      6889     WAIT_FOR_COMM_WAIT: 
0D7A    306002        6890     JNB FLAGS0 . 0 , ( $+5 ) 
0D7D    A17A          6891     	AJMP	WAIT_FOR_COMM_WAIT					
                      6892     
                      6893     	; Setup next wait time
0D7F    854F92        6894     	MOV	TMR3RLL, WT_ZC_SCAN_START_L
0D82    855093        6895     	MOV	TMR3RLH, WT_ZC_SCAN_START_H
0D85    D260          6896     SETB FLAGS0 . 0 
0D87    43E680        6897     	ORL	EIE1, #80H			; Enable timer3 interrupts
0D8A    22            6898     	RET
                      6899     
                      6900     
                      6901     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6902     ;
                      6903     ; Commutation routines
                      6904     ;
                      6905     ; No assumptions
                      6906     ;
                      6907     ; Performs commutation switching 
                      6908     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      6909     ;
                      6910     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6911     ; Comm phase 1 to comm phase 2
                      6912     COMM1COMM2: 	
                      6913     	SET_RPM_OUT
0D8B    207D16        6914     JB FLAGS3 . 5 , COMM12_REV 
                      6915     
0D8E    C2AF          6916     	CLR 	EA					; Disable all interrupts
0D90    754202        6917     	MOV	COMM_PHASE, #2
                      6918     	BPFET_OFF 				; Turn off pfet
0D93    C296          6918+1   CLR P1 . 6 
                      6919     	APFET_ON					; Turn on pfet
0D95    D294          6919+1   SETB P1 . 4 
0D97    306202        6920     JNB FLAGS0 . 2 , COMM12_NFET_DONE 
                      6921     	CNFET_ON					; Pwm on - turn on nfet
0D9A    D293          6921+1   SETB P1 . 3 
                      6922     COMM12_NFET_DONE: 
0D9C    D2AF          6923     	SETB	EA
                      6924     	SET_COMP_PHASE_B 			; Set comparator phase
0D9E    759F11        6924+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0DA1    020F7A        6925     	JMP	COMM_EXIT
                      6926     
                      6927     COMM12_REV: 	
0DA4    C2AF          6928     	CLR 	EA					; Disable all interrupts
0DA6    754202        6929     	MOV	COMM_PHASE, #2
                      6930     	BPFET_OFF 				; Turn off pfet
0DA9    C296          6930+1   CLR P1 . 6 
                      6931     	CPFET_ON					; Turn on pfet (reverse)
0DAB    D292          6931+1   SETB P1 . 2 
0DAD    306202        6932     JNB FLAGS0 . 2 , COMM12_NFET_DONE_REV 
                      6933     	ANFET_ON					; Pwm on - turn on nfet
0DB0    D295          6933+1   SETB P1 . 5 
                      6934     COMM12_NFET_DONE_REV: 
0DB2    D2AF          6935     	SETB	EA
                      6936     	SET_COMP_PHASE_B 			; Set comparator phase
0DB4    759F11        6936+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0DB7    020F7A        6937     	JMP	COMM_EXIT
                      6938     
                      6939     
                      6940     ; Comm phase 2 to comm phase 3
                      6941     COMM2COMM3: 	
                      6942     	CLEAR_RPM_OUT
0DBA    307243        6943     JNB FLAGS2 . 2 , COMM23_NONDAMP 
                      6944     
                      6945     	; Comm2Comm3 Damped
0DBD    207D20        6946     JB FLAGS3 . 5 , COMM23_DAMP_REV 
                      6947     
0DC0    C2AF          6948     	CLR 	EA					; Disable all interrupts
0DC2    754203        6949     	MOV	COMM_PHASE, #3
0DC5    900165        6950     	MOV	DPTR, #PWM_BFET_DAMPED	
0DC8    757B40        6951     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6952     	CNFET_OFF					; Turn off fets
0DCB    C293          6952+1   CLR P1 . 3 
                      6953     	CPFET_OFF						
0DCD    C292          6953+1   CLR P1 . 2 
0DCF    306204        6954     JNB FLAGS0 . 2 , COMM23_NFET_OFF 
                      6955     	BNFET_ON					; Pwm on - turn on nfet
0DD2    D297          6955+1   SETB P1 . 7 
0DD4    A1D8          6956     	AJMP	COMM23_FETS_DONE
                      6957     COMM23_NFET_OFF: 
                      6958     	BPFET_ON					; Pwm off - switch damping fets	
0DD6    D296          6958+1   SETB P1 . 6 
                      6959     COMM23_FETS_DONE: 
0DD8    D2AF          6960     	SETB	EA
                      6961     	SET_COMP_PHASE_C 			; Set comparator phase
0DDA    759F13        6961+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0DDD    020F7A        6962     	LJMP	COMM_EXIT
                      6963     
                      6964     	; Comm2Comm3 Damped reverse
                      6965     COMM23_DAMP_REV: 
0DE0    C2AF          6966     	CLR 	EA					; Disable all interrupts
0DE2    754203        6967     	MOV	COMM_PHASE, #3
0DE5    900165        6968     	MOV	DPTR, #PWM_BFET_DAMPED	
0DE8    757B40        6969     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6970     	ANFET_OFF					; Turn off fets (reverse)
0DEB    C295          6970+1   CLR P1 . 5 
                      6971     	APFET_OFF						
0DED    C294          6971+1   CLR P1 . 4 
0DEF    306204        6972     JNB FLAGS0 . 2 , COMM23_NFET_OFF_REV 
                      6973     	BNFET_ON					; Pwm on - turn on nfet
0DF2    D297          6973+1   SETB P1 . 7 
0DF4    A1F8          6974     	AJMP	COMM23_FETS_DONE_REV
                      6975     COMM23_NFET_OFF_REV: 
                      6976     	BPFET_ON					; Pwm off - switch damping fets	
0DF6    D296          6976+1   SETB P1 . 6 
                      6977     COMM23_FETS_DONE_REV: 
0DF8    D2AF          6978     	SETB	EA
                      6979     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0DFA    759F10        6979+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0DFD    020F7A        6980     	LJMP	COMM_EXIT
                      6981     
                      6982     	; Comm2Comm3 Non-damped
                      6983     COMM23_NONDAMP: 
0E00    207D17        6984     JB FLAGS3 . 5 , COMM23_NONDAMP_REV 
                      6985     
0E03    C2AF          6986     	CLR 	EA					; Disable all interrupts
0E05    754203        6987     	MOV	COMM_PHASE, #3
0E08    900140        6988     	MOV	DPTR, #PWM_BFET	
                      6989     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL BPFET)
                               ENDIF
                      6992     	CNFET_OFF					; Turn off nfet
0E0B    C293          6992+1   CLR P1 . 3 
0E0D    306202        6993     JNB FLAGS0 . 2 , COMM23_NFET_DONE 
                      6994     	BNFET_ON					; Yes - turn on nfet
0E10    D297          6994+1   SETB P1 . 7 
                      6995     COMM23_NFET_DONE: 
0E12    D2AF          6996     	SETB	EA
                      6997     	SET_COMP_PHASE_C 			; Set comparator phase
0E14    759F13        6997+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0E17    020F7A        6998     	LJMP	COMM_EXIT
                      6999     
                      7000     	; Comm2Comm3 Non-damped reverse
                      7001     COMM23_NONDAMP_REV: 
0E1A    C2AF          7002     	CLR 	EA					; Disable all interrupts
0E1C    754203        7003     	MOV	COMM_PHASE, #3
0E1F    900140        7004     	MOV	DPTR, #PWM_BFET	
                      7005     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL BPFET)
                               ENDIF
                      7008     	ANFET_OFF					; Turn off nfet (reverse)
0E22    C295          7008+1   CLR P1 . 5 
0E24    306202        7009     JNB FLAGS0 . 2 , COMM23_NFET_DONE_REV 
                      7010     	BNFET_ON					; Yes - turn on nfet
0E27    D297          7010+1   SETB P1 . 7 
                      7011     COMM23_NFET_DONE_REV: 
0E29    D2AF          7012     	SETB	EA
                      7013     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0E2B    759F10        7013+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0E2E    020F7A        7014     	LJMP	COMM_EXIT
                      7015     
                      7016     
                      7017     ; Comm phase 3 to comm phase 4
                      7018     COMM3COMM4: 	
                      7019     	SET_RPM_OUT
0E31    207D16        7020     JB FLAGS3 . 5 , COMM34_REV 
                      7021     
0E34    C2AF          7022     	CLR 	EA					; Disable all interrupts
0E36    754204        7023     	MOV	COMM_PHASE, #4
                      7024     	APFET_OFF 				; Turn off pfet
0E39    C294          7024+1   CLR P1 . 4 
                      7025     	CPFET_ON					; Turn on pfet
0E3B    D292          7025+1   SETB P1 . 2 
0E3D    306202        7026     JNB FLAGS0 . 2 , COMM34_NFET_DONE 
                      7027     	BNFET_ON					; Pwm on - turn on nfet
0E40    D297          7027+1   SETB P1 . 7 
                      7028     COMM34_NFET_DONE: 
0E42    D2AF          7029     	SETB	EA
                      7030     	SET_COMP_PHASE_A 			; Set comparator phase
0E44    759F10        7030+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0E47    020F7A        7031     	JMP	COMM_EXIT
                      7032     
                      7033     COMM34_REV: 	
0E4A    C2AF          7034     	CLR 	EA					; Disable all interrupts
0E4C    754204        7035     	MOV	COMM_PHASE, #4
                      7036     	CPFET_OFF 				; Turn off pfet (reverse)
0E4F    C292          7036+1   CLR P1 . 2 
                      7037     	APFET_ON					; Turn on pfet (reverse)
0E51    D294          7037+1   SETB P1 . 4 
0E53    306202        7038     JNB FLAGS0 . 2 , COMM34_NFET_DONE_REV 
                      7039     	BNFET_ON					; Pwm on - turn on nfet
0E56    D297          7039+1   SETB P1 . 7 
                      7040     COMM34_NFET_DONE_REV: 
0E58    D2AF          7041     	SETB	EA
                      7042     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0E5A    759F13        7042+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0E5D    020F7A        7043     	JMP	COMM_EXIT
                      7044     
                      7045     
                      7046     ; Comm phase 4 to comm phase 5
                      7047     COMM4COMM5: 	
                      7048     	CLEAR_RPM_OUT
0E60    307243        7049     JNB FLAGS2 . 2 , COMM45_NONDAMP 
                      7050     
                      7051     	; Comm4Comm5 Damped
0E63    207D20        7052     JB FLAGS3 . 5 , COMM45_DAMP_REV 
                      7053     
0E66    C2AF          7054     	CLR 	EA					; Disable all interrupts
0E68    754205        7055     	MOV	COMM_PHASE, #5
0E6B    900154        7056     	MOV	DPTR, #PWM_AFET_DAMPED	
0E6E    757B10        7057     	MOV	DAMPINGFET, #(1 SHL APFET)
                      7058     	BNFET_OFF					; Turn off fets
0E71    C297          7058+1   CLR P1 . 7 
                      7059     	BPFET_OFF						
0E73    C296          7059+1   CLR P1 . 6 
0E75    306204        7060     JNB FLAGS0 . 2 , COMM45_NFET_OFF 
                      7061     	ANFET_ON					; Pwm on - turn on nfet
0E78    D295          7061+1   SETB P1 . 5 
0E7A    C17E          7062     	AJMP	COMM45_FETS_DONE
                      7063     COMM45_NFET_OFF: 
                      7064     	APFET_ON					; Pwm off - switch damping fets	
0E7C    D294          7064+1   SETB P1 . 4 
                      7065     COMM45_FETS_DONE: 
0E7E    D2AF          7066     	SETB	EA
                      7067     	SET_COMP_PHASE_B 			; Set comparator phase
0E80    759F11        7067+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0E83    020F7A        7068     	LJMP	COMM_EXIT
                      7069     
                      7070     	; Comm4Comm5 Damped reverse
                      7071     COMM45_DAMP_REV: 
0E86    C2AF          7072     	CLR 	EA					; Disable all interrupts
0E88    754205        7073     	MOV	COMM_PHASE, #5
0E8B    900176        7074     	MOV	DPTR, #PWM_CFET_DAMPED	; (reverse)
0E8E    757B04        7075     	MOV	DAMPINGFET, #(1 SHL CPFET)	; (reverse)
                      7076     	BNFET_OFF					; Turn off fets
0E91    C297          7076+1   CLR P1 . 7 
                      7077     	BPFET_OFF						
0E93    C296          7077+1   CLR P1 . 6 
0E95    306204        7078     JNB FLAGS0 . 2 , COMM45_NFET_OFF_REV 
                      7079     	CNFET_ON					; Pwm on - turn on nfet (reverse)
0E98    D293          7079+1   SETB P1 . 3 
0E9A    C19E          7080     	AJMP	COMM45_FETS_DONE_REV
                      7081     COMM45_NFET_OFF_REV: 
                      7082     	CPFET_ON					; Pwm off - switch damping fets (reverse)	
0E9C    D292          7082+1   SETB P1 . 2 
                      7083     COMM45_FETS_DONE_REV: 
0E9E    D2AF          7084     	SETB	EA
                      7085     	SET_COMP_PHASE_B 			; Set comparator phase
0EA0    759F11        7085+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0EA3    020F7A        7086     	LJMP	COMM_EXIT
                      7087     
                      7088     	; Comm4Comm5 Non-damped
                      7089     COMM45_NONDAMP: 
0EA6    207D17        7090     JB FLAGS3 . 5 , COMM45_NONDAMP_REV 
                      7091     
0EA9    C2AF          7092     	CLR 	EA					; Disable all interrupts
0EAB    754205        7093     	MOV	COMM_PHASE, #5
0EAE    900136        7094     	MOV	DPTR, #PWM_AFET	
                      7095     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL APFET)
                               ENDIF
                      7098     	BNFET_OFF					; Turn off nfet
0EB1    C297          7098+1   CLR P1 . 7 
0EB3    306202        7099     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      7100     	ANFET_ON					; Yes - turn on nfet
0EB6    D295          7100+1   SETB P1 . 5 
                      7101     COMM45_NFET_DONE: 
0EB8    D2AF          7102     	SETB	EA
                      7103     	SET_COMP_PHASE_B 			; Set comparator phase
0EBA    759F11        7103+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0EBD    020F7A        7104     	LJMP	COMM_EXIT
                      7105     
                      7106     	; Comm4Comm5 Non-damped reverse
                      7107     COMM45_NONDAMP_REV: 
0EC0    C2AF          7108     	CLR 	EA					; Disable all interrupts
0EC2    754205        7109     	MOV	COMM_PHASE, #5
0EC5    90014A        7110     	MOV	DPTR, #PWM_CFET		;  (reverse)
                      7111     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL CPFET)
                               ENDIF
                      7114     	BNFET_OFF					; Turn off nfet
0EC8    C297          7114+1   CLR P1 . 7 
0ECA    3062EB        7115     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      7116     	CNFET_ON					; Yes - turn on nfet (reverse)
0ECD    D293          7116+1   SETB P1 . 3 
0ECF    D2AF          7117     	SETB	EA
                      7118     	SET_COMP_PHASE_B 			; Set comparator phase
0ED1    759F11        7118+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0ED4    020F7A        7119     	LJMP	COMM_EXIT
                      7120     
                      7121     
                      7122     ; Comm phase 5 to comm phase 6
                      7123     COMM5COMM6: 	
                      7124     	SET_RPM_OUT
0ED7    207D16        7125     JB FLAGS3 . 5 , COMM56_REV 
                      7126     
0EDA    C2AF          7127     	CLR 	EA					; Disable all interrupts
0EDC    754206        7128     	MOV	COMM_PHASE, #6
                      7129     	CPFET_OFF 				; Turn off pfet
0EDF    C292          7129+1   CLR P1 . 2 
                      7130     	BPFET_ON					; Turn on pfet
0EE1    D296          7130+1   SETB P1 . 6 
0EE3    306202        7131     JNB FLAGS0 . 2 , COMM56_NFET_DONE 
                      7132     	ANFET_ON					; Pwm on - turn on nfet
0EE6    D295          7132+1   SETB P1 . 5 
                      7133     COMM56_NFET_DONE: 
0EE8    D2AF          7134     	SETB	EA
                      7135     	SET_COMP_PHASE_C 			; Set comparator phase
0EEA    759F13        7135+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0EED    020F7A        7136     	JMP	COMM_EXIT
                      7137     
                      7138     COMM56_REV: 
0EF0    C2AF          7139     	CLR 	EA					; Disable all interrupts
0EF2    754206        7140     	MOV	COMM_PHASE, #6
                      7141     	APFET_OFF 				; Turn off pfet (reverse)
0EF5    C294          7141+1   CLR P1 . 4 
                      7142     	BPFET_ON					; Turn on pfet
0EF7    D296          7142+1   SETB P1 . 6 
0EF9    306202        7143     JNB FLAGS0 . 2 , COMM56_NFET_DONE_REV 
                      7144     	CNFET_ON					; Pwm on - turn on nfet
0EFC    D293          7144+1   SETB P1 . 3 
                      7145     COMM56_NFET_DONE_REV: 
0EFE    D2AF          7146     	SETB	EA
                      7147     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0F00    759F10        7147+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F03    020F7A        7148     	JMP	COMM_EXIT
                      7149     
                      7150     
                      7151     ; Comm phase 6 to comm phase 1
                      7152     COMM6COMM1: 	
                      7153     	CLEAR_RPM_OUT
0F06    307243        7154     JNB FLAGS2 . 2 , COMM61_NONDAMP 
                      7155     
                      7156     	; Comm6Comm1 Damped
0F09    207D20        7157     JB FLAGS3 . 5 , COMM61_DAMP_REV 
                      7158     
0F0C    C2AF          7159     	CLR 	EA					; Disable all interrupts
0F0E    754201        7160     	MOV	COMM_PHASE, #1
0F11    900176        7161     	MOV	DPTR, #PWM_CFET_DAMPED	
0F14    757B04        7162     	MOV	DAMPINGFET, #(1 SHL CPFET)
                      7163     	ANFET_OFF					; Turn off fets
0F17    C295          7163+1   CLR P1 . 5 
                      7164     	APFET_OFF						
0F19    C294          7164+1   CLR P1 . 4 
0F1B    306204        7165     JNB FLAGS0 . 2 , COMM61_NFET_OFF 
                      7166     	CNFET_ON					; Pwm on - turn on nfet
0F1E    D293          7166+1   SETB P1 . 3 
0F20    E124          7167     	AJMP	COMM61_FETS_DONE
                      7168     COMM61_NFET_OFF: 
                      7169     	CPFET_ON					; Pwm off - switch damping fets	
0F22    D292          7169+1   SETB P1 . 2 
                      7170     COMM61_FETS_DONE: 
0F24    D2AF          7171     	SETB	EA
                      7172     	SET_COMP_PHASE_A 			; Set comparator phase
0F26    759F10        7172+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F29    020F7A        7173     	LJMP	COMM_EXIT
                      7174     
                      7175     	; Comm6Comm1 Damped reverse
                      7176     COMM61_DAMP_REV: 
0F2C    C2AF          7177     	CLR 	EA					; Disable all interrupts
0F2E    754201        7178     	MOV	COMM_PHASE, #1
0F31    900154        7179     	MOV	DPTR, #PWM_AFET_DAMPED	; (reverse)	
0F34    757B10        7180     	MOV	DAMPINGFET, #(1 SHL APFET)	; (reverse)
                      7181     	CNFET_OFF					; Turn off fets (reverse)
0F37    C293          7181+1   CLR P1 . 3 
                      7182     	CPFET_OFF						
0F39    C292          7182+1   CLR P1 . 2 
0F3B    306204        7183     JNB FLAGS0 . 2 , COMM61_NFET_OFF_REV 
                      7184     	ANFET_ON					; Pwm on - turn on nfet
0F3E    D295          7184+1   SETB P1 . 5 
0F40    E144          7185     	AJMP	COMM61_FETS_DONE_REV
                      7186     COMM61_NFET_OFF_REV: 
                      7187     	APFET_ON					; Pwm off - switch damping fets (reverse)	
0F42    D294          7187+1   SETB P1 . 4 
                      7188     COMM61_FETS_DONE_REV: 
0F44    D2AF          7189     	SETB	EA
                      7190     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0F46    759F13        7190+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F49    020F7A        7191     	JMP	COMM_EXIT
                      7192     
                      7193     	; Comm6Comm1 Non-damped
                      7194     COMM61_NONDAMP: 
0F4C    207D17        7195     JB FLAGS3 . 5 , COMM61_NONDAMP_REV 
                      7196     
0F4F    C2AF          7197     	CLR 	EA					; Disable all interrupts
0F51    754201        7198     	MOV	COMM_PHASE, #1
0F54    90014A        7199     	MOV	DPTR, #PWM_CFET	
                      7200     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL CPFET)
                               ENDIF
                      7203     	ANFET_OFF					; Turn off nfet
0F57    C295          7203+1   CLR P1 . 5 
0F59    306202        7204     JNB FLAGS0 . 2 , COMM61_NFET_DONE 
                      7205     	CNFET_ON					; Yes - turn on nfet
0F5C    D293          7205+1   SETB P1 . 3 
                      7206     COMM61_NFET_DONE: 
0F5E    D2AF          7207     	SETB	EA
                      7208     	SET_COMP_PHASE_A 			; Set comparator phase
0F60    759F10        7208+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F63    020F7A        7209     	JMP	COMM_EXIT
                      7210     
                      7211     	; Comm6Comm1 Non-damped reverse
                      7212     COMM61_NONDAMP_REV: 
0F66    C2AF          7213     	CLR 	EA					; Disable all interrupts
0F68    754201        7214     	MOV	COMM_PHASE, #1
0F6B    900136        7215     	MOV	DPTR, #PWM_AFET		; (reverse)
                      7216     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL APFET)
                               ENDIF
                      7219     	CNFET_OFF					; Turn off nfet (reverse)
0F6E    C293          7219+1   CLR P1 . 3 
0F70    306202        7220     JNB FLAGS0 . 2 , COMM61_NFET_DONE_REV 
                      7221     	ANFET_ON					; Yes - turn on nfet (reverse)
0F73    D295          7221+1   SETB P1 . 5 
                      7222     COMM61_NFET_DONE_REV: 
0F75    D2AF          7223     	SETB	EA
                      7224     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0F77    759F13        7224+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
                      7225     
                      7226     COMM_EXIT: 
0F7A    C265          7227     CLR FLAGS0 . 5 
0F7C    22            7228     	RET
                      7229     
                      7230     
                      7231     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7232     ;
                      7233     ; Switch power off routine
                      7234     ;
                      7235     ; No assumptions
                      7236     ;
                      7237     ; Switches all fets off 
                      7238     ;
                      7239     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7240     SWITCH_POWER_OFF: 
0F7D    900134        7241     	MOV	DPTR, #PWM_NOFET	; Set DPTR register to pwm_nofet		
0F80    757B00        7242     	MOV	DAMPINGFET, #0
                      7243     	ALL_NFETS_OFF			; Turn off all nfets
0F83    C295          7243+1   CLR P1 . 5 
0F85    C293          7243+1   CLR P1 . 3 
0F87    C297          7243+1   CLR P1 . 7 
                      7244     	ALL_PFETS_OFF			; Turn off all pfets
0F89    C294          7244+1   CLR P1 . 4 
0F8B    C292          7244+1   CLR P1 . 2 
0F8D    C296          7244+1   CLR P1 . 6 
0F8F    C262          7245     CLR FLAGS0 . 2 
0F91    22            7246     	RET			
                      7247     
                      7248     
                      7249     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7250     ;
                      7251     ; Set default parameters
                      7252     ;
                      7253     ; No assumptions
                      7254     ;
                      7255     ; Sets default programming parameters
                      7256     ;
                      7257     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7258     SET_DEFAULT_PARAMETERS: 
                      7259     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_SPOOLUP_TIME
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Pwm dither
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BRAKE_ON_STOP
                               ENDIF
                      7332     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_DITHER
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BRAKE_ON_STOP
                               ENDIF
                      7405     IF MODE == 2	; Multi
0F92    7880          7406     MOV R0 , # PGM_GOV_P_GAIN 
0F94    7609          7407     MOV @ R0 , # 9 
0F96    08            7408     INC R0 
0F97    7609          7409     MOV @ R0 , # 9 
0F99    08            7410     INC R0 
0F9A    7604          7411     MOV @ R0 , # 4 
0F9C    08            7412     INC R0 
0F9D    76FF          7413     MOV @ R0 , # 0FFH 
0F9F    08            7414     INC R0 
0FA0    7603          7415     MOV @ R0 , # 3 
0FA2    08            7416     INC R0 
0FA3    76FF          7417     MOV @ R0 , # 0FFH 
0FA5    08            7418     INC R0 
0FA6    760A          7419     MOV @ R0 , # 10 
0FA8    08            7420     INC R0 
0FA9    7603          7421     MOV @ R0 , # 3 
0FAB    08            7422     INC R0 
0FAC    7601          7423     MOV @ R0 , # 1 
0FAE    08            7424     INC R0 
0FAF    7601          7425     MOV @ R0 , # 1 
                      7426     
0FB1    788C          7427     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
0FB3    7601          7428     MOV @ R0 , # 1 
0FB5    08            7429     INC R0 
0FB6    76FF          7430     MOV @ R0 , # 0FFH 
0FB8    08            7431     INC R0 
0FB9    76FF          7432     MOV @ R0 , # 0FFH 
0FBB    08            7433     INC R0 
0FBC    76FF          7434     MOV @ R0 , # 0FFH 
0FBE    08            7435     INC R0 
0FBF    76FF          7436     MOV @ R0 , # 0FFH 
0FC1    08            7437     INC R0 
0FC2    76FF          7438     MOV @ R0 , # 0FFH 
0FC4    08            7439     INC R0 
0FC5    7603          7440     MOV @ R0 , # 3 
0FC7    08            7441     INC R0 
0FC8    76FF          7442     MOV @ R0 , # 0FFH 
0FCA    08            7443     INC R0 
0FCB    76FF          7444     MOV @ R0 , # 0FFH 
0FCD    08            7445     INC R0 
0FCE    76FF          7446     MOV @ R0 , # 0FFH 
0FD0    08            7447     INC R0 
0FD1    760A          7448     MOV @ R0 , # 10 
0FD3    08            7449     INC R0 
0FD4    76F0          7450     MOV @ R0 , # 240 
0FD6    08            7451     INC R0 
0FD7    7650          7452     MOV @ R0 , # 80 
0FD9    08            7453     INC R0 
0FDA    7650          7454     MOV @ R0 , # 80 
0FDC    08            7455     INC R0 
0FDD    7604          7456     MOV @ R0 , # 4 
0FDF    08            7457     INC R0 
0FE0    76FF          7458     MOV @ R0 , # 0FFH 
0FE2    08            7459     INC R0 
0FE3    7603          7460     MOV @ R0 , # 3 
0FE5    08            7461     INC R0 
0FE6    7600          7462     MOV @ R0 , # 0 
0FE8    08            7463     INC R0 
0FE9    767D          7464     MOV @ R0 , # 125 
0FEB    08            7465     INC R0 
0FEC    76FF          7466     MOV @ R0 , # 0FFH 
0FEE    08            7467     INC R0 
0FEF    7601          7468     MOV @ R0 , # 1 
0FF1    08            7469     INC R0 
0FF2    7601          7470     MOV @ R0 , # 1 
0FF4    08            7471     INC R0 
0FF5    7600          7472     MOV @ R0 , # 0 
0FF7    08            7473     INC R0 
0FF8    7603          7474     MOV @ R0 , # 3 
0FFA    08            7475     INC R0 
0FFB    7601          7476     MOV @ R0 , # 1 
                      7477     ENDIF
0FFD    22            7478     	RET
                      7479     
                      7480     
                      7481     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7482     ;
                      7483     ; Decode parameters
                      7484     ;
                      7485     ; No assumptions
                      7486     ;
                      7487     ; Decodes programming parameters
                      7488     ;
                      7489     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7490     DECODE_PARAMETERS: 
                      7491     	; Load programmed pwm frequency
0FFE    7887          7492     MOV R0 , # PGM_PWM_FREQ 
1000    E6            7493     MOV A , @ R0 
1001    FF            7494     MOV R7 , A 
1002    C272          7495     CLR FLAGS2 . 2 
                      7496     IF DAMPED_MODE_ENABLE == 1
1004    BF0302        7497     CJNE R7 , # 3 , ( $+5 ) 
1007    D272          7498     SETB FLAGS2 . 2 
                      7499     ENDIF
                      7500     	; Load programmed direction
1009    7888          7501     MOV R0 , # PGM_DIRECTION 
                      7502     IF MODE >= 1	; Tail or multi
100B    E6            7503     MOV A , @ R0 
100C    C3            7504     	CLR	C
100D    9403          7505     	SUBB	A, #3
100F    6008          7506     	JZ	DECODE_PARAMS_DIR_SET
                      7507     ENDIF
                      7508     
1011    C27D          7509     CLR FLAGS3 . 5 
1013    E6            7510     MOV A , @ R0 
1014    30E102        7511     	JNB	ACC.1, ($+5)
1017    D27D          7512     SETB FLAGS3 . 5 
                      7513     DECODE_PARAMS_DIR_SET: 
1019    C27E          7514     CLR FLAGS3 . 6 
101B    7889          7515     MOV R0 , # PGM_INPUT_POL 
101D    E6            7516     MOV A , @ R0 
101E    30E102        7517     	JNB	ACC.1, ($+5)
1021    D27E          7518     SETB FLAGS3 . 6 
1023    C3            7519     	CLR	C
1024    EF            7520     MOV A , R7 
1025    9402          7521     	SUBB	A, #2
1027    6008          7522     	JZ	DECODE_PWM_FREQ_LOW
                      7523     
1029    758E01        7524     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
102C    D273          7525     SETB FLAGS2 . 3 
102E    021036        7526     	JMP	DECODE_PWM_FREQ_END
                      7527     
                      7528     DECODE_PWM_FREQ_LOW: 
1031    758E00        7529     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
1034    C273          7530     CLR FLAGS2 . 3 
                      7531     
                      7532     DECODE_PWM_FREQ_END: 
1036    22            7533     	RET
                      7534     
                      7535     
                      7536     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7537     ;
                      7538     ; Decode settings
                      7539     ;
                      7540     ; No assumptions
                      7541     ;
                      7542     ; Decodes various settings
                      7543     ;
                      7544     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7545     DECODE_SETTINGS: 
                      7546     	; Decode governor gains
1037    7880          7547     MOV R0 , # PGM_GOV_P_GAIN 
1039    E6            7548     MOV A , @ R0 
103A    14            7549     	DEC	A	
103B    900080        7550     	MOV	DPTR, #GOV_GAIN_TABLE
103E    93            7551     	MOVC A, @A+DPTR	
103F    78A5          7552     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
1041    F6            7553     MOV @ R0 , A 
1042    7881          7554     MOV R0 , # PGM_GOV_I_GAIN 
1044    E6            7555     MOV A , @ R0 
1045    14            7556     	DEC	A	
1046    900080        7557     	MOV	DPTR, #GOV_GAIN_TABLE
1049    93            7558     	MOVC A, @A+DPTR	
104A    78A6          7559     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
104C    F6            7560     MOV @ R0 , A 
                      7561     	; Decode startup power
104D    7886          7562     MOV R0 , # PGM_STARTUP_PWR 
104F    E6            7563     MOV A , @ R0 
1050    14            7564     	DEC	A	
1051    90008D        7565     	MOV	DPTR, #STARTUP_POWER_TABLE
1054    93            7566     	MOVC A, @A+DPTR	
1055    78A7          7567     MOV R0 , # PGM_STARTUP_PWR_DECODED 
1057    F6            7568     MOV @ R0 , A 
                      7569     IF MODE == 0	; Main
                               	; Decode spoolup time
                               	MOV	TEMP1, #PGM_MAIN_SPOOLUP_TIME		
                               	MOV	A, @TEMP1
                               	MOV	TEMP1, A		; Store
                               	JNZ	DECODE_MAIN_SPOOLUP_NONZERO	; If not zero - branch
                               	
                               	MOV	MAIN_SPOOLUP_TIME_3X, #0	
                               	AJMP	DECODE_MAIN_SPOOLUP_DONE
                               
                               DECODE_MAIN_SPOOLUP_NONZERO:
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, #17		; Limit to 17 max
                               	JC	($+4)
                               
                               	MOV	TEMP1, #17
                               
                               	MOV	A, TEMP1
                               	ADD	A, TEMP1
                               	ADD	A, TEMP1		; Now 3x
                               	MOV	MAIN_SPOOLUP_TIME_3X, A
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, TEMP1		; Now 10x
                               	MOV	MAIN_SPOOLUP_TIME_10X, A
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, TEMP1		
                               	ADD	A, TEMP1		; Now 15x
                               	MOV	MAIN_SPOOLUP_TIME_15X, A
                               DECODE_MAIN_SPOOLUP_DONE:
                               ENDIF
                      7601     	; Decode low rpm power slope
1058    7886          7602     MOV R0 , # PGM_STARTUP_PWR 
105A    E6            7603     MOV A , @ R0 
105B    F539          7604     	MOV	LOW_RPM_PWR_SLOPE, A
105D    C3            7605     	CLR	C	
105E    9402          7606     	SUBB	A, #2
1060    5003          7607     	JNC	($+5)
1062    753902        7608     	MOV	LOW_RPM_PWR_SLOPE, #2
                      7609     	; Decode demag compensation
1065    789C          7610     MOV R0 , # PGM_DEMAG_COMP 
1067    E6            7611     MOV A , @ R0 
1068    7538FF        7612     	MOV	DEMAG_PWR_OFF_THRESH, #255	; Set default
                      7613     
106B    B40203        7614     	CJNE	A, #2, DECODE_DEMAG_HIGH
                      7615     
106E    7538A0        7616     	MOV	DEMAG_PWR_OFF_THRESH, #160	; Settings for demag comp low
                      7617     
                      7618     DECODE_DEMAG_HIGH: 
1071    B40303        7619     	CJNE	A, #3, DECODE_DEMAG_DONE
                      7620     
1074    753882        7621     	MOV	DEMAG_PWR_OFF_THRESH, #130	; Settings for demag comp high
                      7622     
                      7623     DECODE_DEMAG_DONE: 
                      7624     	; Decode pwm dither
1077    78A3          7625     MOV R0 , # PGM_PWM_DITHER 
1079    E6            7626     MOV A , @ R0 
107A    14            7627     	DEC	A	
107B    90009A        7628     	MOV	DPTR, #PWM_DITHER_TABLE
107E    93            7629     	MOVC A, @A+DPTR	
107F    F566          7630     	MOV	PWM_DITHER_DECODED, A
1081    120F7D        7631     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1084    22            7632     	RET
                      7633     
                      7634     
                      7635     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7636     ;
                      7637     ; Set BEC voltage
                      7638     ;
                      7639     ; No assumptions
                      7640     ;
                      7641     ; Sets the BEC output voltage low or high
                      7642     ;
                      7643     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7644     SET_BEC_VOLTAGE: 
                      7645     	; Set bec voltage
                      7646     IF HIGH_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
                      7656     IF HIGH_BEC_VOLTAGE == 2
                               	SET_BEC_0				; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	CJNE	A, #1, SET_BEC_VOLTAGE_2	
                               
                               	SET_BEC_1				; Set to level 1
                               
                               SET_BEC_VOLTAGE_2:
                               	CJNE	A, #2, SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_2				; Set to level 2
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
1085    22            7671     	RET
                      7672     
                      7673     
                      7674     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7675     ;
                      7676     ; Find throttle gain
                      7677     ;
                      7678     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      7679     ;
                      7680     ; Finds throttle gain from throttle calibration values
                      7681     ;
                      7682     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7683     FIND_THROTTLE_GAIN: 
                      7684     	; Load programmed minimum and maximum throttle
1086    7896          7685     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1088    E6            7686     MOV A , @ R0 
1089    FA            7687     MOV R2 , A 
108A    7897          7688     MOV R0 , # PGM_PPM_MAX_THROTTLE 
108C    E6            7689     MOV A , @ R0 
108D    FB            7690     MOV R3 , A 
108E    7888          7691     MOV R0 , # PGM_DIRECTION 
1090    E6            7692     MOV A , @ R0 
1091    B40305        7693     	CJNE	A, #3, FIND_THROTTLE_GAIN_CHECK_FULL
                      7694     
1094    C3            7695     	CLR	C
1095    EB            7696     MOV A , R3 
1096    940E          7697     	SUBB	A, #14				; Compensate for higher deadband in bidirectional
1098    FB            7698     MOV R3 , A 
                      7699     
                      7700     FIND_THROTTLE_GAIN_CHECK_FULL: 
                      7701     	; Check if full range is chosen
1099    307F04        7702     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      7703     
109C    7A00          7704     MOV R2 , # 0 
109E    7BFF          7705     MOV R3 , # 255 
                      7706     
                      7707     FIND_THROTTLE_GAIN_CALCULATE: 
                      7708     	; Calculate difference
10A0    C3            7709     	CLR	C
10A1    EB            7710     MOV A , R3 
10A2    9A            7711     SUBB A , R2 
10A3    FC            7712     MOV R4 , A 
                      7713     	; Check that difference is minimum 130
10A4    C3            7714     	CLR	C
10A5    9482          7715     	SUBB	A, #130
10A7    5002          7716     	JNC	($+4)
                      7717     
10A9    7C82          7718     MOV R4 , # 130 
                      7719     
                      7720     	; Find gain
10AB    757200        7721     	MOV	PPM_THROTTLE_GAIN, #0
                      7722     TEST_THROTTLE_GAIN: 
10AE    0572          7723     	INC	PPM_THROTTLE_GAIN
10B0    EC            7724     MOV A , R4 
10B1    8572F0        7725     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
10B4    A4            7726     	MUL	AB
10B5    C3            7727     	CLR	C
10B6    E5F0          7728     	MOV	A, B
10B8    947D          7729     	SUBB	A, #125
10BA    40F2          7730     	JC	TEST_THROTTLE_GAIN
10BC    22            7731     	RET
                      7732     
                      7733     
                      7734     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7735     ;
                      7736     ; Average throttle 
                      7737     ;
                      7738     ; Outputs result in Temp7
                      7739     ;
                      7740     ; Averages throttle calibration readings
                      7741     ;
                      7742     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7743     AVERAGE_THROTTLE: 
10BD    D27F          7744     SETB FLAGS3 . 7 
10BF    1186          7745     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
10C1    1205F3        7746     	CALL WAIT30MS		
10C4    1205F3        7747     	CALL WAIT30MS		
10C7    7A00          7748     MOV R2 , # 0 
10C9    7B00          7749     MOV R3 , # 0 
10CB    7C10          7750     MOV R4 , # 16 
                      7751     AVERAGE_THROTTLE_MEAS: 
10CD    1205E9        7752     	CALL	WAIT3MS			; Wait for new RC pulse value
10D0    E55C          7753     	MOV	A, NEW_RCP		; Get new RC pulse value
10D2    2A            7754     ADD A , R2 
10D3    FA            7755     MOV R2 , A 
10D4    7400          7756     	MOV	A, #0
10D6    3B            7757     ADDC A , R3 
10D7    FB            7758     MOV R3 , A 
10D8    DCF3          7759     DJNZ R4 , AVERAGE_THROTTLE_MEAS 
                      7760     
10DA    7C04          7761     MOV R4 , # 4 
                      7762     AVERAGE_THROTTLE_DIV: 
10DC    C3            7763     	CLR	C
10DD    EB            7764     MOV A , R3 
10DE    13            7765     	RRC	A      
10DF    FB            7766     MOV R3 , A 
10E0    EA            7767     MOV A , R2 
10E1    13            7768     	RRC	A      
10E2    FA            7769     MOV R2 , A 
10E3    DCF7          7770     DJNZ R4 , AVERAGE_THROTTLE_DIV 
                      7771     
10E5    FE            7772     MOV R6 , A 
10E6    C27F          7773     CLR FLAGS3 . 7 
10E8    1186          7774     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
10EA    22            7775     	RET
                      7776     
                      7777     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7778     ;		Music Routines
                      7779     ;
                      7780     ;
                      7781     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7782     
                      7783     MUSIC_F1: 
10EB    7ADE          7784     MOV R2 , # 222 
                      7785     MUSIC_F1_BEEP: 
                      7786     	APFET_ON
10ED    D294          7786+1   SETB P1 . 4 
                      7787     	CNFET_ON
10EF    D293          7787+1   SETB P1 . 3 
10F1    744B          7788     	MOV	A, #75		
10F3    D5E0FD        7789     	DJNZ	ACC, $
                      7790     	CNFET_OFF
10F6    C293          7790+1   CLR P1 . 3 
                      7791     	APFET_OFF
10F8    C294          7791+1   CLR P1 . 4 
                      7792     
                      7793     ;X*1ms to wait
10FA    7902          7794     MOV R1 , # 2 
                      7795     WAIT_MS_1_O_M1: 	
10FC    7817          7796     MOV R0 , # 23 
                      7797     WAIT_MS_1_M_M1: 	
10FE    E4            7798     	CLR	A
10FF    D5E0FD        7799      	DJNZ	ACC, $	
1102    D8FA          7800     DJNZ R0 , WAIT_MS_1_M_M1 
1104    D9F6          7801     DJNZ R1 , WAIT_MS_1_O_M1 
                      7802     
                      7803     ;X*5us to wait
1106    796E          7804     MOV R1 , # 110 
                      7805     WAIT_US_100_M1: 
1108    741E          7806     	MOV	A, #30		
110A    D5E0FD        7807     	DJNZ	ACC, $
110D    D9F9          7808     DJNZ R1 , WAIT_US_100_M1 
                      7809     
110F    DADC          7810     DJNZ R2 , MUSIC_F1_BEEP 
1111    22            7811     	RET
                      7812     
                      7813     
                      7814     MUSIC_F2: 
1112    7A84          7815     MOV R2 , # 132 
                      7816     MUSIC_F2_BEEP: 
                      7817     	APFET_ON
1114    D294          7817+1   SETB P1 . 4 
                      7818     	CNFET_ON
1116    D293          7818+1   SETB P1 . 3 
1118    744B          7819     	MOV	A, #75
111A    D5E0FD        7820     	DJNZ	ACC, $
                      7821     	CNFET_OFF
111D    C293          7821+1   CLR P1 . 3 
                      7822     	APFET_OFF
111F    C294          7822+1   CLR P1 . 4 
                      7823     
                      7824     ;X*1ms to wait
1121    7903          7825     MOV R1 , # 3 
                      7826     WAIT_MS_1_O_M2: 	
1123    7817          7827     MOV R0 , # 23 
                      7828     WAIT_MS_1_M_M2: 
1125    E4            7829     	CLR	A
1126    D5E0FD        7830      	DJNZ	ACC, $
1129    D8FA          7831     DJNZ R0 , WAIT_MS_1_M_M2 
112B    D9F6          7832     DJNZ R1 , WAIT_MS_1_O_M2 
                      7833     
                      7834     ;X*5us to wait
112D    792B          7835     MOV R1 , # 43 
                      7836     WAIT_US_100_M2: 
112F    741E          7837     	MOV	A, #30		
1131    D5E0FD        7838     	DJNZ	ACC, $
1134    D9F9          7839     DJNZ R1 , WAIT_US_100_M2 
1136    DADC          7840     DJNZ R2 , MUSIC_F2_BEEP 
1138    22            7841     	RET
                      7842     
                      7843     
                      7844     MUSIC_F3: 
1139    7A84          7845     MOV R2 , # 132 
                      7846     MUSIC_F3_BEEP: 
                      7847     	APFET_ON
113B    D294          7847+1   SETB P1 . 4 
                      7848     	CNFET_ON
113D    D293          7848+1   SETB P1 . 3 
113F    744B          7849     	MOV	A, #75	
1141    D5E0FD        7850     	DJNZ	ACC, $
                      7851     	CNFET_OFF
1144    C293          7851+1   CLR P1 . 3 
                      7852     	APFET_OFF
1146    C294          7852+1   CLR P1 . 4 
                      7853     
                      7854     ;X*1ms to wait
1148    7902          7855     MOV R1 , # 2 
                      7856     WAIT_MS_1_O_M3: 	
114A    7817          7857     MOV R0 , # 23 
                      7858     WAIT_MS_1_M_M3: 	
114C    E4            7859     	CLR	A
114D    D5E0FD        7860      	DJNZ	ACC, $	
1150    D8FA          7861     DJNZ R0 , WAIT_MS_1_M_M3 
1152    D9F6          7862     DJNZ R1 , WAIT_MS_1_O_M3 
                      7863     
1154    791D          7864     MOV R1 , # 29 
                      7865     WAIT_US_100_M3: 
1156    741E          7866     	MOV	A, #30		
1158    D5E0FD        7867     	DJNZ	ACC, $
115B    D9F9          7868     DJNZ R1 , WAIT_US_100_M3 
115D    DADC          7869     DJNZ R2 , MUSIC_F3_BEEP 
115F    22            7870     	RET
                      7871     
                      7872     
                      7873     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7874     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7875     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7876     ;
                      7877     ; Main program start
                      7878     ;
                      7879     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7880     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7881     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7882     PGM_START: 
                      7883     	; Initialize flash keys to invalid values
1160    757C00        7884     	MOV	FLASH_KEY_1, #0
1163    757D00        7885     	MOV	FLASH_KEY_2, #0
                      7886     	; Check flash lock byte
1166    E5EF          7887     	MOV	A, RSTSRC			
1168    20E603        7888     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      7889     
116B    752000        7890     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      7891     
116E    0520          7892     	INC	BIT_ACCESS
1170    903FFF        7893     MOV DPTR , # 16383 
1173    E520          7894     	MOV	A, BIT_ACCESS
1175    14            7895     	DEC	A
1176    6006          7896     	JZ	LOCK_BYTE_TEST
                      7897     
1178    901FFF        7898     MOV DPTR , # 8191 
117B    14            7899     	DEC	A
117C    6000          7900     	JZ	LOCK_BYTE_TEST
                      7901     
                      7902     LOCK_BYTE_TEST: 
117E    93            7903     	MOVC A, @A+DPTR		; Read lock byte
117F    04            7904     	INC	A				
1180    6003          7905     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      7906     
                      7907     IF ONE_S_CAPABLE == 0		
1182    75EF16        7908     	MOV	RSTSRC, #16H			; Generate hardware reset and set missing clock and VDD monitor
                      7909     ELSE
                               	MOV	RSTSRC, #14H			; Generate hardware reset and disable VDD monitor
                               ENDIF
                      7912     
                      7913     LOCK_BYTE_OK: 
                      7914     	; Disable the WDT.
                      7915     IF SIGNATURE_001 == 0F3H		
1185    53D9BF        7916     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
1188    75D908        7917     	MOV	PCA0MD, #0X08     ; PCA0MD divider to Sysclock instead of sysclock / 12 - Multishot
                      7918     ENDIF
                      7919     IF SIGNATURE_001 == 0F8H		
                               	MOV	WDTCN, #0DEH		; Disable watchdog
                               	MOV	WDTCN, #0ADH		
                               ENDIF
                      7923     	; Initialize stack
118B    7581C0        7924     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      7925     	; Initialize VDD monitor
118E    43FF80        7926     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
1191    1205E4        7927     	CALL	WAIT1MS			; Wait at least 100us
                      7928     IF ONE_S_CAPABLE == 0		
1194    75EF06        7929     	MOV 	RSTSRC, #06H   	; Set missing clock and VDD monitor as a reset source if not 1S capable
                      7930     ELSE
                               	MOV 	RSTSRC, #04H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it
                               ENDIF
                      7933     	; Set clock frequency
                      7934     IF SIGNATURE_001 == 0F3H		
1197    43B203        7935     	ORL	OSCICN, #03H		; Set clock divider to 1 (not supported on 'f850)
                      7936     ENDIF
                      7937     IF SIGNATURE_001 == 0F8H		
                               	MOV	CLKSEL, #00H		; Set clock divider to 1 (not supported on 'f3xx)
                               ENDIF
119A    E5B3          7940     	MOV	A, OSCICL				
119C    2402          7941     	ADD	A, #02H			; 24.5MHz to 24MHz (~0.5-1% per step)
119E    20E70D        7942     	JB	ACC.7, RESET_CAL_DONE	; Is carry (7bit) set? - branch
                      7943     
11A1    F521          7944     	MOV	BIT_ACCESS_INT, A
                      7945     IF SIGNATURE_002 <> 010H		
11A3    E5E3          7946     	MOV	A, OSCLCN
                      7947     ELSE
                               	MOV	A, OSCXCN
                               ENDIF
11A5    20E006        7950     	JB	ACC.0, RESET_CAL_DONE	; Set if cal aleady done
                      7951     
11A8    8521B3        7952     	MOV	OSCICL, BIT_ACCESS_INT
                      7953     IF SIGNATURE_002 <> 010H		
11AB    43E301        7954     	ORL	OSCLCN, #01H			; Tag that cal is done
                      7955     ELSE
                               	ORL	OSCXCN, #01H			; Tag that cal is done
                               ENDIF
                      7958     
                      7959     RESET_CAL_DONE: 
                      7960     	; Switch power off
11AE    120F7D        7961     	CALL	SWITCH_POWER_OFF
                      7962     	; Ports initialization
11B1    7580FF        7963     MOV P0 , # 255 
11B4    75A400        7964     MOV P0MDOUT , # 0 
11B7    75F1B2        7965     MOV P0MDIN , # -78 
11BA    75D4DF        7966     MOV P0SKIP , # -33 
11BD    759001        7967     MOV P1 , # 1 
11C0    75A5FC        7968     MOV P1MDOUT , # 252 
11C3    75F2FE        7969     MOV P1MDIN , # -2 
11C6    75D501        7970     MOV P1SKIP , # 1 
                      7971     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
11C9    75A601        7974     MOV P2MDOUT , # 1 
                      7975     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      7982     	; Initialize the XBAR and related functionality
                      7983     	INITIALIZE_XBAR
11CC    75E241        7983+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      7984     	; Switch power off again, after initializing ports
11CF    120F7D        7985     	CALL	SWITCH_POWER_OFF
                      7986     	; Clear RAM
11D2    E4            7987     	CLR	A				; Clear accumulator
11D3    F8            7988     MOV R0 , A 
                      7989     CLEAR_RAM: 	
11D4    F6            7990     MOV @ R0 , A 
11D5    D8FD          7991     DJNZ R0 , CLEAR_RAM 
                      7992     	; Initialize LFSR
11D7    756801        7993     	MOV	RANDOM, #1
                      7994     	; Set default programmed parameters
11DA    120F92        7995     	CALL	SET_DEFAULT_PARAMETERS
                      7996     	; Read all programmed parameters
11DD    1216DD        7997     	CALL READ_ALL_EEPROM_PARAMETERS
                      7998     	; Set beep strength
11E0    7898          7999     MOV R0 , # PGM_BEEP_STRENGTH 
11E2    8673          8000     MOV BEEP_STRENGTH , @ R0 
                      8001     	; Set initial arm variable
11E4    753001        8002     	MOV	INITIAL_ARM, #1
                      8003     	; Initializing beep
11E7    C2AF          8004     	CLR	EA				; Disable interrupts explicitly
                      8005     
11E9    1205FD        8006       CALL WAIT200MS
11EC    11EB          8007     	CALL MUSIC_F1
11EE    1205F8        8008     	CALL WAIT100MS
11F1    11EB          8009     	CALL MUSIC_F1
11F3    1205F8        8010     	CALL WAIT100MS
11F6    11EB          8011     	CALL MUSIC_F1
11F8    1205F8        8012     	CALL WAIT100MS
11FB    3112          8013     	CALL MUSIC_F2
11FD    3139          8014     	CALL MUSIC_F3
11FF    11EB          8015     	CALL MUSIC_F1
1201    1205F8        8016     	CALL WAIT100MS
1204    3112          8017     	CALL MUSIC_F2
1206    3139          8018     	CALL MUSIC_F3
1208    11EB          8019     	CALL MUSIC_F1
120A    11EB          8020     	CALL MUSIC_F1
                      8021     
                      8022     IF MODE <= 1	; Main or tail
                               	; Wait for receiver to initialize
                               	CALL	WAIT1S
                               	CALL	WAIT200MS
                               	CALL	WAIT200MS
                               	CALL	WAIT100MS
                               ENDIF
                      8029     
                      8030     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8031     ;
                      8032     ; No signal entry point
                      8033     ;
                      8034     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8035     INIT_NO_SIGNAL: 
                      8036     	; Disable interrupts explicitly
120C    C2AF          8037     	CLR	EA				
                      8038     	; Initialize flash keys to invalid values
120E    757C00        8039     	MOV	FLASH_KEY_1, #0
1211    757D00        8040     	MOV	FLASH_KEY_2, #0
                      8041     	; Check if input signal is high for more than 15ms
1214    78FA          8042     MOV R0 , # 250 
                      8043     INPUT_HIGH_CHECK_1: 
1216    79FA          8044     MOV R1 , # 250 
                      8045     INPUT_HIGH_CHECK_2: 
1218    308507        8046     JNB 128 . 5 , BOOTLOADER_DONE 
121B    D9FB          8047     DJNZ R1 , INPUT_HIGH_CHECK_2 
121D    D8F7          8048     DJNZ R0 , INPUT_HIGH_CHECK_1 
                      8049     
121F    021C00        8050     	LJMP	1C00H			; Jump to bootloader
                      8051     
                      8052     BOOTLOADER_DONE: 
                      8053     	; Decode parameters
1222    120FFE        8054     	CALL	DECODE_PARAMETERS
                      8055     	; Decode settings
1225    1137          8056     	CALL	DECODE_SETTINGS
                      8057     	; Set BEC voltage
1227    1185          8058     	CALL	SET_BEC_VOLTAGE
                      8059     	; Find throttle gain from stored min and max settings
1229    1186          8060     	CALL	FIND_THROTTLE_GAIN
                      8061     	; Set beep strength
122B    7898          8062     MOV R0 , # PGM_BEEP_STRENGTH 
122D    8673          8063     MOV BEEP_STRENGTH , @ R0 
                      8064     	; Switch power off
122F    120F7D        8065     	CALL	SWITCH_POWER_OFF
                      8066     	; Set clock frequency
                      8067     IF MCU_48MHZ == 1
                      8068     	SET_MCU_CLK_24MHZ
1232    75A900        8068+1   MOV CLKSEL , # 0  ; SET CLOCK TO 24MHZ
1235    75B680        8068+1   MOV FLSCL , # 80H  ; SET FLASH TIMING FOR 24MHZ
1238    757A00        8068+1   MOV CLOCK_SET_AT_48MHZ , # 0 
                      8069     ENDIF
                      8070     	; Timer control
123B    758810        8071     	MOV	TCON, #10H		; Timer0 enabled
                      8072     	; Timer mode
123E    758902        8073     	MOV	TMOD, #02H		; Timer0 as 8bit
                      8074     	; Timer2: clk/12 for 128us and 32ms interrupts
1241    75C824        8075     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      8076     	; Timer3: clk/12 for commutation timing
1244    759104        8077     	MOV	TMR3CN, #04H		; Timer3 enabled
                      8078     	; PCA
1247    75D840        8079     	MOV	PCA0CN, #40H		; PCA enabled
                      8080     	; Enable interrupts
124A    75A822        8081     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
124D    75B802        8082     	MOV	IP, #02H			; High priority to timer0 interrupts
1250    75E690        8083     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      8084     	; Initialize comparator
1253    759B80        8085     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
1256    759D00        8086     	MOV	CPT0MD, #00H		; Comparator response time 100ns
                      8087     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #00H		; Comparator response time 100ns
                               ENDIF
                      8091     	; Initialize ADC
                      8092     	INITIALIZE_ADC			; Initialize ADC operation
1259    75D10E        8092+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
                      8092+1   IF 1 ==0 
                               MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
                               ELSE 
125C    75BCC0        8092+1   MOV ADC0CF , # 0C0H  ; ADC CLOCK 2MHZ
                      8092+1   ENDIF 
125F    75BB08        8092+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
1262    75BA11        8092+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
1265    75E880        8092+1   MOV ADC0CN , # 80H  ; ADC ENABLED
1268    1205E4        8093     	CALL	WAIT1MS
126B    D2AF          8094     	SETB	EA				; Enable all interrupts
                      8095     	; Measure number of lipo cells
126D    1208F2        8096     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      8097     	; Reset stall count
1270    753600        8098     	MOV	STALL_CNT, #0
                      8099     	; Initialize RC pulse
                      8100     	RCP_INT_FIRST 					; Enable interrupt and set to first edge
1273    53DACF        8100+1   ANL PCA0CPM0 , # 0CFH 
1276    207E03        8100+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
1279    43DA20        8100+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
127C    307E03        8100+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
127F    43DA10        8100+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      8101     	RCP_INT_ENABLE		 			; Enable interrupt
1282    43DA01        8101+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      8102     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
1285    C2D8          8102+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1287    C271          8103     CLR FLAGS2 . 1 
1289    1205FD        8104     	CALL WAIT200MS
                      8105     
                      8106     	; Measure PWM frequency
                      8107     MEASURE_PWM_FREQ_INIT: 	
128C    D261          8108     SETB FLAGS0 . 1 
128E    7B03          8109     MOV R3 , # 3 
                      8110     MEASURE_PWM_FREQ_START: 	
1290    7A0C          8111     MOV R2 , # 12 
                      8112     MEASURE_PWM_FREQ_LOOP: 	
                      8113     	; Check if period diff was accepted
1292    E55B          8114     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
1294    7007          8115     	JNZ	MEASURE_PWM_FREQ_WAIT
                      8116     
1296    7A0C          8117     MOV R2 , # 12 
1298    DB03          8118     DJNZ R3 , ( $+5 ) 
129A    02120C        8119     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      8120     
                      8121     MEASURE_PWM_FREQ_WAIT: 
129D    1205F3        8122     	CALL	WAIT30MS						; Wait 30ms for new pulse
12A0    207003        8123     JB FLAGS2 . 0 , ( $+6 ) 
12A3    02120C        8124     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      8125     
12A6    C270          8126     CLR FLAGS2 . 0 
12A8    E55C          8127     	MOV	A, NEW_RCP					; Load value
12AA    C3            8128     	CLR	C
12AB    9402          8129     SUBB A , # 2 
12AD    40E1          8130     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      8131     
12AF    E52F          8132     	MOV	A, FLAGS3						; Check pwm frequency flags
12B1    541F          8133     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
12B3    855E5D        8134     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
12B6    F55E          8135     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
12B8    B55DD5        8136     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      8137     
12BB    DAD5          8138     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      8139     
                      8140     	; Clear measure pwm frequency flag
12BD    C261          8141     CLR FLAGS0 . 1 
                      8142     	; Set up RC pulse interrupts after pwm frequency measurement
                      8143     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
12BF    53DACF        8143+1   ANL PCA0CPM0 , # 0CFH 
12C2    207E03        8143+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
12C5    43DA20        8143+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
12C8    307E03        8143+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
12CB    43DA10        8143+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      8144     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
12CE    C2D8          8144+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
12D0    C271          8145     CLR FLAGS2 . 1 
12D2    78A2          8146     MOV R0 , # PGM_ENABLE_PWM_INPUT 
12D4    E6            8147     MOV A , @ R0 
12D5    7008          8148     	JNZ	TEST_FOR_ONESHOT				; If it is - proceed
                      8149     
12D7    D274          8150     SETB FLAGS2 . 4 
12D9    E52F          8151     	MOV	A, FLAGS3						; Clear pwm frequency flags
12DB    54E0          8152     	ANL	A, #NOT((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
12DD    F52F          8153     	MOV	FLAGS3, A
                      8154     
                      8155     TEST_FOR_ONESHOT: 	
                      8156     	; Test whether signal is OneShot125
12DF    C275          8157     CLR FLAGS2 . 5 
12E1    752900        8158     	MOV	RCP_OUTSIDE_RANGE_CNT, #0		; Reset out of range counter
12E4    1205F8        8159     	CALL WAIT100MS						; Wait for new RC pulse
12E7    307409        8160     JNB FLAGS2 . 4 , VALIDATE_RCP_START 
                      8161     
12EA    C3            8162     	CLR	C
12EB    E529          8163     	MOV	A, RCP_OUTSIDE_RANGE_CNT			; Check how many pulses were outside normal PPM range (800-2160us)
12ED    940A          8164     	SUBB	A, #10						
12EF    4002          8165     	JC	VALIDATE_RCP_START
                      8166     
12F1    D275          8167     SETB FLAGS2 . 5 
                      8168     
                      8169     	; Validate RC pulse
                      8170     VALIDATE_RCP_START: 	
12F3    1205E9        8171     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
12F6    7802          8172     MOV R0 , # 2 
12F8    307402        8173     JNB FLAGS2 . 4 , ( $+5 ) 
                      8174     
12FB    7800          8175     MOV R0 , # 0 
                      8176     
12FD    C3            8177     	CLR	C
12FE    E55C          8178     	MOV	A, NEW_RCP					; Load value
1300    98            8179     SUBB A , R0 
1301    40F0          8180     	JC	VALIDATE_RCP_START				; No - start over
                      8181     
                      8182     	; Beep arm sequence start signal
1303    C2AF          8183     	CLR 	EA							; Disable all interrupts
1305    12060D        8184     	CALL BEEP_F1						; Signal that RC pulse is ready
1308    12060D        8185     	CALL BEEP_F1
130B    D2AF          8186     	SETB	EA							; Enable all interrupts
130D    1205FD        8187     	CALL WAIT200MS	
                      8188     
                      8189     	; Arming sequence start
1310    754C00        8190     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      8191     ARMING_START: 
                      8192     IF MODE >= 1	; Tail or multi
1313    7888          8193     MOV R0 , # PGM_DIRECTION 
1315    E6            8194     MOV A , @ R0 
1316    B40302        8195     	CJNE	A, #3, ($+5)
                      8196     
1319    8106          8197     	AJMP	PROGRAM_BY_TX_CHECKED	; Disable tx programming if bidirectional operation
                      8198     ENDIF
                      8199     
131B    1205E9        8200     	CALL WAIT3MS
131E    788C          8201     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
1320    E6            8202     MOV A , @ R0 
1321    C3            8203     	CLR	C
1322    9401          8204     	SUBB	A, #1				; Is TX programming enabled?
1324    5003          8205     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      8206     
1326    021406        8207     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      8208     
                      8209     ARMING_INITIAL_ARM_CHECK: 
1329    E530          8210     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
132B    C3            8211     	CLR	C
132C    9401          8212     	SUBB	A, #1				; Is it the initial arm sequence?
132E    5003          8213     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      8214     
1330    021406        8215     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      8216     
                      8217     ARMING_PPM_CHECK: 
                      8218     	; Initialize flash keys to valid values
1333    757CA5        8219     	MOV	FLASH_KEY_1, #0A5H
1336    757DF1        8220     	MOV	FLASH_KEY_2, #0F1H
1339    207435        8221     JB FLAGS2 . 4 , THROTTLE_HIGH_CAL_START 
                      8222     
                      8223     	; PWM tx program entry
133C    C3            8224     	CLR	C
133D    E55C          8225     	MOV	A, NEW_RCP			; Load new RC pulse value
133F    94FF          8226     SUBB A , # 255 
1341    5003          8227     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      8228     
1343    021406        8229     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      8230     
                      8231     PROGRAM_BY_TX_ENTRY_PWM: 	
1346    C2AF          8232     	CLR	EA					; Disable all interrupts
1348    120622        8233     	CALL BEEP_F4
134B    D2AF          8234     	SETB	EA					; Enable all interrupts
134D    1205F8        8235     	CALL WAIT100MS
1350    C3            8236     	CLR	C
1351    E55C          8237     	MOV	A, NEW_RCP			; Load new RC pulse value
1353    9401          8238     SUBB A , # 1 
1355    50EF          8239     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      8240     
                      8241     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
1357    C2AF          8242     	CLR	EA					; Disable all interrupts
1359    12060D        8243     	CALL BEEP_F1
135C    1205EE        8244     	CALL WAIT10MS
135F    12060D        8245     	CALL BEEP_F1
1362    D2AF          8246     	SETB	EA					; Enable all interrupts
1364    1205F8        8247     	CALL WAIT100MS
1367    C3            8248     	CLR	C
1368    E55C          8249     	MOV	A, NEW_RCP			; Load new RC pulse value
136A    94FF          8250     SUBB A , # 255 
136C    40E9          8251     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      8252     
136E    021889        8253     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      8254     
                      8255     	; PPM throttle calibration and tx program entry
                      8256     THROTTLE_HIGH_CAL_START: 
                      8257     IF MODE <= 1	; Main or tail
                               	MOV	TEMP8, #5				; Set 3 seconds wait time
                               ELSE
1371    7F02          8260     MOV R7 , # 2 
                      8261     ENDIF
                      8262     THROTTLE_HIGH_CAL: 			
1373    D27F          8263     SETB FLAGS3 . 7 
1375    1186          8264     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1377    1205F8        8265     	CALL WAIT100MS				; Wait for new throttle value
137A    C2AF          8266     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
137C    C27F          8267     CLR FLAGS3 . 7 
137E    1186          8268     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1380    AE5C          8269     MOV R6 , NEW_RCP 
1382    C3            8270     	CLR	C
1383    E55C          8271     	MOV	A, NEW_RCP			; Load new RC pulse value
1385    947F          8272     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
1387    D2AF          8273     	SETB	EA					; Enable interrupts
1389    5002          8274     	JNC	($+4)		
138B    8116          8275     	AJMP	ARM_TARGET_UPDATED		; No - branch
                      8276     
138D    1205E4        8277     	CALL WAIT1MS		
1390    C2AF          8278     	CLR	EA					; Disable all interrupts
1392    120622        8279     	CALL BEEP_F4
1395    D2AF          8280     	SETB	EA					; Enable all interrupts
1397    DFDA          8281     DJNZ R7 , THROTTLE_HIGH_CAL 
                      8282     
1399    11BD          8283     	CALL	AVERAGE_THROTTLE
139B    C3            8284     	CLR	C
139C    EE            8285     MOV A , R6 
                      8286     IF MODE <= 1	; Main or tail
                               	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
                               ENDIF
139D    7897          8289     MOV R0 , # PGM_PPM_MAX_THROTTLE 
139F    F6            8290     MOV @ R0 , A 
13A0    1205FD        8291     	CALL WAIT200MS				
13A3    12180C        8292     	CALL	SUCCESS_BEEP
                      8293     
                      8294     THROTTLE_LOW_CAL_START: 
13A6    7F0A          8295     MOV R7 , # 10 
                      8296     THROTTLE_LOW_CAL: 			
13A8    D27F          8297     SETB FLAGS3 . 7 
13AA    1186          8298     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13AC    1205F8        8299     	CALL WAIT100MS
13AF    C2AF          8300     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
13B1    C27F          8301     CLR FLAGS3 . 7 
13B3    1186          8302     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13B5    AE5C          8303     MOV R6 , NEW_RCP 
13B7    C3            8304     	CLR	C
13B8    E55C          8305     	MOV	A, NEW_RCP			; Load new RC pulse value
13BA    947F          8306     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
13BC    D2AF          8307     	SETB	EA					; Enable interrupts
13BE    50E6          8308     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      8309     
13C0    1205E4        8310     	CALL WAIT1MS		
13C3    C2AF          8311     	CLR	EA					; Disable all interrupts
13C5    12060D        8312     	CALL BEEP_F1
13C8    1205EE        8313     	CALL WAIT10MS
13CB    12060D        8314     	CALL BEEP_F1
13CE    D2AF          8315     	SETB	EA					; Enable all interrupts
13D0    DFD6          8316     DJNZ R7 , THROTTLE_LOW_CAL 
                      8317     
13D2    11BD          8318     	CALL	AVERAGE_THROTTLE
13D4    EE            8319     MOV A , R6 
13D5    2403          8320     	ADD	A, #3				; Add about 1%
13D7    7896          8321     MOV R0 , # PGM_PPM_MIN_THROTTLE 
13D9    F6            8322     MOV @ R0 , A 
13DA    F8            8323     MOV R0 , A 
13DB    7997          8324     MOV R1 , # PGM_PPM_MAX_THROTTLE 
13DD    E7            8325     MOV A , @ R1 
13DE    C3            8326     	CLR	C
13DF    9482          8327     	SUBB	A, #130				; Subtract 130 (520us) from max throttle
13E1    4003          8328     	JC	PROGRAM_BY_TX_ENTRY_LIMIT
                      8329     
13E3    98            8330     SUBB A , R0 
13E4    5006          8331     	JNC	PROGRAM_BY_TX_ENTRY_STORE
                      8332     
                      8333     PROGRAM_BY_TX_ENTRY_LIMIT: 
13E6    E8            8334     MOV A , R0 
13E7    2482          8335     	ADD	A, #130				; Make max 520us higher than min
13E9    7897          8336     MOV R0 , # PGM_PPM_MAX_THROTTLE 
13EB    F6            8337     MOV @ R0 , A 
                      8338     
                      8339     PROGRAM_BY_TX_ENTRY_STORE: 
13EC    1205FD        8340     	CALL WAIT200MS				
13EF    12171F        8341     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
13F2    12183B        8342     	CALL	SUCCESS_BEEP_INVERTED
                      8343     
                      8344     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
13F5    1205F8        8345     	CALL WAIT100MS
13F8    1186          8346     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13FA    C3            8347     	CLR	C
13FB    E55C          8348     	MOV	A, NEW_RCP			; Load new RC pulse value
13FD    94FF          8349     SUBB A , # 255 
13FF    5002          8350     	JNC	($+4)
1401    6133          8351     	AJMP	ARMING_PPM_CHECK		; No - go back
                      8352     
1403    021889        8353     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      8354     
                      8355     PROGRAM_BY_TX_CHECKED: 
                      8356     	; Initialize flash keys to invalid values
1406    757C00        8357     	MOV	FLASH_KEY_1, #0
1409    757D00        8358     	MOV	FLASH_KEY_2, #0
140C    C3            8359     	CLR	C
140D    E55C          8360     	MOV	A, NEW_RCP			; Load new RC pulse value
140F    954C          8361     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
1411    4003          8362     	JC	ARM_TARGET_UPDATED		; No - do not update
                      8363     
1413    855C4C        8364     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      8365     
                      8366     ARM_TARGET_UPDATED: 
1416    1205F8        8367     	CALL WAIT100MS				; Wait for new throttle value
1419    7801          8368     MOV R0 , # 1 
141B    7988          8369     MOV R1 , # PGM_DIRECTION 
141D    E7            8370     MOV A , @ R1 
141E    B40302        8371     	CJNE	A, #3, ($+5)			; No - branch
                      8372     
1421    7805          8373     MOV R0 , # ( RCP_STOP+4 ) 
                      8374     
1423    C3            8375     	CLR	C
1424    E55C          8376     	MOV	A, NEW_RCP			; Load new RC pulse value
1426    98            8377     SUBB A , R0 
1427    4002          8378     	JC	ARM_END_BEEP			; Yes - proceed
                      8379     
1429    6113          8380     	JMP	ARMING_START			; No - start over
                      8381     
                      8382     ARM_END_BEEP: 
                      8383     	; Beep arm sequence end signal
142B    C2AF          8384     	CLR 	EA					; Disable all interrupts
142D    120622        8385     	CALL BEEP_F4			; Signal that rcpulse is ready
1430    120622        8386     	CALL BEEP_F4
1433    D2AF          8387     	SETB	EA					; Enable all interrupts
1435    1205FD        8388     	CALL WAIT200MS
                      8389     
                      8390     	; Clear initial arm variable
1438    753000        8391     	MOV	INITIAL_ARM, #0
                      8392     
                      8393     	; Armed and waiting for power on
                      8394     WAIT_FOR_POWER_ON: 
143B    E4            8395     	CLR	A
143C    F531          8396     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
143E    F532          8397     	MOV	POWER_ON_WAIT_CNT_H, A	
                      8398     WAIT_FOR_POWER_ON_LOOP: 
1440    0531          8399     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
1442    E531          8400     	MOV	A, POWER_ON_WAIT_CNT_L
1444    F4            8401     	CPL	A
1445    703F          8402     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 3 sec)
                      8403     
1447    0532          8404     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
1449    789A          8405     MOV R0 , # PGM_BEACON_DELAY 
144B    E6            8406     MOV A , @ R0 
144C    7819          8407     MOV R0 , # 25 
144E    14            8408     	DEC	A
144F    6012          8409     	JZ	BEEP_DELAY_SET
                      8410     
1451    7832          8411     MOV R0 , # 50 
1453    14            8412     	DEC	A
1454    600D          8413     	JZ	BEEP_DELAY_SET
                      8414     
1456    787D          8415     MOV R0 , # 125 
1458    14            8416     	DEC	A
1459    6008          8417     	JZ	BEEP_DELAY_SET
                      8418     
145B    78FA          8419     MOV R0 , # 250 
145D    14            8420     	DEC	A
145E    6003          8421     	JZ	BEEP_DELAY_SET
                      8422     
1460    753200        8423     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      8424     
                      8425     BEEP_DELAY_SET: 
1463    C3            8426     	CLR	C
1464    E532          8427     	MOV	A, POWER_ON_WAIT_CNT_H
1466    98            8428     SUBB A , R0 
1467    401D          8429     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      8430     
1469    120F7D        8431     	CALL	SWITCH_POWER_OFF		; Switch power off in case braking is set
146C    1205E4        8432     	CALL	WAIT1MS
146F    1532          8433     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
1471    753100        8434     	MOV	POWER_ON_WAIT_CNT_L, #0	; Set low wait counter
1474    7899          8435     MOV R0 , # PGM_BEACON_STRENGTH 
1476    8673          8436     MOV BEEP_STRENGTH , @ R0 
1478    C2AF          8437     	CLR 	EA					; Disable all interrupts
147A    120622        8438     	CALL BEEP_F4				; Signal that there is no signal
147D    D2AF          8439     	SETB	EA					; Enable all interrupts
147F    7898          8440     MOV R0 , # PGM_BEEP_STRENGTH 
1481    8673          8441     MOV BEEP_STRENGTH , @ R0 
1483    1205F8        8442     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      8443     
                      8444     WAIT_FOR_POWER_ON_NO_BEEP: 
1486    1205EE        8445     	CALL WAIT10MS
1489    E52A          8446     	MOV	A, RCP_TIMEOUT_CNTD				; Load RC pulse timeout counter value
148B    7005          8447     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      8448     
148D    307402        8449     JNB FLAGS2 . 4 , WAIT_FOR_POWER_ON_PPM_NOT_MISSING 
                      8450     
1490    410C          8451     	JMP	INIT_NO_SIGNAL					; If ppm and pulses missing - go back to detect input signal
                      8452     
                      8453     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
1492    7801          8454     MOV R0 , # 1 
1494    207402        8455     JB FLAGS2 . 4 , ( $+5 ) 
                      8456     
1497    7806          8457     MOV R0 , # ( RCP_STOP+5 ) 
                      8458     
1499    C3            8459     	CLR	C
149A    E55C          8460     	MOV	A, NEW_RCP			; Load new RC pulse value
149C    98            8461     SUBB A , R0 
149D    40A1          8462     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      8463     
                      8464     IF MODE >= 1	; Tail or multi
149F    7888          8465     MOV R0 , # PGM_DIRECTION 
14A1    E6            8466     MOV A , @ R0 
14A2    C3            8467     	CLR	C
14A3    9403          8468     	SUBB	A, #3
14A5    6003          8469     	JZ 	WAIT_FOR_POWER_ON_CHECK_TIMEOUT	; Do not wait if bidirectional operation
                      8470     ENDIF
                      8471     
14A7    1205F8        8472     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      8473     
                      8474     WAIT_FOR_POWER_ON_CHECK_TIMEOUT: 
14AA    E52A          8475     	MOV	A, RCP_TIMEOUT_CNTD		; Load RC pulse timeout counter value
14AC    7003          8476     	JNZ	($+5)				; If it is not zero - proceed
                      8477     
14AE    02120C        8478     	LJMP	INIT_NO_SIGNAL			; If it is zero (pulses missing) - go back to detect input signal
                      8479     
                      8480     
                      8481     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8482     ;
                      8483     ; Start entry point
                      8484     ;
                      8485     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8486     INIT_START: 
14B1    C2AF          8487     	CLR	EA
14B3    120F7D        8488     	CALL SWITCH_POWER_OFF
14B6    E4            8489     	CLR	A
14B7    F522          8490     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
14B9    F523          8491     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
14BB    F524          8492     	MOV	CURRENT_PWM, A			; Set current pwm to zero
14BD    F525          8493     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
14BF    F526          8494     	MOV	CURRENT_PWM_LIM_DITH, A
14C1    F567          8495     	MOV	PWM_DITHER_EXCESS_POWER, A
14C3    D2AF          8496     	SETB	EA
14C5    7885          8497     MOV R0 , # PGM_MOTOR_IDLE 
14C7    E6            8498     MOV A , @ R0 
14C8    C3            8499     	CLR	C
14C9    33            8500     	RLC	A
14CA    F565          8501     	MOV	PWM_MOTOR_IDLE, A
14CC    E4            8502     	CLR	A
14CD    F544          8503     	MOV	GOV_TARGET_L, A		; Set target to zero
14CF    F545          8504     	MOV	GOV_TARGET_H, A
14D1    F546          8505     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
14D3    F547          8506     	MOV	GOV_INTEGRAL_H, A
14D5    F548          8507     	MOV	GOV_INTEGRAL_X, A
14D7    F570          8508     	MOV	ADC_CONVERSION_CNT, A
14D9    F52C          8509     	MOV	FLAGS0, A				; Clear flags0
14DB    F52D          8510     	MOV	FLAGS1, A				; Clear flags1
14DD    F537          8511     	MOV	DEMAG_DETECTED_METRIC, A	; Clear demag metric
                      8512     	;**** **** **** **** ****
                      8513     	; Motor start beginning
                      8514     	;**** **** **** **** **** 
14DF    757008        8515     MOV ADC_CONVERSION_CNT , # 8 
                      8516     	SET_ADC_IP_TEMP
14E2    75BB10        8516+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
14E5    1205E4        8517     	CALL WAIT1MS
14E8    1208F6        8518     	CALL START_ADC_CONVERSION
                      8519     READ_INITIAL_TEMP: 
14EB    30EDFD        8520     	JNB	AD0INT, READ_INITIAL_TEMP
                      8521     	READ_ADC_RESULT						; Read initial temperature
14EE    A8BD          8521+1   MOV R0 , ADC0L 
14F0    A9BE          8521+1   MOV R1 , ADC0H 
14F2    E9            8522     MOV A , R1 
14F3    7001          8523     	JNZ	($+3)							; Is reading below 256?
                      8524     
14F5    F8            8525     MOV R0 , A 
                      8526     
14F6    8871          8527     MOV CURRENT_AVERAGE_TEMP , R0 
14F8    1208FA        8528     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
14FB    757008        8529     MOV ADC_CONVERSION_CNT , # 8 
                      8530     	SET_ADC_IP_TEMP
14FE    75BB10        8530+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      8531     	; Set up start operating conditions
1501    120FFE        8532     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
                      8533     	; Set max allowed power
1504    C2AF          8534     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
1506    7561FF        8535     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
1509    120990        8536     	CALL SET_STARTUP_PWM
150C    852261        8537     	MOV	PWM_LIMIT, REQUESTED_PWM
150F    852262        8538     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
1512    852263        8539     	MOV	PWM_LIMIT_BY_RPM, REQUESTED_PWM
1515    D2AF          8540     	SETB	EA
1517    752201        8541     	MOV	REQUESTED_PWM, #1			; Set low pwm again after calling set_startup_pwm
151A    752401        8542     	MOV	CURRENT_PWM, #1
151D    752501        8543     	MOV	CURRENT_PWM_LIMITED, #1	
1520    752601        8544     	MOV	CURRENT_PWM_LIM_DITH, #1
1523    856069        8545     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1526    756A01        8546     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      8547     	; Begin startup sequence
                      8548     IF MCU_48MHZ == 1
                      8549     	SET_MCU_CLK_48MHZ
1529    75B690        8549+1   MOV FLSCL , # 90H  ; SET FLASH TIMING FOR 48MHZ
152C    75A903        8549+1   MOV CLKSEL , # 3  ; SET CLOCK TO 48MHZ
152F    757A01        8549+1   MOV CLOCK_SET_AT_48MHZ , # 1 
                      8550     ENDIF
1532    7888          8551     MOV R0 , # PGM_DIRECTION 
1534    E6            8552     MOV A , @ R0 
1535    B40307        8553     	CJNE	A, #3, INIT_START_BIDIR_DONE
                      8554     
1538    C27D          8555     CLR FLAGS3 . 5 
153A    307602        8556     JNB FLAGS2 . 6 , ( $+5 ) 
153D    D27D          8557     SETB FLAGS3 . 5 
                      8558     
                      8559     INIT_START_BIDIR_DONE: 
153F    D268          8560     SETB FLAGS1 . 0 
1541    D269          8561     SETB FLAGS1 . 1 
1543    753300        8562     	MOV	STARTUP_CNT, #0			; Reset counter
1546    120ED7        8563     	CALL COMM5COMM6				; Initialize commutation
1549    120F06        8564     	CALL COMM6COMM1				
154C    1209B0        8565     	CALL INITIALIZE_TIMING			; Initialize timing
154F    1209B7        8566     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
1552    1209B0        8567     	CALL INITIALIZE_TIMING			; Initialize timing
1555    1209B7        8568     	CALL	CALC_NEXT_COMM_TIMING		
1558    1209B0        8569     	CALL	INITIALIZE_TIMING			; Initialize timing
                      8570     
                      8571     
                      8572     
                      8573     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8574     ;
                      8575     ; Run entry point
                      8576     ;
                      8577     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8578     
                      8579     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      8580     ; Out_cA changes from low to high
                      8581     RUN1: 
155B    120C43        8582     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
                      8583     ;	 	setup_comm_wait		; Setup wait time from zero cross to commutation
                      8584     ;	 	evaluate_comparator_integrity	; Check whether comparator reading has been normal
155E    120703        8585     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
1561    120D44        8586     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
1564    120D8B        8587     	CALL COMM1COMM2			; Commutate
1567    1209B7        8588     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
                      8589     ;	 	wait_advance_timing		; Wait advance timing and start zero cross wait
                      8590     ;	 	calc_new_wait_times
                      8591     ;	 	wait_before_zc_scan		; Wait zero cross wait and start zero cross timeout
                      8592     
                      8593     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      8594     ; Out_cB changes from high to low
                      8595     RUN2: 
156A    120C32        8596     	CALL WAIT_FOR_COMP_OUT_LOW
                      8597     ;	 	setup_comm_wait	
                      8598     ;		evaluate_comparator_integrity	
156D    306E03        8599     JNB FLAGS1 . 6 , ( $+6 ) 
1570    12075F        8600     	LCALL CALC_GOVERNOR_PROP_ERROR
1573    206603        8601     JB FLAGS0 . 6 , ( $+6 ) 
1576    1208AC        8602     	LCALL SET_PWM_LIMIT_LOW_RPM
1579    306603        8603     JNB FLAGS0 . 6 , ( $+6 ) 
157C    1208DC        8604     	LCALL SET_PWM_LIMIT_HIGH_RPM
157F    120D44        8605     	CALL WAIT_FOR_COMM
1582    120DBA        8606     	CALL COMM2COMM3
1585    1209B7        8607     	CALL CALC_NEXT_COMM_TIMING
                      8608     ;	 	wait_advance_timing
                      8609     ;	 	calc_new_wait_times
                      8610     ;	 	wait_before_zc_scan	
                      8611     
                      8612     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      8613     ; Out_cC changes from low to high
                      8614     RUN3: 
1588    120C43        8615     	CALL WAIT_FOR_COMP_OUT_HIGH
                      8616     ;	 	setup_comm_wait	
                      8617     ;	 	evaluate_comparator_integrity	
158B    306E03        8618     JNB FLAGS1 . 6 , ( $+6 ) 
158E    120794        8619     	LCALL CALC_GOVERNOR_INT_ERROR
1591    120D44        8620     	CALL WAIT_FOR_COMM
1594    120E31        8621     	CALL COMM3COMM4
1597    1209B7        8622     	CALL CALC_NEXT_COMM_TIMING
                      8623     ;	 	wait_advance_timing
                      8624     ;	 	calc_new_wait_times
                      8625     ;	 	wait_before_zc_scan	
                      8626     
                      8627     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      8628     ; Out_cA changes from high to low
                      8629     RUN4: 
159A    120C32        8630     	CALL WAIT_FOR_COMP_OUT_LOW
                      8631     ;	 	setup_comm_wait	
                      8632     ;	 	evaluate_comparator_integrity	
159D    306E03        8633     JNB FLAGS1 . 6 , ( $+6 ) 
15A0    1207F2        8634     	LCALL CALC_GOVERNOR_PROP_CORRECTION
15A3    120D44        8635     	CALL WAIT_FOR_COMM
15A6    120E60        8636     	CALL COMM4COMM5
15A9    1209B7        8637     	CALL CALC_NEXT_COMM_TIMING
                      8638     ;	 	wait_advance_timing
                      8639     ;	 	calc_new_wait_times
                      8640     ;	 	wait_before_zc_scan	
                      8641     
                      8642     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      8643     ; Out_cB changes from low to high
                      8644     RUN5: 
15AC    120C43        8645     	CALL WAIT_FOR_COMP_OUT_HIGH
                      8646     ;	 	setup_comm_wait	
                      8647     ;	 	evaluate_comparator_integrity	
15AF    306E03        8648     JNB FLAGS1 . 6 , ( $+6 ) 
15B2    120850        8649     	LCALL CALC_GOVERNOR_INT_CORRECTION
15B5    120D44        8650     	CALL WAIT_FOR_COMM
15B8    120ED7        8651     	CALL COMM5COMM6
15BB    1209B7        8652     	CALL CALC_NEXT_COMM_TIMING
                      8653     ;	 	wait_advance_timing
                      8654     ;	 	calc_new_wait_times
                      8655     ;	 	wait_before_zc_scan	
                      8656     
                      8657     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      8658     ; Out_cC changes from high to low
                      8659     RUN6: 
15BE    1208F6        8660     	CALL START_ADC_CONVERSION
15C1    120C32        8661     	CALL WAIT_FOR_COMP_OUT_LOW
                      8662     ;	 	setup_comm_wait	
                      8663     ;	 	evaluate_comparator_integrity	
15C4    120D44        8664     	CALL WAIT_FOR_COMM
15C7    120F06        8665     	CALL COMM6COMM1
15CA    1208FA        8666     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
15CD    1209B7        8667     	CALL CALC_NEXT_COMM_TIMING
                      8668     ;	 	wait_advance_timing
                      8669     ;	 	calc_new_wait_times
                      8670     ;	 	wait_before_zc_scan	
                      8671     
                      8672     	; Check if it is direct startup
15D0    306932        8673     JNB FLAGS1 . 1 , NORMAL_RUN_CHECKS 
                      8674     
                      8675     	; Set spoolup power variables
15D3    856461        8676     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
15D6    856462        8677     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
15D9    856069        8678     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
15DC    756A01        8679     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      8680     	; Check startup counter
15DF    7918          8681     MOV R1 , # 24 
15E1    7A0C          8682     MOV R2 , # 12 
15E3    C3            8683     	CLR	C
15E4    E533          8684     	MOV	A, STARTUP_CNT				; Load counter
15E6    99            8685     SUBB A , R1 
15E7    400F          8686     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      8687     
15E9    C269          8688     CLR FLAGS1 . 1 
15EB    D26A          8689     SETB FLAGS1 . 2 
15ED    8A35          8690     MOV INITIAL_RUN_ROT_CNTD , R2 
                      8691     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               ENDIF
                      8694     IF MODE == 2	; Multi
15EF    856461        8695     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG
15F2    856463        8696     	MOV	PWM_LIMIT_BY_RPM, PWM_SPOOLUP_BEG
                      8697     ENDIF
15F5    021605        8698     	JMP	NORMAL_RUN_CHECKS
                      8699     
                      8700     DIRECT_START_CHECK_RCP: 
15F8    C3            8701     	CLR	C
15F9    E55C          8702     	MOV	A, NEW_RCP				; Load new pulse value
15FB    9401          8703     SUBB A , # 1 
15FD    4003          8704     	JC	($+5)
                      8705     
15FF    02155B        8706     	LJMP	RUN1						; Continue to run 
                      8707     
1602    02168B        8708     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8709     
                      8710     
                      8711     NORMAL_RUN_CHECKS: 
                      8712     	; Check if it is initial run phase
1605    306A1D        8713     JNB FLAGS1 . 2 , INITIAL_RUN_PHASE_DONE 
1608    206C1A        8714     JB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      8715     
                      8716     	; Decrement startup rotaton count
160B    E535          8717     	MOV	A, INITIAL_RUN_ROT_CNTD
160D    14            8718     	DEC	A
                      8719     	; Check number of nondamped rotations
160E    7006          8720     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      8721     
1610    C26A          8722     CLR FLAGS1 . 2 
1612    D26B          8723     SETB FLAGS1 . 3 
1614    A15B          8724     	JMP RUN1						; Continue with normal run
                      8725     
                      8726     NORMAL_RUN_CHECK_STARTUP_ROT: 
1616    F535          8727     	MOV	INITIAL_RUN_ROT_CNTD, A		; Not zero - store counter
                      8728     
1618    C3            8729     	CLR	C
1619    E55C          8730     	MOV	A, NEW_RCP				; Load new pulse value
161B    9401          8731     SUBB A , # 1 
161D    4003          8732     	JC	($+5)
                      8733     
161F    02155B        8734     	LJMP	RUN1						; Continue to run 
                      8735     
1622    02168B        8736     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8737     
                      8738     INITIAL_RUN_PHASE_DONE: 
                      8739     	; Reset stall count
1625    753600        8740     	MOV	STALL_CNT, #0
                      8741     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      8754     	; Exit run loop after a given time
1628    78FA          8755     MOV R0 , # 250 
162A    79A4          8756     MOV R1 , # PGM_BRAKE_ON_STOP 
162C    E7            8757     MOV A , @ R1 
162D    6002          8758     	JZ	($+4)
                      8759     
162F    7803          8760     MOV R0 , # 3 
                      8761     
1631    C3            8762     	CLR	C
1632    E55F          8763     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
1634    98            8764     SUBB A , R0 
1635    5054          8765     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      8766     
1637    307404        8767     JNB FLAGS2 . 4 , RUN6_CHECK_DIR 
                      8768     
163A    E52A          8769     	MOV	A, RCP_TIMEOUT_CNTD			; Load RC pulse timeout counter value
163C    604D          8770     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      8771     
                      8772     RUN6_CHECK_DIR: 
                      8773     IF MODE >= 1	; Tail or multi
163E    7888          8774     MOV R0 , # PGM_DIRECTION 
1640    E6            8775     MOV A , @ R0 
1641    B40317        8776     	CJNE	A, #3, RUN6_CHECK_SPEED
                      8777     
1644    207D05        8778     JB FLAGS3 . 5 , RUN6_CHECK_DIR_REV 
1647    207607        8779     JB FLAGS2 . 6 , RUN6_CHECK_DIR_CHANGE 
164A    C15B          8780     	AJMP	RUN6_CHECK_SPEED
                      8781     
                      8782     RUN6_CHECK_DIR_REV: 
164C    307602        8783     JNB FLAGS2 . 6 , RUN6_CHECK_DIR_CHANGE 
164F    C15B          8784     	AJMP	RUN6_CHECK_SPEED
                      8785     
                      8786     RUN6_CHECK_DIR_CHANGE: 
1651    206C07        8787     JB FLAGS1 . 4 , RUN6_CHECK_SPEED 
                      8788     
1654    D26C          8789     SETB FLAGS1 . 4 
1656    856461        8790     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set max power while braking
1659    A19A          8791     	JMP	RUN4						; Go back to run 4, thereby changing force direction
                      8792     
                      8793     RUN6_CHECK_SPEED: 
                      8794     ENDIF
165B    78F0          8795     MOV R0 , # 0F0H 
165D    306C05        8796     JNB FLAGS1 . 4 , RUN6_BRAKE_DONE 
                      8797     
1660    856461        8798     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG 	; Set max power while braking
1663    7820          8799     MOV R0 , # 20H 
                      8800     
                      8801     RUN6_BRAKE_DONE: 
1665    C3            8802     	CLR	C
1666    E541          8803     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
1668    98            8804     SUBB A , R0 
1669    5002          8805     	JNC	($+4)					; Yes - stop or turn direction 
166B    A15B          8806     	AJMP	RUN1						; No - go back to run 1
                      8807     
                      8808     IF MODE >= 1	; Tail or multi
166D    306C1B        8809     JNB FLAGS1 . 4 , RUN_TO_WAIT_FOR_POWER_ON 
                      8810     
1670    C26C          8811     CLR FLAGS1 . 4 
1672    C27D          8812     CLR FLAGS3 . 5 
1674    307602        8813     JNB FLAGS2 . 6 , ( $+5 ) 
1677    D27D          8814     SETB FLAGS3 . 5 
1679    D26A          8815     SETB FLAGS1 . 2 
167B    753512        8816     	MOV	INITIAL_RUN_ROT_CNTD, #18
167E    856461        8817     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set initial max power
1681    A15B          8818     	AJMP	RUN1						; Go back to run 1 
                      8819     ENDIF
                      8820     
                      8821     RUN_TO_WAIT_FOR_POWER_ON_FAIL: 	
1683    0536          8822     	INC	STALL_CNT					; Increment stall count
1685    E55C          8823     	MOV	A, NEW_RCP				; Check if RCP is zero, then it is a normal stop			
1687    6002          8824     	JZ	RUN_TO_WAIT_FOR_POWER_ON
1689    C18E          8825     	AJMP	RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE
                      8826     
                      8827     RUN_TO_WAIT_FOR_POWER_ON: 	
168B    753600        8828     	MOV	STALL_CNT, #0
                      8829     
                      8830     RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE: 
168E    C2AF          8831     	CLR	EA
1690    120F7D        8832     	CALL SWITCH_POWER_OFF
1693    7887          8833     MOV R0 , # PGM_PWM_FREQ 
1695    E6            8834     MOV A , @ R0 
1696    FE            8835     MOV R6 , A 
1697    7602          8836     MOV @ R0 , # 2 
1699    120FFE        8837     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
169C    7887          8838     MOV R0 , # PGM_PWM_FREQ 
169E    EE            8839     MOV A , R6 
169F    F6            8840     MOV @ R0 , A 
16A0    E4            8841     	CLR	A
16A1    F522          8842     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
16A3    F523          8843     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
16A5    F524          8844     	MOV	CURRENT_PWM, A				; Set current pwm to zero
16A7    F525          8845     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
16A9    F526          8846     	MOV	CURRENT_PWM_LIM_DITH, A	
16AB    F565          8847     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
16AD    752C00        8848     	MOV	FLAGS0, #0				; Clear flags0
16B0    752D00        8849     	MOV	FLAGS1, #0				; Clear flags1
                      8850     IF MCU_48MHZ == 1
                      8851     	SET_MCU_CLK_24MHZ
16B3    75A900        8851+1   MOV CLKSEL , # 0  ; SET CLOCK TO 24MHZ
16B6    75B680        8851+1   MOV FLSCL , # 80H  ; SET FLASH TIMING FOR 24MHZ
16B9    757A00        8851+1   MOV CLOCK_SET_AT_48MHZ , # 0 
                      8852     ENDIF
16BC    D2AF          8853     	SETB	EA
16BE    1205F8        8854     	CALL	WAIT100MS					; Wait for pwm to be stopped
16C1    120F7D        8855     	CALL SWITCH_POWER_OFF
16C4    78A4          8856     MOV R0 , # PGM_BRAKE_ON_STOP 
16C6    E6            8857     MOV A , @ R0 
16C7    6006          8858     	JZ	RUN_TO_WAIT_FOR_POWER_ON_BRAKE_DONE
                      8859     
                      8860     	BRAKE_FETS_ON
                      8860+1   ANFET_ON 
16C9    D295          8860+2   SETB P1 . 5 
                      8860+1   BNFET_ON 
16CB    D297          8860+2   SETB P1 . 7 
                      8860+1   CNFET_ON 
16CD    D293          8860+2   SETB P1 . 3 
                      8861     
                      8862     RUN_TO_WAIT_FOR_POWER_ON_BRAKE_DONE: 
                      8863     IF MODE == 0	; Main
                               	JNB	FLAGS2.RCP_PPM, RUN_TO_NEXT_STATE_MAIN	; If flag is not set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNTD			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	INIT_NO_SIGNAL				; If it is zero (pulses missing) - go back to detect input signal
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      8883     IF MODE >= 1	; Tail or multi
16CF    307409        8884     JNB FLAGS2 . 4 , JMP_WAIT_FOR_POWER_ON 
                      8885     
16D2    C3            8886     	CLR	C
16D3    E536          8887     	MOV	A, STALL_CNT
16D5    9404          8888     	SUBB	A, #4
16D7    4002          8889     	JC	JMP_WAIT_FOR_POWER_ON
16D9    410C          8890     	JMP	INIT_NO_SIGNAL
                      8891     
                      8892     JMP_WAIT_FOR_POWER_ON: 
16DB    813B          8893     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      8894     ENDIF
                      8895     
                      8896     
                      8897     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8898     
                      8899     $INCLUDE (BLHELITXPGM.INC)			; Include source code for programming the ESC with the TX
                      9566     $INCLUDE (BLHELIBOOTLOAD.INC)			; Include source code for bootloader
                      9973     
                      9974     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      9975     
                      9976     
------                9977     CSEG AT 19FDH
                      9978     RESET: 
19FD    021160        9979     LJMP	PGM_START
                      9980     
                      9981     
                      9982     
                      9983     
                      9984     END
MACRO ASSEMBLER BLHELI                                      08/30/16 15:04:18 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

SET4 . . . . . . .  C ADDR   1CCEH   A 
ID3. . . . . . . .  C ADDR   1C55H   A 
BYTE_CNTH. . . . .  D ADDR   0028H   A 
CRCH . . . . . . .  D ADDR   0023H   A 
CMDL . . . . . . .    REG    R4             
XH . . . . . . . .    REG    R1             
NORMAL_RUN_CHECK_~  C ADDR   1616H   A 
DECODE_DEMAG_HIGH.  C ADDR   1071H   A 
COMM61_DAMP_REV. .  C ADDR   0F2CH   A 
COMM12_NFET_DONE .  C ADDR   0D9CH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0C31H   A 
CHECK_TEMP_VOLTAG~  C ADDR   08FAH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0877H   A 
GOVERNOR_CORR_NEG~  C ADDR   083FH   A 
PCA_INT_PPM_BELOW~  C ADDR   04CEH   A 
T2_INT_CURRENT_PW~  C ADDR   02C8H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
TIMER0_OVERFLOW_V~  D ADDR   0079H   A 
PPM_THROTTLE_GAIN.  D ADDR   0072H   A 
LIPO_ADC_LIMIT_H .  D ADDR   006FH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005EH   A 
RCP_EDGE_H . . . .  D ADDR   0058H   A 
FLAGS3 . . . . . .  D ADDR   002FH   A 
RCP_PREV_EDGE_L. .  D ADDR   0027H   A 
ADC_IP . . . . . .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
ALIGN_MR25_15A_MU~  N NUMB   010Bh            
DYS_XM20A_TAIL . .  N NUMB   00F8h            
POLARIS_THUNDER_4~  N NUMB   008Fh            
POLARIS_THUNDER_3~  N NUMB   008Dh            
POLARIS_THUNDER_1~  N NUMB   0087h            
SET5 . . . . . . .  C ADDR   1CD4H   A 
ID4. . . . . . . .  C ADDR   1C60H   A 
BOOT_START . . . .  N NUMB   1C00h            
FUNCTION_BEEP. . .  C ADDR   1870H   A 
INIT_START . . . .  C ADDR   14B1H   A 
PROGRAM_BY_TX_ENT~  C ADDR   1346H   A 
FIND_THROTTLE_GAI~  C ADDR   10A0H   A 
COMM45_NONDAMP . .  C ADDR   0EA6H   A 
COMM4COMM5 . . . .  C ADDR   0E60H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0A7BH   A 
SET_PWM_LIMIT_HIG~  C ADDR   08ECH   A 
PCA_INT_RESTORE_E~  C ADDR   0453H   A 
T2H_INT_RCP_STOP .  C ADDR   030DH   A 
T0_INT_PWM_OFF_DA~  C ADDR   011FH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006DH   A 
RANDOM . . . . . .  D ADDR   0068H   A 
PWM_MOTOR_IDLE . .  D ADDR   0065H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005DH   A 
COMM_PERIOD4X_H. .  D ADDR   0041H   A 
PWM_START. . . . .  N NUMB   0032h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
DYS_XM20A_MULTI. .  N NUMB   00F9h            
ZTW_SPIDER_PRO_20~  N NUMB   00EBh            
EMAX_NANO_20A_TAIL  N NUMB   00B3h            
PLATINUM_50AV3_TA~  N NUMB   00A1h            
PLATINUM_PRO_30A_~  N NUMB   009Ah            
POLARIS_THUNDER_4~  N NUMB   0090h            
H_KING_35A_TAIL. .  N NUMB   0080h            
SET6 . . . . . . .  C ADDR   1CDCH   A 
ID5. . . . . . . .  C ADDR   1C6DH   A 
ERRORPROG. . . . .  N NUMB   00C5h            
ERRORCRC . . . . .  N NUMB   00C2h            
BOOT_DELAY . . . .  N NUMB   5F5E10h            
PARAVAL_BEEP . . .  C ADDR   187EH   A 
STORE_MULTI_FUNC_~  C ADDR   17F7H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   16CFH   A 
COMM45_DAMP_REV. .  C ADDR   0E86H   A 
COMM23_NFET_DONE .  C ADDR   0E12H   A 
GOVERNOR_CHECK_PWM  C ADDR   07CDH   A 
GOVERNOR_ACTIVATE.  C ADDR   0728H   A 
PWM_AFET_DAMPED_D~  C ADDR   0161H   A 
EEP_PGM_BRAKE_ON_~  C ADDR   1A27H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
DEMAG_DETECTED_ME~  D ADDR   0037H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
SIGNATURE_001. . .  N NUMB   00F3h            
RTX_PORT . . . . .  N NUMB   0080h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
FLYCOLOR_RAPTOR_3~  N NUMB   00D6h            
EMAX_NANO_20A_MUL~  N NUMB   00B4h            
PLATINUM_50AV3_MU~  N NUMB   00A2h            
POLARIS_THUNDER_6~  N NUMB   0092h            
H_KING_35A_MULTI .  N NUMB   0081h            
TURNIGY_AE_25A_MA~  N NUMB   0043h            
TURNIGY_AE_20A_TA~  N NUMB   0041h            
TURNIGY_PLUSH_10A~  N NUMB   001Fh            
XP_35A_SW_TAIL . .  N NUMB   0014h            
GETC . . . . . . .  C ADDR   1D92H   A 
BIT_CNT. . . . . .  D ADDR   0026H   A 
BOOT_PAGES . . . .  N NUMB   0001h            
STORE_MULTI_FUNC_~  C ADDR   17FCH   A 
WRITE_EEPROM_SIGN~  C ADDR   1795H   A 
WAIT_FOR_POWER_ON.  C ADDR   143BH   A 
ERASE_AND_STORE_A~  C ADDR   171FH   A 
THROTTLE_LOW_CAL_~  C ADDR   13A6H   A 
ARMING_INITIAL_AR~  C ADDR   1329H   A 
PROGRAM_BY_TX_CHE~  C ADDR   1406H   A 
FIND_THROTTLE_GAI~  C ADDR   1099H   A 
SET_DEFAULT_PARAM~  C ADDR   0F92H   A 
COMM56_REV . . . .  C ADDR   0EF0H   A 
COMM5COMM6 . . . .  C ADDR   0ED7H   A 
COMM23_NFET_OFF_R~  C ADDR   0DF6H   A 
COMP_READ_WRONG_E~  C ADDR   0CB7H   A 
COMP_READ_OK . . .  C ADDR   0CF1H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0B1CH   A 
CALC_NEXT_COMM_TI~  C ADDR   09B7H   A 
CALC_GOVERNOR_TAR~  C ADDR   075EH   A 
BEEP_ANFET_OFF . .  C ADDR   065CH   A 
PCA_INT_STORE_DATA  C ADDR   0478H   A 
T2_INT_RCP_GAIN_P~  C ADDR   0246H   A 
T2_INT_RCP_UPDATE~  C ADDR   0208H   A 
PWM_BFET_DAMPED_D~  C ADDR   0172H   A 
RESET. . . . . . .  C ADDR   19FDH   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   00A5H   A 
PGM_ENABLE_TEMP_P~  I ADDR   00A0H   A 
_PGM_THROTTLE_RATE  I ADDR   009BH   A 
_PGM_STARTUP_RPM .  I ADDR   008FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   0062H   A 
RCP_PREPREV_EDGE_H  D ADDR   0056H   A 
WT_ZC_SCAN_START_L  D ADDR   004FH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0003h            
STARTUP_PHASE. . .  N NUMB   0001h            
RCP_SKIP_CNTD. . .  D ADDR   002BH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
SIGNATURE_002. . .  N NUMB   0090h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
ZTW_SPIDER_PRO_20~  N NUMB   00F2h            
FLYCOLOR_FAIRY_6A~  N NUMB   00CBh            
POLARIS_THUNDER_6~  N NUMB   0093h            
SKYWALKER_20A_MAIN  N NUMB   0058h            
TURNIGY_AE_30A_TA~  N NUMB   0047h            
TURNIGY_AE_20A_MU~  N NUMB   0042h            
XP_35A_SW_MULTI. .  N NUMB   0015h            
XP_7A_MAIN . . . .  N NUMB   0004h            
PRO3 . . . . . . .  C ADDR   1D0AH   A 
BOOT_SIGN. . . . .  C ADDR   1DE9H   A 
BYTE_CNTL. . . . .  D ADDR   0027H   A 
BAUDH. . . . . . .  D ADDR   0025H   A 
CRCL . . . . . . .  D ADDR   0022H   A 
XL . . . . . . . .    REG    R0             
FUNCTION_NEXT. . .  C ADDR   18E9H   A 
THROTTLE_HIGH_CAL.  C ADDR   1373H   A 
COMM61_NFET_DONE .  C ADDR   0F5EH   A 
COMM34_NFET_DONE .  C ADDR   0E42H   A 
STORE_TIMES_INCRE~  C ADDR   0BD9H   A 
CALC_NEXT_COMM_NO~  C ADDR   0A2EH   A 
STARTUP_PWM_SET_P~  C ADDR   09A5H   A 
PWM_CFET_DAMPED_D~  C ADDR   0183H   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
LIPO_ADC_LIMIT_L .  D ADDR   006EH   A 
RCP_EDGE_L . . . .  D ADDR   0057H   A 
STALL_CNT. . . . .  D ADDR   0036H   A 
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
RTX_PIN. . . . . .  N NUMB   0005h            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
ZTW_SPIDER_PRO_30~  N NUMB   00F5h            
ZTW_SPIDER_PRO_20~  N NUMB   00F3h            
ZTW_SPIDER_PRO_20~  N NUMB   00EFh            
FVT_LITTLEBEE_20A~  N NUMB   00E0h            
FLYCOLOR_FAIRY_6A~  N NUMB   00CCh            
POLARIS_THUNDER_8~  N NUMB   0095h            
TURNIGY_KFORCE_12~  N NUMB   0053h            
TURNIGY_AE_45A_MA~  N NUMB   0049h            
TURNIGY_AE_30A_MU~  N NUMB   0048h            
TURNIGY_PLUSH_30A~  N NUMB   002Bh            
TURNIGY_PLUSH_12A~  N NUMB   0022h            
XP_3A_TAIL . . . .  N NUMB   0002h            
PRO4 . . . . . . .  C ADDR   1D16H   A 
MAIN . . . . . . .  C ADDR   1C7FH   A 
PARAVAL_NEXT . . .  C ADDR   18D4H   A 
WRITE_EEPROM_BYTE.  C ADDR   1765H   A 
TEST_FOR_ONESHOT .  C ADDR   12DFH   A 
MEASURE_PWM_FREQ_~  C ADDR   128CH   A 
COMM61_NFET_OFF_R~  C ADDR   0F42H   A 
COMM_EXIT. . . . .  C ADDR   0F7AH   A 
CALC_GOVERNOR_INT~  C ADDR   0850H   A 
BEEP_CNFET_OFF . .  C ADDR   0661H   A 
BEEP_ANFET_ON. . .  C ADDR   064CH   A 
PCA_INT_PPM_CHECK~  C ADDR   04EFH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0583H   A 
PCA_INT_FALL_CHEC~  C ADDR   04C0H   A 
PCA_INT_LIMITED. .  C ADDR   05A6H   A 
T2H_INT_START. . .  C ADDR   02F3H   A 
T2_INT_PWM_UPDATE.  C ADDR   024DH   A 
T0_INT_PWM_OFF_DA~  C ADDR   010AH   A 
EEP_DUMMY. . . . .  C ADDR   1A28H   A 
EEP_PGM_ENABLE_PW~  C ADDR   1A25H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A13H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
CLOCK_SET_AT_48MHZ  D ADDR   007AH   A 
COMM_PERIOD4X_L. .  D ADDR   0040H   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
RTX_MDIN . . . . .  N NUMB   00F1h            
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0002h            
ZTW_SPIDER_PRO_30~  N NUMB   00F6h            
ZTW_SPIDER_PRO_20~  N NUMB   00F0h            
FVT_LITTLEBEE_20A~  N NUMB   00E1h            
POLARIS_THUNDER_8~  N NUMB   0096h            
SKYWALKER_40A_MAIN  N NUMB   005Bh            
TURNIGY_KFORCE_12~  N NUMB   0054h            
TURNIGY_PLUSH_40A~  N NUMB   002Eh            
SUPERMICRO_3P5A_M~  N NUMB   0019h            
XP_3A_MULTI. . . .  N NUMB   0003h            
WAIT1. . . . . . .  C ADDR   1DE2H   A 
PRO5 . . . . . . .  C ADDR   1D1CH   A 
FUNC_PARAVAL_WAIT.  C ADDR   189CH   A 
WRITE_TAG. . . . .  C ADDR   17BEH   A 
READ_EEPROM_STORE~  C ADDR   16F6H   A 
RUN6_CHECK_DIR . .  C ADDR   163EH   A 
RUN1 . . . . . . .  C ADDR   155BH   A 
WAIT_FOR_POWER_ON~  C ADDR   14AAH   A 
MEASURE_PWM_FREQ_~  C ADDR   129DH   A 
CLEAR_RAM. . . . .  C ADDR   11D4H   A 
SET_BEC_VOLTAGE. .  C ADDR   1085H   A 
DECODE_DEMAG_DONE.  C ADDR   1077H   A 
COMM45_NFET_DONE .  C ADDR   0EB8H   A 
WAIT_FOR_COMM. . .  C ADDR   0D44H   A 
ADJUST_TIMING_TWO~  C ADDR   0BCCH   A 
CALC_GOVERNOR_PRO~  C ADDR   0793H   A 
DIV_U16_BY_U16_DI~  C ADDR   067CH   A 
WAIT100MS. . . . .  C ADDR   05F8H   A 
WAIT1MS. . . . . .  C ADDR   05E4H   A 
T0_INT_PWM_OFF_TI~  C ADDR   00F0H   A 
T0_INT_PWM_OFF_SE~  C ADDR   00EEH   A 
STARTUP_POWER_TAB~  C ADDR   008DH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
FLASH_KEY_1. . . .  D ADDR   007CH   A 
SKIP_T2_INT. . . .  D ADDR   0077H   A 
TX_PGM_BEEP_NO . .  D ADDR   0076H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   006AH   A 
WT_ZC_TOUT_START_H  D ADDR   0052H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
RTX_MDOUT. . . . .  N NUMB   00A4h            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
HTIRC_HUMMINGBIRD~  N NUMB   011Bh            
SERVOKING_MONSTER~  N NUMB   010Ch            
ZTW_SPIDER_PRO_20~  N NUMB   00ECh            
PLATINUM_PRO_30A_~  N NUMB   009Bh            
TURNIGY_KFORCE_12~  N NUMB   0055h            
RD1. . . . . . . .  C ADDR   1D3DH   A 
PRO6 . . . . . . .  C ADDR   1D33H   A 
ABD. . . . . . . .  C ADDR   1C2EH   A 
FUNCTION_PARAVAL_~  C ADDR   186AH   A 
STORE_NEW_VALUE_I~  C ADDR   17C6H   A 
RUN2 . . . . . . .  C ADDR   156AH   A 
ARMING_PPM_CHECK .  C ADDR   1333H   A 
COMM45_NFET_OFF_R~  C ADDR   0E9CH   A 
COMM23_FETS_DONE .  C ADDR   0DD8H   A 
COMP_READ_WRONG_T~  C ADDR   0CCAH   A 
STORE_TIMES_EXIT .  C ADDR   0BB1H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0BE7H   A 
CHECK_VOLTAGE_PWM~  C ADDR   0987H   A 
GOVERNOR_CORR_INT~  C ADDR   0896H   A 
GOVERNOR_STORE_PR~  C ADDR   078FH   A 
DIV_U16_BY_U16_DI~  C ADDR   0686H   A 
BEEP_CNFET_ON. . .  C ADDR   0651H   A 
WAIT200MS. . . . .  C ADDR   05FDH   A 
T2_INT_RCP_GAIN_C~  C ADDR   023DH   A 
T2_INT_CURRENT_PW~  C ADDR   0277H   A 
T2_INT_PULSES_ABS~  C ADDR   01B3H   A 
T0_INT_PWM_ON_RET.  C ADDR   00D8H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_MAIN_SPOOLUP_~  I ADDR   009FH   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
FLASH_KEY_2. . . .  D ADDR   007DH   A 
RCP_PREPREV_EDGE_L  D ADDR   0055H   A 
GOV_ACTIVE . . . .  N NUMB   0006h            
MOTOR_STARTED. . .  N NUMB   0003h            
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
OVERSKY_MR_20A_PR~  N NUMB   00FDh            
ZTW_SPIDER_PRO_20~  N NUMB   00EDh            
FLYCOLOR_RAPTOR_3~  N NUMB   00D7h            
FLYCOLOR_RAPTOR_2~  N NUMB   00D3h            
PLATINUM_PRO_30A_~  N NUMB   009Ch            
TURNIGY_AE_25A_TA~  N NUMB   0044h            
TURNIGY_PLUSH_60A~  N NUMB   0031h            
TURNIGY_PLUSH_10A~  N NUMB   0020h            
MAI1 . . . . . . .  C ADDR   1C81H   A 
IN1. . . . . . . .  C ADDR   1C77H   A 
BAUDL. . . . . . .  D ADDR   0024H   A 
RUN3 . . . . . . .  C ADDR   1588H   A 
COMM56_NFET_DONE .  C ADDR   0EE8H   A 
COMP_CHECK_TIMEOU~  C ADDR   0C8DH   A 
GOVERNOR_LIMIT_IN~  C ADDR   087EH   A 
GOVERNOR_CHECK_IN~  C ADDR   07B5H   A 
DIV_U16_BY_U16_DI~  C ADDR   069DH   A 
WAIT3MS. . . . . .  C ADDR   05E9H   A 
T2_INT_PULSES_ABS~  C ADDR   01E8H   A 
T0_INT_PWM_ON_TIM~  C ADDR   00D6H   A 
T0_INT_PWM_ON_SET~  C ADDR   00D4H   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0047H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
RCP_PPM_ONESHOT125  N NUMB   0005h            
DIR_CHANGE_BRAKE .  N NUMB   0004h            
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
FLYCOLOR_RAPTOR_3~  N NUMB   00D8h            
POLARIS_THUNDER_1~  N NUMB   0097h            
SKYWALKER_20A_TAIL  N NUMB   0059h            
TURNIGY_AE_25A_MU~  N NUMB   0045h            
TURNIGY_PLUSH_25A~  N NUMB   0028h            
TURNIGY_PLUSH_10A~  N NUMB   0021h            
XP_7A_TAIL . . . .  N NUMB   0005h            
PUTP . . . . . . .  C ADDR   1D53H   A 
SETBUF . . . . . .  C ADDR   1CC8H   A 
MAI2 . . . . . . .  C ADDR   1CA3H   A 
ERRORCOMMAND . . .  N NUMB   00C1h            
BEEP_NO_ENTRY. . .  C ADDR   1895H   A 
JMP_WAIT_FOR_POWE~  C ADDR   16DBH   A 
DIRECT_START_CHEC~  C ADDR   15F8H   A 
RUN4 . . . . . . .  C ADDR   159AH   A 
WAIT_US_100_M1 . .  C ADDR   1108H   A 
COMM61_FETS_DONE .  C ADDR   0F24H   A 
COMM23_NONDAMP_REV  C ADDR   0E1AH   A 
COMP_READ_OK_JMP .  C ADDR   0D03H   A 
STORE_TIMES_UP_OR~  C ADDR   0B7CH   A 
STORE_TIMES_DECRE~  C ADDR   0B90H   A 
CALC_NEXT_COMM_NE~  C ADDR   0A60H   A 
TEMP_AVERAGE_INC .  C ADDR   0932H   A 
GOVERNOR_CORR_INT~  C ADDR   08A7H   A 
MULT_S16_BY_U8_DI~  C ADDR   06ACH   A 
BEEP_START . . . .  C ADDR   062FH   A 
PCA_INT_PPM_NEG_C~  C ADDR   0543H   A 
T2_INT_EXIT. . . .  C ADDR   02D5H   A 
_EEP_PGM_DAMPING_~  C ADDR   1A16H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
PGM_BRAKE_ON_STOP.  I ADDR   00A4H   A 
PWM_DITHER_EXCESS~  D ADDR   0067H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
SKYWALKER_20A_MUL~  N NUMB   005Ah            
TURNIGY_AE_45A_TA~  N NUMB   004Ah            
TURNIGY_PLUSH_80A~  N NUMB   0034h            
TURNIGY_PLUSH_30A~  N NUMB   002Ch            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
XP_7A_MULTI. . . .  N NUMB   0006h            
PUT1 . . . . . . .  C ADDR   1D59H   A 
READ_TAGS. . . . .  C ADDR   17A4H   A 
RUN5 . . . . . . .  C ADDR   15ACH   A 
WAIT_US_100_M2 . .  C ADDR   112FH   A 
COMP_SCALE_SAMPLES  C ADDR   0C78H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0AD2H   A 
SET_PWM_LIMIT_HIG~  C ADDR   08DCH   A 
GOVERNOR_CORR_NEG~  C ADDR   089BH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0784H   A 
GOVERNOR_TARGET_C~  C ADDR   070BH   A 
CALC_GOVERNOR_TAR~  C ADDR   0703H   A 
PCA_INT_PWM_DIVID~  C ADDR   058AH   A 
PCA_INT_CHECK_12K~  C ADDR   03F7H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   0073H   A 
RCP_PREV_PERIOD_H.  D ADDR   005AH   A 
WT_COMM_START_H. .  D ADDR   0054H   A 
WT_ZC_TOUT_START_L  D ADDR   0051H   A 
TIMER2_X . . . . .  D ADDR   003AH   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ANFET_ON . . . . .  ? ADDR   0000H   A 
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
F85_3A_MAIN. . . .  N NUMB   00E8h            
SKYWALKER_40A_TAIL  N NUMB   005Ch            
TURNIGY_AE_45A_MU~  N NUMB   004Bh            
TURNIGY_PLUSH_40A~  N NUMB   002Fh            
TURNIGY_PLUSH_30A~  N NUMB   002Dh            
TURNIGY_PLUSH_18A~  N NUMB   0025h            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
SUPERMICRO_3P5A_T~  N NUMB   001Ah            
PUT2 . . . . . . .  C ADDR   1D6CH   A 
MAI4 . . . . . . .  C ADDR   1CDFH   A 
BAUDTIME . . . . .  N NUMB   0198h            
RUN6_CHECK_DIR_CH~  C ADDR   1651H   A 
RUN6 . . . . . . .  C ADDR   15BEH   A 
ARMING_START . . .  C ADDR   1313H   A 
MEASURE_PWM_FREQ_~  C ADDR   1292H   A 
WAIT_US_100_M3 . .  C ADDR   1156H   A 
COMM61_NONDAMP_REV  C ADDR   0F66H   A 
COMM45_FETS_DONE .  C ADDR   0E7EH   A 
COMP_CHECK_TIMEOU~  C ADDR   0C93H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0BEFH   A 
GOVERNOR_DEACTIVA~  C ADDR   0715H   A 
PCA_INT_CHECK_LEG~  C ADDR   059BH   A 
PCA_INT_FALL_NOT_~  C ADDR   04A1H   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
PREV_PREV_COMM_H .  D ADDR   003FH   A 
RCP_UPDATED. . . .  N NUMB   0000h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
BNFET_ON . . . . .  ? ADDR   0000H   A 
DEFAULT_PGM_MAIN_~  N NUMB   000Ah            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
HTIRC_HUMMINGBIRD~  N NUMB   011Ch            
SERVOKING_MONSTER~  N NUMB   0112h            
SERVOKING_MONSTER~  N NUMB   010Dh            
FLYCOLOR_FAIRY_30~  N NUMB   00CDh            
ROTORGEEKS_20A_MA~  N NUMB   00C4h            
ALIGN_RCE_BL15P_M~  N NUMB   006Dh            
SKYWALKER_40A_MUL~  N NUMB   005Dh            
TURNIGY_KFORCE_12~  N NUMB   0056h            
TURNIGY_PLUSH_40A~  N NUMB   0030h            
SUPERMICRO_3P5A_M~  N NUMB   001Bh            
DP_3A_MAIN . . . .  N NUMB   0016h            
PUT3 . . . . . . .  C ADDR   1D78H   A 
MAI5 . . . . . . .  C ADDR   1D38H   A 
WAIT_FOR_LOW . . .  C ADDR   1C45H   A 
PARAH. . . . . . .    REG    R3             
PROGRAM_BY_TX_ENT~  C ADDR   13E6H   A 
ARM_TARGET_UPDATED  C ADDR   1416H   A 
COMM12_NFET_DONE_~  C ADDR   0DB2H   A 
EVALUATE_COMPARAT~  C ADDR   0D25H   A 
TEMP_CHECK_EXIT. .  C ADDR   095CH   A 
GOVERNOR_APPLY_PR~  C ADDR   0826H   A 
PWM_AFET_EXIT. . .  C ADDR   013EH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_PWM_IN~  I ADDR   00A2H   A 
_PGM_STARTUP_ACCEL  I ADDR   0090H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0046H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CNFET_ON . . . . .  ? ADDR   0000H   A 
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
HTIRC_HUMMINGBIRD~  N NUMB   011Dh            
SERVOKING_MONSTER~  N NUMB   010Eh            
OVERSKY_MR_20A_PR~  N NUMB   00FEh            
FLYCOLOR_RAPTOR_2~  N NUMB   00D4h            
TURNIGY_KFORCE_12~  N NUMB   0057h            
TURNIGY_PLUSH_60A~  N NUMB   0032h            
PUT4 . . . . . . .  C ADDR   1D8AH   A 
MAI6 . . . . . . .  C ADDR   1D49H   A 
CNTH . . . . . . .    REG    R7             
WRITE_EEPROM_BLOC~  C ADDR   1742H   A 
NORMAL_RUN_CHECKS.  C ADDR   1605H   A 
INIT_NO_SIGNAL . .  C ADDR   120CH   A 
WAIT_MS_1_M_M1 . .  C ADDR   10FEH   A 
COMM45_NONDAMP_REV  C ADDR   0EC0H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0C51H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0B20H   A 
CALC_NEW_WAIT_PER~  C ADDR   0A8AH   A 
CALC_GOVERNOR_PRO~  C ADDR   075FH   A 
PCA_INT_PPM_UNIDI~  C ADDR   053DH   A 
T2_INT_PPM_TIMEOU~  C ADDR   01F4H   A 
PWM_BFET_EXIT. . .  C ADDR   0148H   A 
T0_INT_PWM_OFF_EX~  C ADDR   00FDH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_BRAKE~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_COM . . . . .  N NUMB   0003h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
OVERSKY_MR_20A_PR~  N NUMB   00FFh            
FLYCOLOR_RAPTOR_2~  N NUMB   00D5h            
POLARIS_THUNDER_1~  N NUMB   0098h            
ALIGN_RCE_BL35P_M~  N NUMB   0073h            
TURNIGY_PLUSH_60A~  N NUMB   0033h            
TURNIGY_PLUSH_25A~  N NUMB   0029h            
POLYNOM. . . . . .  N NUMB   A001h            
WRITE_EEPROM_BLOC~  C ADDR   1750H   A 
PROGRAM_BY_TX_ENT~  C ADDR   13F5H   A 
READ_ALL_EEPROM_P~  C ADDR   16DDH   A 
WAIT_MS_1_M_M2 . .  C ADDR   1125H   A 
COMM23_NFET_DONE_~  C ADDR   0E29H   A 
SETUP_ZC_SCAN_TIM~  C ADDR   0C16H   A 
CALC_NEXT_COMM_NE~  C ADDR   0A69H   A 
CALC_NEXT_COMM_ST~  C ADDR   09F0H   A 
CHECK_VOLTAGE_LOW~  C ADDR   097BH   A 
PWM_CFET_EXIT. . .  C ADDR   0152H   A 
T0_INT . . . . . .  C ADDR   00AAH   A 
_EEP_PGM_STARTUP_~  C ADDR   1A18H   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
SKIP_T2H_INT . . .  D ADDR   0078H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006BH   A 
RCP_STOP_CNT . . .  D ADDR   005FH   A 
NEW_RCP. . . . . .  D ADDR   005CH   A 
RCP_PREV_PERIOD_L.  D ADDR   0059H   A 
WT_COMM_START_L. .  D ADDR   0053H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
INITIAL_RUN_PHASE.  N NUMB   0002h            
HIGH_RPM . . . . .  N NUMB   0006h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00F0h            
DEBUGPIN . . . . .  N NUMB   0000h            
ANFET. . . . . . .  N NUMB   0005h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
TBS_CUBE_12A_MAIN.  N NUMB   0100h            
ROTORGEEKS_20A_PL~  N NUMB   00C7h            
POLARIS_THUNDER_1~  N NUMB   0099h            
TURNIGY_PLUSH_80A~  N NUMB   0035h            
TURNIGY_PLUSH_25A~  N NUMB   002Ah            
INIT_START_BIDIR_~  C ADDR   153FH   A 
WAIT_MS_1_M_M3 . .  C ADDR   114CH   A 
WAIT_MS_1_O_M1 . .  C ADDR   10FCH   A 
EVAL_COMP_EXIT . .  C ADDR   0D43H   A 
PCA_INT_SET_TIMEO~  C ADDR   05BEH   A 
PWM_NOFET. . . . .  C ADDR   0134H   A 
EEP_PGM_PWM_DITHER  C ADDR   1A26H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
PREV_PREV_COMM_L .  D ADDR   003EH   A 
PREV_COMM_H. . . .  D ADDR   003CH   A 
RCP_DIR_REV. . . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0007h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
F85_3A_TAIL. . . .  N NUMB   00E9h            
FVT_LITTLEBEE_20A~  N NUMB   00DCh            
MDRX62H_MAIN . . .  N NUMB   00C1h            
TURNIGY_PLUSH_80A~  N NUMB   0036h            
TURNIGY_PLUSH_18A~  N NUMB   0026h            
XP_12A_MAIN. . . .  N NUMB   000Ah            
PUTW . . . . . . .  C ADDR   1D4BH   A 
PARAL. . . . . . .    REG    R2             
BOOTLOADER_DONE. .  C ADDR   1222H   A 
WAIT_MS_1_O_M2 . .  C ADDR   1123H   A 
AVERAGE_THROTTLE .  C ADDR   10BDH   A 
DECODE_PARAMS_DIR~  C ADDR   1019H   A 
COMM61_NFET_DONE_~  C ADDR   0F75H   A 
COMM34_NFET_DONE_~  C ADDR   0E58H   A 
SETUP_COMM_WAIT. .  C ADDR   0D07H   A 
CALC_NEXT_COMM_TI~  C ADDR   0AD4H   A 
CALC_GOVERNOR_INT~  C ADDR   07F1H   A 
T2_INT . . . . . .  C ADDR   0187H   A 
_PGM_DAMPING_FORCE  I ADDR   0093H   A 
AUTO_BAILOUT_ARMED  D ADDR   0060H   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0004h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
SERVOKING_MONSTER~  N NUMB   0113h            
F85_3A_MULTI . . .  N NUMB   00EAh            
FVT_LITTLEBEE_30A~  N NUMB   00E2h            
FVT_LITTLEBEE_12A~  N NUMB   00D9h            
FLYCOLOR_FAIRY_30~  N NUMB   00CEh            
ROTORGEEKS_20A_TA~  N NUMB   00C5h            
ALIGN_RCE_BL15P_T~  N NUMB   006Eh            
RCTIMER_6A_MAIN. .  N NUMB   0067h            
TURNIGY_PLUSH_NFE~  N NUMB   003Dh            
TURNIGY_PLUSH_18A~  N NUMB   0027h            
DP_3A_TAIL . . . .  N NUMB   0017h            
XP_7A_FAST_MAIN. .  N NUMB   0007h            
GET1 . . . . . . .  C ADDR   1D97H   A 
BYTE_REG . . . . .  D ADDR   0021H   A 
CNTL . . . . . . .    REG    R6             
ARM_END_BEEP . . .  C ADDR   142BH   A 
THROTTLE_HIGH_CAL~  C ADDR   1371H   A 
PGM_START. . . . .  C ADDR   1160H   A 
WAIT_MS_1_O_M3 . .  C ADDR   114AH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0C32H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0B30H   A 
LOAD_MIN_TIME. . .  C ADDR   0ACEH   A 
SET_STARTUP_PWM. .  C ADDR   0990H   A 
GOVERNOR_STORE_IN~  C ADDR   07EBH   A 
GOVERNOR_ACTIVATE~  C ADDR   0751H   A 
T2H_INT_EXIT . . .  C ADDR   031EH   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   0328H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0075H   A 
ADC_CONVERSION_CNT  D ADDR   0070H   A 
GOV_ARM_TARGET . .  D ADDR   004CH   A 
RCP_PPM. . . . . .  N NUMB   0004h            
RCP_OUTSIDE_RANGE~  D ADDR   0029H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0006h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
SERVOKING_MONSTER~  N NUMB   0114h            
GRAUPNER_ULTRA_20~  N NUMB   00E5h            
FLYCOLOR_FAIRY_30~  N NUMB   00CFh            
ROTORGEEKS_20A_MU~  N NUMB   00C6h            
EMAX_20A_MAIN. . .  N NUMB   00ACh            
TAROT_30A_MAIN . .  N NUMB   00A6h            
ALIGN_RCE_BL15P_M~  N NUMB   006Fh            
DP_3A_MULTI. . . .  N NUMB   0018h            
GET2 . . . . . . .  C ADDR   1DACH   A 
FUNC_PARAVAL . . .  C ADDR   1898H   A 
WAIT1S_LOOP. . . .  C ADDR   1806H   A 
STORE_MULTI_FUNC_1  C ADDR   17CAH   A 
RUN6_CHECK_DIR_REV  C ADDR   164CH   A 
MUSIC_F1_BEEP. . .  C ADDR   10EDH   A 
AVERAGE_THROTTLE_~  C ADDR   10DCH   A 
COMP_CHECK_TIMEOUT  C ADDR   0C80H   A 
CALC_GOVERNOR_PRO~  C ADDR   084FH   A 
GOVERNOR_INT_MIN_~  C ADDR   07E6H   A 
GOVERNOR_LIMIT_PR~  C ADDR   078BH   A 
BEEP_F1. . . . . .  C ADDR   060DH   A 
PCA_INT_PPM_OUTSI~  C ADDR   04D7H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   0071H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0064H   A 
PWM_LIMIT. . . . .  D ADDR   0061H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
FLYCOLOR_FAIRY_V2~  N NUMB   00D0h            
ALIGN_RCE_BL35P_T~  N NUMB   0074h            
GET3 . . . . . . .  C ADDR   1DD0H   A 
BL_FLASH_KEY_1 . .  D ADDR   0029H   A 
STORE_MULTI_FUNC_2  C ADDR   17CFH   A 
INITIAL_RUN_PHASE~  C ADDR   1625H   A 
MUSIC_F2_BEEP. . .  C ADDR   1114H   A 
TEST_THROTTLE_GAIN  C ADDR   10AEH   A 
COMM23_FETS_DONE_~  C ADDR   0DF8H   A 
GOVERNOR_STORE_PR~  C ADDR   084DH   A 
GOVERNOR_CHECK_PR~  C ADDR   0811H   A 
MULT_S16_BY_U8_PO~  C ADDR   06C6H   A 
DIV_U16_BY_U16 . .  C ADDR   0674H   A 
BEEP_ONOFF . . . .  C ADDR   0631H   A 
BEEP_F2. . . . . .  C ADDR   0614H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0524H   A 
PCA_INT_CHECK_DIFF  C ADDR   046BH   A 
T2_INT_SKIP_START.  C ADDR   01F8H   A 
PWM_AFET . . . . .  C ADDR   0136H   A 
T0_INT_PWM_OFF_FU~  C ADDR   0126H   A 
EEP_PGM_ENABLE_PO~  C ADDR   1A24H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0015h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
PREV_COMM_L. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNTD .  D ADDR   002AH   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
TBS_CUBE_12A_TAIL.  N NUMB   0101h            
ROTORGEEKS_20A_PL~  N NUMB   00C8h            
XROTOR_10A_MAIN. .  N NUMB   00B8h            
EMAX_40A_MAIN. . .  N NUMB   00AFh            
ALIGN_RCE_BL35P_M~  N NUMB   0075h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ah            
TURNIGY_KFORCE_70~  N NUMB   004Fh            
TURNIGY_KFORCE_40~  N NUMB   004Ch            
XP_25A_MAIN. . . .  N NUMB   0010h            
INIT . . . . . . .  C ADDR   1C00H   A 
BL_FLASH_KEY_2 . .  D ADDR   002AH   A 
PARAVAL_NO_ENTRY .  C ADDR   1892H   A 
STORE_MULTI_FUNC_3  C ADDR   17D4H   A 
RUN6_BRAKE_DONE. .  C ADDR   1665H   A 
SUCCESS_BEEP_INVE~  C ADDR   183BH   A 
SUCCESS_BEEP . . .  C ADDR   180CH   A 
MUSIC_F3_BEEP. . .  C ADDR   113BH   A 
FIND_THROTTLE_GAIN  C ADDR   1086H   A 
DECODE_SETTINGS. .  C ADDR   1037H   A 
COMM56_NFET_DONE_~  C ADDR   0EFEH   A 
RUN_TO_WAIT_FOR_P~  C ADDR   1683H   A 
TEMP_AVERAGE_INC_~  C ADDR   0922H   A 
GOVERNOR_INT_MAX_~  C ADDR   07DEH   A 
GOVERNOR_LIMIT_IN~  C ADDR   07BEH   A 
BEEP_F3. . . . . .  C ADDR   061BH   A 
PCA_INT_FAIL_MINI~  C ADDR   0384H   A 
PWM_BFET . . . . .  C ADDR   0140H   A 
T0_INT_PWM_OFF_EX~  C ADDR   011FH   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0069H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
SKIP_DAMP_ON . . .  N NUMB   0007h            
P1_INIT. . . . . .  N NUMB   0001h            
RTX_SKIP . . . . .  N NUMB   00D4h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
TBS_CUBE_12A_MULTI  N NUMB   0102h            
FVT_LITTLEBEE_20A~  N NUMB   00DDh            
ROTORGEEKS_20A_PL~  N NUMB   00C9h            
MDRX62H_TAIL . . .  N NUMB   00C2h            
XROTOR_20A_MAIN. .  N NUMB   00BBh            
EMAX_LIGHTNING_20~  N NUMB   00B5h            
PLATINUM_PRO_150A~  N NUMB   009Dh            
TURNIGY_PLUSH_NFE~  N NUMB   003Ah            
XP_12A_TAIL. . . .  N NUMB   000Bh            
UART_LOOP. . . . .  N NUMB   001Ah            
STORE_MULTI_FUNC_4  C ADDR   17D9H   A 
BEEP_DELAY_SET . .  C ADDR   1463H   A 
PROGRAM_BY_TX_ENT~  C ADDR   1357H   A 
LOCK_BYTE_OK . . .  C ADDR   1185H   A 
AVERAGE_THROTTLE_~  C ADDR   10CDH   A 
DECODE_PWM_FREQ_L~  C ADDR   1031H   A 
COMM61_FETS_DONE_~  C ADDR   0F44H   A 
COMP_READ_WRONG_L~  C ADDR   0CD6H   A 
SET_PWM_LIMIT_LOW~  C ADDR   08D9H   A 
BEEP_F4. . . . . .  C ADDR   0622H   A 
PCA_INT_PPM_MAX_C~  C ADDR   056AH   A 
PCA_INT_RESTORE_E~  C ADDR   0455H   A 
T2_INT_CURRENT_PW~  C ADDR   02C6H   A 
PWM_CFET . . . . .  C ADDR   014AH   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A7H   A 
_PGM_STARTUP_METH~  I ADDR   0095H   A 
_PGM_VOLT_COMP . .  I ADDR   0091H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0005h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
HTIRC_HUMMINGBIRD~  N NUMB   0118h            
FVT_LITTLEBEE_30A~  N NUMB   00E3h            
FVT_LITTLEBEE_20A~  N NUMB   00DEh            
FVT_LITTLEBEE_12A~  N NUMB   00DAh            
MDRX62H_MULTI. . .  N NUMB   00C3h            
H_KING_10A_MAIN. .  N NUMB   0079h            
ALIGN_RCE_BL35X_M~  N NUMB   0070h            
RCTIMER_6A_TAIL. .  N NUMB   0068h            
TURNIGY_PLUSH_NFE~  N NUMB   003Eh            
XP_18A_MAIN. . . .  N NUMB   000Dh            
XP_12A_MULTI . . .  N NUMB   000Ch            
XP_7A_FAST_TAIL. .  N NUMB   0008h            
PROGRAM_BY_TX_EXIT  C ADDR   18F8H   A 
STORE_MULTI_FUNC_5  C ADDR   17DEH   A 
READ_EEPROM_BYTE .  C ADDR   1761H   A 
THROTTLE_LOW_CAL .  C ADDR   13A8H   A 
COMP_READ_WRONG. .  C ADDR   0C9EH   A 
STORE_TIMES_UP_OR~  C ADDR   0BD3H   A 
STORE_TIMES_DECRE~  C ADDR   0BE1H   A 
TEMP_AVERAGE_UPDA~  C ADDR   093AH   A 
SET_PWM_LIMIT_HIG~  C ADDR   08EDH   A 
GOVERNOR_APPLY_IN~  C ADDR   0882H   A 
GOVERNOR_LIMIT_PR~  C ADDR   081CH   A 
BEEP_OFF . . . . .  C ADDR   066AH   A 
WAIT10MS . . . . .  C ADDR   05EEH   A 
T2_INT_CURRENT_PW~  C ADDR   02A4H   A 
PWM_AFET_DAMPED_E~  C ADDR   0163H   A 
T0_INT_PWM_ON_EXIT  C ADDR   00C4H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Eh            
PGM_PWM_DITHER . .  I ADDR   00A3H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0074H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   000Ah            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
HTIRC_HUMMINGBIRD~  N NUMB   0115h            
SERVOKING_MONSTER~  N NUMB   010Fh            
DALRC_XR20A_MAIN .  N NUMB   0103h            
GRAUPNER_ULTRA_20~  N NUMB   00E6h            
FVT_LITTLEBEE_30A~  N NUMB   00E4h            
FVT_LITTLEBEE_12A~  N NUMB   00DBh            
XROTOR_40A_MAIN. .  N NUMB   00BEh            
EMAX_20A_TAIL. . .  N NUMB   00ADh            
TAROT_30A_TAIL . .  N NUMB   00A7h            
H_KING_20A_MAIN. .  N NUMB   007Ch            
RCTIMER_6A_MULTI .  N NUMB   0069h            
HIMODEL_COOL_22A_~  N NUMB   005Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0037h            
XP_7A_FAST_MULTI .  N NUMB   0009h            
GETW . . . . . . .  C ADDR   1D8EH   A 
STORE_MULTI_FUNC_6  C ADDR   17E3H   A 
READ_TAG . . . . .  C ADDR   17ADH   A 
RESET_CAL_DONE . .  C ADDR   11AEH   A 
MUSIC_F1 . . . . .  C ADDR   10EBH   A 
DECODE_PARAMETERS.  C ADDR   0FFEH   A 
COMM45_FETS_DONE_~  C ADDR   0E9EH   A 
COMM23_NFET_OFF. .  C ADDR   0DD6H   A 
SETUP_ZC_SCAN_TIM~  C ADDR   0BF9H   A 
STORE_TIMES_INCRE~  C ADDR   0B82H   A 
MEASURE_LIPO_CELLS  C ADDR   08F2H   A 
CALC_GOVERNOR_INT~  C ADDR   0794H   A 
PCA_INT_PPM_CALCU~  C ADDR   0506H   A 
PCA_INT_EXIT . . .  C ADDR   05D2H   A 
T2_INT_RCP_UPDATE~  C ADDR   0225H   A 
PWM_BFET_DAMPED_E~  C ADDR   0174H   A 
RCP_PERIOD_DIFF_A~  D ADDR   005BH   A 
COMPARATOR_READ_C~  D ADDR   0043H   A 
STARTUP_CNT. . . .  D ADDR   0033H   A 
PWM_TIMER0_OVERFL~  N NUMB   0003h            
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0001h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
AIKON_BOLTLITE_30~  N NUMB   0106h            
OVERSKY_MR_20A_MA~  N NUMB   00FAh            
GRAUPNER_ULTRA_20~  N NUMB   00E7h            
FLYCOLOR_FAIRY_V2~  N NUMB   00D1h            
EMAX_20A_MULTI . .  N NUMB   00AEh            
TAROT_30A_MULTI. .  N NUMB   00A8h            
HIMODEL_COOL_41A_~  N NUMB   0064h            
TURNIGY_PLUSH_6A_~  N NUMB   001Ch            
GETX . . . . . . .  C ADDR   1D9CH   A 
STORE_MULTI_FUNC_7  C ADDR   17E8H   A 
RUN6_CHECK_SPEED .  C ADDR   165BH   A 
WAIT_FOR_POWER_ON~  C ADDR   1492H   A 
MUSIC_F2 . . . . .  C ADDR   1112H   A 
SWITCH_POWER_OFF .  C ADDR   0F7DH   A 
COMP_READ_WRONG_N~  C ADDR   0CAAH   A 
CALC_NEW_WAIT_PER~  C ADDR   0AA6H   A 
WAIT30MS . . . . .  C ADDR   05F3H   A 
PCA_INT_PPM_BIDIR~  C ADDR   055BH   A 
PCA_INT_CHECK_1KHZ  C ADDR   0444H   A 
T2H_INT. . . . . .  C ADDR   02E2H   A 
PWM_CFET_DAMPED_E~  C ADDR   0185H   A 
GOV_INTEGRAL_X . .  D ADDR   0048H   A 
COMP_TIMED_OUT . .  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   0018h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
FLYCOLOR_FAIRY_V2~  N NUMB   00D2h            
XROTOR_10A_TAIL. .  N NUMB   00B9h            
EMAX_40A_TAIL. . .  N NUMB   00B0h            
EAZY_3AV2_MAIN . .  N NUMB   00A3h            
ALIGN_RCE_BL15X_T~  N NUMB   006Bh            
HIMODEL_COOL_33A_~  N NUMB   0061h            
TURNIGY_KFORCE_70~  N NUMB   0050h            
TURNIGY_KFORCE_40~  N NUMB   004Dh            
XP_25A_TAIL. . . .  N NUMB   0011h            
RST. . . . . . . .  C ADDR   1CC6H   A 
SUCCESS. . . . . .  N NUMB   0030h            
BOOT_VERSION . . .  N NUMB   0006h            
XTAL . . . . . . .  N NUMB   17D7840h            
FUNC_PARAVAL_CONT~  C ADDR   18C7H   A 
WAIT1S . . . . . .  C ADDR   1804H   A 
STORE_MULTI_FUNC_8  C ADDR   17EDH   A 
WRITE_TAGS . . . .  C ADDR   17B7H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   168BH   A 
MUSIC_F3 . . . . .  C ADDR   1139H   A 
COMM61_NFET_OFF. .  C ADDR   0F22H   A 
EVAL_COMP_CHECK_T~  C ADDR   0D33H   A 
ADJUST_TIMING_TWO~  C ADDR   0B69H   A 
INITIALIZE_TIMING.  C ADDR   09B0H   A 
CHECK_VOLTAGE_RET.  C ADDR   098FH   A 
GOVERNOR_ACTIVATE~  C ADDR   0758H   A 
WAITXMS_M. . . . .  C ADDR   0604H   A 
PCA_INT_CHECK_2KHZ  C ADDR   0433H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
WT_ADV_START_H . .  D ADDR   004EH   A 
GOV_TARGET_H . . .  D ADDR   0045H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
XROTOR_20A_TAIL. .  N NUMB   00BCh            
XROTOR_10A_MULTI .  N NUMB   00BAh            
EMAX_LIGHTNING_20~  N NUMB   00B6h            
EMAX_40A_MULTI . .  N NUMB   00B1h            
SKYIII_30A_MAIN. .  N NUMB   00A9h            
PLATINUM_PRO_150A~  N NUMB   009Eh            
POLARIS_THUNDER_2~  N NUMB   0088h            
H_KING_50A_MAIN. .  N NUMB   0082h            
GAUI_GE_183_18A_M~  N NUMB   0076h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ch            
TURNIGY_KFORCE_70~  N NUMB   0051h            
TURNIGY_KFORCE_40~  N NUMB   004Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Bh            
XP_25A_MULTI . . .  N NUMB   0012h            
EXIT . . . . . . .  C ADDR   1CB7H   A 
BOOT_MSG . . . . .  C ADDR   1DEFH   A 
STORE_MULTI_FUNC_9  C ADDR   17F2H   A 
READ_INITIAL_TEMP.  C ADDR   14EBH   A 
WAIT_FOR_POWER_ON~  C ADDR   1486H   A 
PROGRAM_BY_TX_ENT~  C ADDR   13ECH   A 
DECODE_PWM_FREQ_E~  C ADDR   1036H   A 
WAIT_FOR_COMM_WAIT  C ADDR   0D7AH   A 
START_ADC_CONVERS~  C ADDR   08F6H   A 
MULT_S16_BY_U8_EX~  C ADDR   06FAH   A 
PCA_INT_PPM_LIMIT~  C ADDR   057CH   A 
GET_RCP_END. . . .  C ADDR   035BH   A 
T2H_INT_RCP_GOV_P~  C ADDR   031EH   A 
T2_INT_PWM_MIN_RUN  C ADDR   024DH   A 
PWM_DITHER_TABLE .  C ADDR   009AH   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
PGM_ENABLE_POWER_~  I ADDR   00A1H   A 
PWM_DITHER_DECODED  D ADDR   0066H   A 
PWM_LIMIT_BY_RPM .  D ADDR   0063H   A 
LOW_RPM_PWR_SLOPE.  D ADDR   0039H   A 
INITIAL_RUN_ROT_C~  D ADDR   0035H   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
MUX_A. . . . . . .  N NUMB   0000h            
PFETON_DELAY . . .  N NUMB   0018h            
HIGH_BEC_VOLTAGE .  N NUMB   0000h            
PSW. . . . . . . .  D ADDR   00D0H   A 
HTIRC_HUMMINGBIRD~  N NUMB   0119h            
ALIGN_MR25_15A_MA~  N NUMB   0109h            
XROTOR_20A_MULTI .  N NUMB   00BDh            
EMAX_LIGHTNING_20~  N NUMB   00B7h            
PLATINUM_PRO_150A~  N NUMB   009Fh            
POLARIS_THUNDER_3~  N NUMB   008Bh            
POLARIS_THUNDER_1~  N NUMB   0085h            
H_KING_10A_TAIL. .  N NUMB   007Ah            
ALIGN_RCE_BL35X_T~  N NUMB   0071h            
TURNIGY_PLUSH_NFE~  N NUMB   003Ch            
XP_18A_TAIL. . . .  N NUMB   000Eh            
WAITF. . . . . . .  C ADDR   1DDCH   A 
BOOT_BAUDRATE. . .  N NUMB   4B00h            
STORE_IN_RAM_EXIT.  C ADDR   1801H   A 
VALIDATE_RCP_START  C ADDR   12F3H   A 
LOCK_BYTE_TEST . .  C ADDR   117EH   A 
COMM45_NFET_OFF. .  C ADDR   0E7CH   A 
COMM12_REV . . . .  C ADDR   0DA4H   A 
COMM1COMM2 . . . .  C ADDR   0D8BH   A 
COMP_READ_WRONG_L~  C ADDR   0CE7H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0BF1H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0938H   A 
TEMP_AVERAGE_DEC .  C ADDR   092EH   A 
CALC_GOVERNOR_PRO~  C ADDR   07F2H   A 
WAITXMS_O. . . . .  C ADDR   0602H   A 
PCA_INT_PPM_TIMEO~  C ADDR   05C7H   A 
PCA_INT_CHECK_4KHZ  C ADDR   0422H   A 
T0_INT_PWM_OFF . .  C ADDR   00DFH   A 
T0_INT_START . . .  C ADDR   00B7H   A 
EEPROM_FW_SUB_REV~  N NUMB   004Bh            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   004AH   A 
DEFAULT_PGM_MULTI~  N NUMB   0050h            
MUX_B. . . . . . .  N NUMB   0002h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   000Ah            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
HTIRC_HUMMINGBIRD~  N NUMB   011Ah            
HTIRC_HUMMINGBIRD~  N NUMB   0116h            
SERVOKING_MONSTER~  N NUMB   0110h            
DALRC_XR20A_TAIL .  N NUMB   0104h            
DYS_XM20A_MAIN . .  N NUMB   00F7h            
XROTOR_40A_TAIL. .  N NUMB   00BFh            
POLARIS_THUNDER_4~  N NUMB   008Eh            
H_KING_20A_TAIL. .  N NUMB   007Dh            
H_KING_10A_MULTI .  N NUMB   007Bh            
ALIGN_RCE_BL35X_M~  N NUMB   0072h            
HIMODEL_COOL_22A_~  N NUMB   005Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0038h            
XP_18A_MULTI . . .  N NUMB   000Fh            
PUTC . . . . . . .  C ADDR   1D6FH   A 
BIT_REG. . . . . .  D ADDR   0020H   A 
CMDH . . . . . . .    REG    R5             
READ_EEPROM_EXIT .  C ADDR   171EH   A 
WAIT_FOR_POWER_ON~  C ADDR   1440H   A 
INPUT_HIGH_CHECK_1  C ADDR   1216H   A 
CHECK_VOLTAGE_STA~  C ADDR   0960H   A 
SET_PWM_LIMIT_LOW~  C ADDR   08ACH   A 
CALC_GOVERNOR_INT~  C ADDR   08ABH   A 
GOVERNOR_LIMIT_IN~  C ADDR   07C7H   A 
MULT_S16_BY_U8_DI~  C ADDR   06DFH   A 
BEEP . . . . . . .  C ADDR   0629H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0529H   A 
PCA_INT_FALL . . .  C ADDR   0486H   A 
T2_INT_SKIP_END. .  C ADDR   0203H   A 
TX_PGM_PARAMS_MUL~  C ADDR   009FH   A 
EEP_PGM_TEMP_PROT~  C ADDR   1A23H   A 
_EEP_PGM_THROTTLE~  C ADDR   1A1EH   A 
_EEP_PGM_STARTUP_~  C ADDR   1A12H   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A6H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006CH   A 
COMM_PHASE . . . .  D ADDR   0042H   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
MUX_C. . . . . . .  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   000Ah            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
HTIRC_HUMMINGBIRD~  N NUMB   0117h            
SERVOKING_MONSTER~  N NUMB   0111h            
AIKON_BOLTLITE_30~  N NUMB   0107h            
DALRC_XR20A_MULTI.  N NUMB   0105h            
OVERSKY_MR_20A_TA~  N NUMB   00FBh            
XROTOR_40A_MULTI .  N NUMB   00C0h            
EMAX_NANO_20A_MAIN  N NUMB   00B2h            
PLATINUM_50AV3_MA~  N NUMB   00A0h            
H_KING_35A_MAIN. .  N NUMB   007Fh            
H_KING_20A_MULTI .  N NUMB   007Eh            
HIMODEL_COOL_41A_~  N NUMB   0065h            
HIMODEL_COOL_22A_~  N NUMB   0060h            
TURNIGY_PLUSH_NFE~  N NUMB   0039h            
TURNIGY_PLUSH_6A_~  N NUMB   001Dh            
WAITH. . . . . . .  C ADDR   1DE0H   A 
ERASE_FLASH. . . .  C ADDR   1781H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   168EH   A 
PROGRAM_BY_TX. . .  C ADDR   1889H   A 
INPUT_HIGH_CHECK_2  C ADDR   1218H   A 
COMM23_NONDAMP . .  C ADDR   0E00H   A 
COMM2COMM3 . . . .  C ADDR   0DBAH   A 
CALC_NEXT_COMM_AV~  C ADDR   0A4DH   A 
GOVERNOR_STORE_IN~  C ADDR   08A9H   A 
GOVERNOR_CHECK_IN~  C ADDR   086BH   A 
GOVERNOR_CORR_PRO~  C ADDR   083AH   A 
GOVERNOR_ACTIVATE~  C ADDR   0745H   A 
T2_INT_START . . .  C ADDR   01A3H   A 
PWM_AFET_DAMPED. .  C ADDR   0154H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_ADV_START_L . .  D ADDR   004DH   A 
GOV_TARGET_L . . .  D ADDR   0044H   A 
DEMAG_PWR_OFF_THR~  D ADDR   0038H   A 
STARTUP_ZC_TIMEOU~  D ADDR   0034H   A 
FLAGS0 . . . . . .  D ADDR   002CH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFB2h            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
AIKON_BOLTLITE_30~  N NUMB   0108h            
OVERSKY_MR_20A_MU~  N NUMB   00FCh            
EAZY_3AV2_TAIL . .  N NUMB   00A4h            
POLARIS_THUNDER_6~  N NUMB   0091h            
HIMODEL_COOL_41A_~  N NUMB   0066h            
HIMODEL_COOL_33A_~  N NUMB   0062h            
TURNIGY_AE_20A_MA~  N NUMB   0040h            
TURNIGY_PLUSH_6A_~  N NUMB   001Eh            
XP_35A_SW_MAIN . .  N NUMB   0013h            
ID1. . . . . . . .  C ADDR   1C4AH   A 
FUNC_PARAVAL_STORE  C ADDR   18B8H   A 
WRITE_EEPROM_BYTE~  C ADDR   1766H   A 
READ_EEPROM_BLOCK1  C ADDR   1706H   A 
READ_EEPROM_READ .  C ADDR   16FFH   A 
COMM23_DAMP_REV. .  C ADDR   0DE0H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0BB3H   A 
LOAD_MIN_TIME_FAST  C ADDR   0B1AH   A 
MEASURE_LIPO_EXIT.  C ADDR   08F5H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0822H   A 
GOVERNOR_CHECK_PR~  C ADDR   0778H   A 
PCA_INT_SECOND_ME~  C ADDR   03ADH   A 
T2H_INT_RCP_STOP_~  C ADDR   0301H   A 
PWM_BFET_DAMPED. .  C ADDR   0165H   A 
PCA_INT. . . . . .  C ADDR   033BH   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
FLAGS1 . . . . . .  D ADDR   002DH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0001h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFEh            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
ZTW_SPIDER_PRO_20~  N NUMB   00F1h            
FLYCOLOR_FAIRY_6A~  N NUMB   00CAh            
SKYIII_30A_TAIL. .  N NUMB   00AAh            
EAZY_3AV2_MULTI. .  N NUMB   00A5h            
POLARIS_THUNDER_2~  N NUMB   0089h            
H_KING_50A_TAIL. .  N NUMB   0083h            
GAUI_GE_183_18A_T~  N NUMB   0077h            
HIMODEL_COOL_33A_~  N NUMB   0063h            
TURNIGY_AE_30A_MA~  N NUMB   0046h            
BOOT_INFO. . . . .  C ADDR   1DF3H   A 
ERRORVERIFY. . . .  N NUMB   00C0h            
READ_EEPROM_BLOCK2  C ADDR   1714H   A 
MEASURE_PWM_FREQ_~  C ADDR   1290H   A 
COMM61_NONDAMP . .  C ADDR   0F4CH   A 
COMM6COMM1 . . . .  C ADDR   0F06H   A 
COMM34_REV . . . .  C ADDR   0E4AH   A 
COMM3COMM4 . . . .  C ADDR   0E31H   A 
COMP_CHECK_TIMEOU~  C ADDR   0C91H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0C43H   A 
GOVERNOR_CORR_PRO~  C ADDR   084BH   A 
PCA_INT_PPM_BIDIR~  C ADDR   051DH   A 
PCA_INT_CHECK_8KHZ  C ADDR   0411H   A 
T2_INT_CURRENT_PW~  C ADDR   02BDH   A 
PWM_CFET_DAMPED. .  C ADDR   0176H   A 
_EEP_PGM_MAIN_SPO~  C ADDR   1A22H   A 
_EEP_PGM_LOW_VOLT~  C ADDR   1A06H   A 
DAMPINGFET . . . .  D ADDR   007BH   A 
WT_ZC_SCAN_START_H  D ADDR   0050H   A 
GOV_PROP_PWM . . .  D ADDR   004BH   A 
GOV_PROPORTIONAL_L  D ADDR   0049H   A 
PREV_COMM_X. . . .  D ADDR   003DH   A 
FLAGS2 . . . . . .  D ADDR   002EH   A 
DEMAG_DETECTED . .  N NUMB   0004h            
CURRENT_PWM_LIM_D~  D ADDR   0026H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
MCU_48MHZ. . . . .  N NUMB   0001h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
ALIGN_MR25_15A_TA~  N NUMB   010Ah            
ZTW_SPIDER_PRO_30~  N NUMB   00F4h            
ZTW_SPIDER_PRO_20~  N NUMB   00EEh            
FVT_LITTLEBEE_20A~  N NUMB   00DFh            
SKYIII_30A_MULTI .  N NUMB   00ABh            
POLARIS_THUNDER_8~  N NUMB   0094h            
POLARIS_THUNDER_3~  N NUMB   008Ch            
POLARIS_THUNDER_2~  N NUMB   008Ah            
POLARIS_THUNDER_1~  N NUMB   0086h            
H_KING_50A_MULTI .  N NUMB   0084h            
GAUI_GE_183_18A_M~  N NUMB   0078h            
TURNIGY_KFORCE_12~  N NUMB   0052h            
XP_3A_MAIN . . . .  N NUMB   0001h            



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6887    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =    105    ----
   IDATA SIZE       =     88    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)

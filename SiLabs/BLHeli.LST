MACRO ASSEMBLER BLHELI                                      09/14/16 15:00:17 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.18.15.328
OBJECT MODULE PLACED IN OUTPUT\HTIRC_HUMMINGBIRD_30A_PRO_REV14_75.OBJ
ASSEMBLER INVOKED BY: SET(BESCNO=285) OBJECT(OUTPUT\HTIRC_HUMMINGBIRD_30A_PRO_REV14_75.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ;
                         4     ; BLHeli program for controlling brushless motors in helicopters and multirotors
                         5     ;
                         6     ; Copyright 2011, 2012 Steffen Skaug
                         7     ; This program is distributed under the terms of the GNU General Public License
                         8     ;
                         9     ; This file is part of BLHeli.
                        10     ;
                        11     ; BLHeli is free software: you can redistribute it and/or modify
                        12     ; it under the terms of the GNU General Public License as published by
                        13     ; the Free Software Foundation, either version 3 of the License, or
                        14     ; (at your option) any later version.
                        15     ;
                        16     ; BLHeli is distributed in the hope that it will be useful,
                        17     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        18     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        19     ; GNU General Public License for more details.
                        20     ;
                        21     ; You should have received a copy of the GNU General Public License
                        22     ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                        23     ;
                        24     ;**** **** **** **** ****
                        25     ;
                        26     ; The software was initially designed for use with Eflite mCP X, but is now adapted to copters/planes in general
                        27     ;
                        28     ; The software was inspired by and started from from Bernard Konze's BLMC: http://home.versanet.de/~bkonze/blc_6a/blc_6a.htm
                        29     ; And also Simon Kirby's TGY: https://github.com/sim-/tgy
                        30     ;
                        31     ; This file is best viewed with tab width set to 5
                        32     ;
                        33     ; The input signal can be positive 1kHz, 2kHz, 4kHz, 8kHz or 12kHz PWM (e.g. taken from the "resistor tap" on mCPx)
                        34     ; And the input signal can be PPM (1-2ms) or OneShot125 (125-250us) at rates up to several hundred Hz.
                        35     ; The code autodetects the various input modes/frequencies
                        36     ; The code can also be programmed to accept inverted input signal.
                        37     ;
                        38     ; The first lines of the software must be modified according to the chosen environment:
                        39     ; Uncomment the selected ESC and main/tail/multi mode
                        40     ; BESCNO EQU "ESC"_"mode" 						
                        41     ; 
                        42     ;**** **** **** **** ****
                        43     ; Revision history:
                        44     ; - Rev1.0: Initial revision based upon BLHeli for AVR controllers
                        45     ; - Rev2.0: Changed "Eeprom" initialization, layout and defaults
                        46     ;           Various changes and improvements to comparator reading. Now using timer1 for time from pwm on/off
                        47     ;           Beeps are made louder
                        48     ;           Added programmable low voltage limit
                        49     ;           Added programmable damped tail mode (only for 1S ESCs)
                        50     ;           Added programmable motor rotation direction
                        51     ; - Rev2.1: (minor changes by 4712)
                        52     ;		  Added Disable TX Programming by PC Setup Application 
                        53     ;		  therfore changed EEPROM_LAYOUT_REVISION = 8					
                        54     ;		  Added Vdd Monitor as reset source when writing to "EEProm"
                        55     ;		  Changed for use of batch file to assemble, link and make hex files	
                        56     ; - Rev2.2: (minor changes by 4712)
                        57     ;           Added Disable Throttle Re-Arming every motor start by PC Setup Application 
                        58     ; - Rev2.3: (minor changes by 4712)
                        59     ;           Added bugfixed (2x CLR C before j(n)c operations)thx Steffen!			
                        60     ; - Rev2.4: Revisions 2.1 to 2.3 integrated
                        61     ; - Rev3.0: Added PPM (1050us-1866us) as accepted input signal
                        62     ;           Added startup rpm as a programming parameter
                        63     ;           Added startup acceleration as a programming parameter
                        64     ;           Added option for using voltage measurements to compensate motor power
                        65     ;           Added governor target by setup as a governor mode option
                        66     ;           Governor is kept active regardless of rpm
                        67     ;           Smooth governor spoolup/down in arm and setup modes
                        68     ;           Increased governor P and I gain programming ranges
                        69     ;           Increased and changed low voltage limit programming range
                        70     ;           Disabled tx programming entry for all but the first arming sequence after power on
                        71     ;           Made it possible to skip parameters in tx programming by setting throttle midstick
                        72     ;           Made it default not to rearm for every restart
                        73     ; - Rev3.1: Fixed bug that prevented chosen parameter to be set in tx programming
                        74     ; - Rev3.2: ...also updated the EEPROM revision parameter
                        75     ; - Rev3.3: Fixed negative number bug in voltage compensation
                        76     ;           Fixed bug in startup power calculation for non-default power
                        77     ;           Prevented possibility for voltage compensation fighting low voltage limiting
                        78     ;           Applied overall spoolup control to ensure soft spoolup in any mode
                        79     ;           Added a delay of 3 seconds from initiation of main motor stop until new startup is allowed
                        80     ;           Reduced beep power to reduce power consumption for very strong motors/ESCs
                        81     ; - Rev3.4: Fixed bug that prevented full power in governor arm and setup modes
                        82     ;           Increased NFETON_DELAY for XP_7A and XP_12A to allow for more powerful fets
                        83     ;           Increased initial spoolup power, and linked to startup power
                        84     ; - Rev4.0: Fixed bug that made tail tx program beeps very weak
                        85     ;           Added thermal protection feature
                        86     ;           Governor P and I gain ranges are extended up to 8.0x gain
                        87     ;           Startup sequence is aborted upon zero throttle
                        88     ;           Avoided voltage compensation function induced latency for tail when voltage compensation is not enabled
                        89     ;           Improved input signal frequency detection robustness
                        90     ; - Rev4.1: Increased thermal protection temperature limits
                        91     ; - Rev5.0: Added multi(copter) operating mode. TAIL define changed to MODE with three modes: MAIN, TAIL and MULTI
                        92     ;           Added programmable commutation timing
                        93     ;           Added a damped light mode that has less damping, but that can be used with all escs
                        94     ;           Added programmable damping force
                        95     ;           Added thermal protection for startup too
                        96     ;           Added wait beeps when waiting more than 30 sec for throttle above zero (after having been armed)
                        97     ;           Modified tail idling to provide option for very low speeds
                        98     ;           Changed PPM range to 1150-1830us
                        99     ;           Arming sequence is dropped for PPM input, unless it is governor arm mode
                       100     ;           Loss of input signal will immediately stop the motor for PPM input
                       101     ;           Bug corrected in Turnigy Plush 6A voltage measurement setup
                       102     ;           FET switching delays are set for original fets. Stronger/doubled/tripled etc fets may require faster pfet off switching
                       103     ;           Miscellaneous other changes
                       104     ; - Rev6.0: Reverted comparator reading routine to rev5.0 equivalent, in order to avoid tail motor stops
                       105     ;           Added governor range programmability
                       106     ;           Implemented startup retry sequence with varying startup power for multi mode
                       107     ;           In damped light mode, damping is now applied to the active nfet phase for fully damped capable ESCs
                       108     ; - Rev6.1: Added input signal qualification criteria for PPM, to avoid triggering on noise spikes (fix for plush hardware)
                       109     ;           Changed main and multi mode stop criteria. Will now be in run mode, even if RC pulse input is zero
                       110     ;           Fixed bug in commutation that caused rough running in damped light mode
                       111     ;           Miscellaneous other changes
                       112     ; - Rev7.0  Added direct startup mode programmability
                       113     ;           Added throttle calibration. Min>=1000us and Max<=2000us. Difference must be >520us, otherwise max is shifted so that difference=520us
                       114     ;           Added programmable throttle change rate
                       115     ;           Added programmable beep strength, beacon strength and beacon delay
                       116     ;           Reduced power step to full power significantly
                       117     ;           Miscellaneous other changes
                       118     ; - Rev8.0  Added a 2 second delay after power up, to wait for receiver initialization
                       119     ;           Added a programming option for disabling low voltage limit, and made it default for MULTI
                       120     ;           Added programable demag compensation, using the concept of SimonK
                       121     ;           Improved robustness against noisy input signal
                       122     ;           Refined direct startup
                       123     ;           Removed voltage compensation
                       124     ;           Miscellaneous other changes
                       125     ; - Rev9.0  Increased programming range for startup power, and made its default ESC dependent
                       126     ;           Made default startup method ESC dependent
                       127     ;           Even more smooth and gentle spoolup for MAIN, to suit larger helis
                       128     ;           Improved transition from stepped startup to run
                       129     ;           Refined direct startup
                       130     ; - Rev9.1  Fixed bug that changed FW revision after throttle calibration or TX programming
                       131     ; - Rev9.2  Altered timing of throttle calibration in order to work with MultiWii calibration firmware
                       132     ;           Reduced main spoolup time to around 5 seconds
                       133     ;           Changed default beacon delay to 3 minutes
                       134     ; - Rev9.3  Fixed bug in Plush 60/80A temperature reading, that caused failure in operation above 4S
                       135     ;           Corrected temperature limit for HiModel cool 22/33/41A, RCTimer 6A, Skywalker 20/40A, Turnigy AE45A, Plush 40/60/80A. Limit was previously set too high
                       136     ; - Rev9.4  Improved timing for increased maximum rpm limit
                       137     ; - Rev10.0 Added closed loop mode for multi
                       138     ;           Added high/low BEC voltage option (for the ESCs where HW supports it)
                       139     ;           Added method of resetting all programmed parameter values to defaults by TX programming
                       140     ;           Added Turnigy K-force 40A and Turnigy K-force 120A HV ESCs
                       141     ;           Enabled fully damped mode for several ESCs
                       142     ;           Extended startup power range downwards to enable very smooth start for large heli main motors
                       143     ;           Extended damping force with a highest setting
                       144     ;           Corrected temperature limits for F310 chips (Plush 40A and AE 45A)
                       145     ;           Implemented temperature reading average in order to avoid problems with ADC noise on Skywalkers
                       146     ;           Increased switching delays for XP 7A fast, in order to avoid cross conduction of N and P fets
                       147     ;           Miscellaneous other changes
                       148     ; - Rev10.1 Relaxed RC signal jitter requirement during frequency measurement
                       149     ;           Corrected bug that prevented using governor low
                       150     ;           Enabled vdd monitor always, in order to reduce likelihood of accidental overwriting of adjustments
                       151     ;           Fixed bug that caused stop for PPM input above 2048us, and moved upper accepted limit to 2160us
                       152     ; - Rev10.2 Corrected temperature limit for AE20-30/XP7-25, where limit was too high
                       153     ;           Corrected temperature limit for 120HV, where limit was too low
                       154     ;           Fixed bug that caused AE20/25/30A not to run in reverse
                       155     ; - Rev10.3 Removed vdd monitor for 1S capable ESCs, in order to avoid brownouts/resets
                       156     ;           Made auto bailout spoolup for main more smooth
                       157     ; - Rev10.4 Ensured that main spoolup and governor activation will always be smooth, regardless of throttle input
                       158     ;           Added capability to operate on 12kHz input signal too
                       159     ; - Rev11.0 Fixed bug of programming default values for governor in MULTI mode
                       160     ;           Disabled interrupts explicitly some places, to avoid possibilities for unintentional fet switching
                       161     ;           Changed interrupt disable strategy, to always allow pwm interrupts, to avoid noise when running at low rpms
                       162     ;           Added governor middle range for MAIN mode
                       163     ;           Added bidirectional mode for TAIL and MULTI mode with PPM input
                       164     ;           Changed and improved demag compensation
                       165     ;           Miscellaneous other changes
                       166     ; - Rev11.1 Fixed bug of slow acceleration response for MAIN mode running without governor
                       167     ;           Fixed bug with PWM input, where throttle remains high even when zeroing throttle (seen on V922 tail)
                       168     ;           Fixed bug in bidirectional operation, where direction change could cause reset
                       169     ;           Improved autorotation bailout for MAIN
                       170     ;           Reduced min speed back to 1220 erpm
                       171     ;           Misc code cleanups
                       172     ; - Rev11.2 Fixed throttle calibration bug
                       173     ;           Added high side driver precharge for all-nfet ESCs
                       174     ;           Optimized timing in general and for demag compensation in particular
                       175     ;           Auto bailout functionality modified
                       176     ;           Governor is deactivated for throttle inputs below 10%
                       177     ;           Increased beacon delay times
                       178     ; - Rev12.0 Added programmable main spoolup time
                       179     ;           Added programmable temperature protection enable
                       180     ;           Bidirectional mode stop/start improved. Motor is now stopped before starting
                       181     ;           Power is limited for very low rpms (when BEMF is low), in order to avoid sync loss 
                       182     ;           Damped light mode is made more smooth and quiet, particularly at low and high rpms
                       183     ;           Comparator signal qualification scheme is changed
                       184     ;           Demag compensation scheme is significantly changed
                       185     ;           Increased jitter tolerance for PPM frequency measurement
                       186     ;           Fully damped mode removed, and damped light only supported on damped capable ESCs
                       187     ;           Default tail mode changed to damped light
                       188     ;           Miscellaneous other changes
                       189     ; - Rev12.1 Fixed bug in tail code
                       190     ;           Improved startup for Atmel
                       191     ;           Added support for multiple high BEC voltages
                       192     ;           Added support for RPM output
                       193     ; - Rev12.2 Improved running smoothness, particularly for damped light
                       194     ;           Avoiding lockup at full throttle when input signal is noisy
                       195     ;           Avoiding detection of 1-wire programming signal as valid throttle signal
                       196     ; - Rev13.0 Removed stepped start
                       197     ;           Removed throttle change rate and damping force parameters
                       198     ;           Added support for OneShot125
                       199     ;           Improved commutation timing accuracy
                       200     ; - Rev13.1 Removed startup ramp for MULTI
                       201     ;           Improved startup for some odd ESCs
                       202     ; - Rev13.2 Still tweaking startup to make it more reliable and faster for all ESC/motor combos
                       203     ;           Increased deadband for bidirectional operation
                       204     ;           Relaxed signal detection criteria
                       205     ;           Added support for running 48MHz capable SiLabs MCUs at 48MHz
                       206     ;           Added bootlader to SiLabs code
                       207     ;           Miscellaneous other changes
                       208     ; - Rev14.0 Improved running at high timing
                       209     ;           Improved running at high RPMs and increased max RPM limit
                       210     ;           Avoid being locked in bootloader (implemented in Suite 13202)
                       211     ;           Improved reliability of 3D (bidirectional) mode and startup
                       212     ;           Smoother running and greatly reduced step to full power in damped light mode
                       213     ;           Removed low voltage limiting for MULTI
                       214     ;           Added pwm dither parameter
                       215     ;           Added setting for enable/disable of low RPM power protection
                       216     ;           Added setting for enable/disable of PWM input
                       217     ;           Better AFW and damping for some ESCs (that have a slow high side driver)
                       218     ;           Miscellaneous other changes
                       219     ; - Rev14.1 Fixed max throttle calibration bug (for non-oneshot)
                       220     ;           Fixed some closed loop mode bugs
                       221     ;           Relaxed signal jitter requirement for looptimes below 1000
                       222     ;           Added skipping of damping fet switching near max power, for improved high end throttle linearity, using the concept of SimonK
                       223     ;           Improved sync hold at high rpms
                       224     ; - Rev14.2 Added stalled motor shutoff after about 10 seconds (for tail and multi code with PPM input)
                       225     ;           Greatly increased maximum rpm limit, and added rpm limiting at 250k erpm (48MHz MCUs at 400k erpm)
                       226     ;           Improved bidirectional operation
                       227     ; - Rev14.3 Moved reset vector to be just before the settings segment, in order to better recover from partially failed flashing operation
                       228     ;           Added 100ms intialization delay for the Graupner Ultra 20A ESC
                       229     ;           Shortened stall detect time to about 5sec, and prevented going into tx programming after a stall
                       230     ;           Optimizations of software timing and running reliability
                       231     ; - Rev14.4 Improved startup, particularly for larger motors
                       232     ;           Improved running at very high rpms
                       233     ;           Made damped light default for MULTI on ESCs that support it
                       234     ;           Miscellaneous other changes
                       235     ; - Rev14.5 Longer between beacon beeps (to reduce motor heating), and now again beeping on two motor phases
                       236     ;           Implemented programmable brake on zero throttle
                       237     ;           Implemented hardware reload of commutation timers, to reduce sensitivity to interrupt activity on high rpms
                       238     ;           Implemented support for EN/PWM style fet drivers
                       239     ;           Slightly modified throttle calibration
                       240     ;           Improved startup, particularly for small motors
                       241     ;           Improved smoothness
                       242     ; - Rev14.6 Fixed bug that caused tail motor not to stop
                       243     ;           Fixed bug that caused brake not to work for low side pwm ESCs
                       244     ;           Fixed bug where noisy input signal could cause loss of sync
                       245     ;           Increased fet deadtime a bit for the LB20A and the LB20A pro
                       246     ;           Made low rpm power limiting programmable through the startup power parameter
                       247     ; - Rev14.7 Beeps can be turned off by programming beep strength to 1
                       248     ;           Throttle cal difference is checked to be above required minimum before storing. Throttle cal max is not stored until successful min throttle cal
                       249     ;           In order to have a good code for fixed wing planes, that has low voltage limiting, a main code spoolup time setting of 0 is made fast
                       250     ;           Improved protection of bootloader and generally reduced risk of flash corruption
                       251     ;           Some small changes for improved sync hold
                       252     ;	-Rev14.75 Modified input signal accept Multishot protocol
                       253     ;						Changed Defaults to more acceptable/appropriate values	
                       254     ;						Modified beeps to use the "Pit Stop" or "Fast Start" style tones
                       255     ;
                       256     ;**** **** **** **** ****
                       257     ; Up to 8K Bytes of In-System Self-Programmable Flash
                       258     ; Up to 768 Bytes Internal SRAM
                       259     ;
                       260     ;**** **** **** **** ****
                       261     ; Master clock is internal 24MHz oscillator (or 48MHz, for which the times below are halved)
                       262     ; Timer 0 (167/500ns counts) always counts up and is used for
                       263     ; - PWM generation
                       264     ; Timer 2 (500ns counts) always counts up and is used for
                       265     ; - RC pulse timeout/skip counts and commutation times
                       266     ; Timer 3 (500ns counts) always counts up and is used for
                       267     ; - Commutation timeouts
                       268     ; PCA0 (500ns counts) always counts up and is used for
                       269     ; - RC pulse measurement
                       270     ;
                       271     ;**** **** **** **** ****
                       272     ; Interrupt handling
                       273     ; The C8051 does not disable interrupts when entering an interrupt routine.
                       274     ; Also some interrupt flags need to be cleared by software
                       275     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                       276     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                       277     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                       278     ;
                       279     ;**** **** **** **** ****
                       280     ; Motor control:
                       281     ; - Brushless motor control with 6 states for each electrical 360 degrees
                       282     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                       283     ; - Timing advance in this implementation is set to 15deg nominally
                       284     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                       285     ; Motor sequence starting from zero crossing:
                       286     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                       287     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                       288     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                       289     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                       290     ;
                       291     ; Motor startup:
                       292     ; There is a startup phase and an initial run phase, before normal bemf commutation run begins.
                       293     ;
                       294     ;**** **** **** **** ****
                       295     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0001                 296     XP_3A_MAIN 					EQU 1
  0002                 297     XP_3A_TAIL 					EQU 2
  0003                 298     XP_3A_MULTI 					EQU 3
  0004                 299     XP_7A_MAIN 					EQU 4
  0005                 300     XP_7A_TAIL 					EQU 5
  0006                 301     XP_7A_MULTI 					EQU 6
  0007                 302     XP_7A_FAST_MAIN 				EQU 7
  0008                 303     XP_7A_FAST_TAIL 				EQU 8
  0009                 304     XP_7A_FAST_MULTI 				EQU 9
  000A                 305     XP_12A_MAIN 					EQU 10
  000B                 306     XP_12A_TAIL 					EQU 11
  000C                 307     XP_12A_MULTI 					EQU 12
  000D                 308     XP_18A_MAIN 					EQU 13
  000E                 309     XP_18A_TAIL 					EQU 14
  000F                 310     XP_18A_MULTI 					EQU 15
  0010                 311     XP_25A_MAIN 					EQU 16
  0011                 312     XP_25A_TAIL 					EQU 17
  0012                 313     XP_25A_MULTI 					EQU 18
  0013                 314     XP_35A_SW_MAIN 				EQU 19
  0014                 315     XP_35A_SW_TAIL 				EQU 20
  0015                 316     XP_35A_SW_MULTI 				EQU 21
  0016                 317     DP_3A_MAIN 					EQU 22
  0017                 318     DP_3A_TAIL  					EQU 23
  0018                 319     DP_3A_MULTI  					EQU 24
  0019                 320     SUPERMICRO_3P5A_MAIN 			EQU 25
  001A                 321     SUPERMICRO_3P5A_TAIL 			EQU 26   
  001B                 322     SUPERMICRO_3P5A_MULTI 			EQU 27   
  001C                 323     TURNIGY_PLUSH_6A_MAIN 			EQU 28
  001D                 324     TURNIGY_PLUSH_6A_TAIL 			EQU 29   
  001E                 325     TURNIGY_PLUSH_6A_MULTI 			EQU 30   
  001F                 326     TURNIGY_PLUSH_10A_MAIN 			EQU 31
  0020                 327     TURNIGY_PLUSH_10A_TAIL 			EQU 32   
  0021                 328     TURNIGY_PLUSH_10A_MULTI 			EQU 33   
  0022                 329     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                 330     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                 331     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  0025                 332     TURNIGY_PLUSH_18A_MAIN 			EQU 37
  0026                 333     TURNIGY_PLUSH_18A_TAIL 			EQU 38   
  0027                 334     TURNIGY_PLUSH_18A_MULTI 			EQU 39   
  0028                 335     TURNIGY_PLUSH_25A_MAIN 			EQU 40
  0029                 336     TURNIGY_PLUSH_25A_TAIL 			EQU 41   
  002A                 337     TURNIGY_PLUSH_25A_MULTI 			EQU 42   
  002B                 338     TURNIGY_PLUSH_30A_MAIN 			EQU 43
  002C                 339     TURNIGY_PLUSH_30A_TAIL 			EQU 44   
  002D                 340     TURNIGY_PLUSH_30A_MULTI 			EQU 45   
  002E                 341     TURNIGY_PLUSH_40A_MAIN 			EQU 46
  002F                 342     TURNIGY_PLUSH_40A_TAIL 			EQU 47   
  0030                 343     TURNIGY_PLUSH_40A_MULTI 			EQU 48   
  0031                 344     TURNIGY_PLUSH_60A_MAIN 			EQU 49
  0032                 345     TURNIGY_PLUSH_60A_TAIL 			EQU 50   
  0033                 346     TURNIGY_PLUSH_60A_MULTI 			EQU 51   
  0034                 347     TURNIGY_PLUSH_80A_MAIN 			EQU 52
  0035                 348     TURNIGY_PLUSH_80A_TAIL 			EQU 53   
  0036                 349     TURNIGY_PLUSH_80A_MULTI 			EQU 54   
  0037                 350     TURNIGY_PLUSH_NFET_18A_MAIN 		EQU 55
  0038                 351     TURNIGY_PLUSH_NFET_18A_TAIL 		EQU 56   
  0039                 352     TURNIGY_PLUSH_NFET_18A_MULTI 		EQU 57   
  003A                 353     TURNIGY_PLUSH_NFET_25A_MAIN 		EQU 58
  003B                 354     TURNIGY_PLUSH_NFET_25A_TAIL 		EQU 59   
  003C                 355     TURNIGY_PLUSH_NFET_25A_MULTI 		EQU 60   
  003D                 356     TURNIGY_PLUSH_NFET_30A_MAIN 		EQU 61
  003E                 357     TURNIGY_PLUSH_NFET_30A_TAIL 		EQU 62   
  003F                 358     TURNIGY_PLUSH_NFET_30A_MULTI 		EQU 63   
  0040                 359     TURNIGY_AE_20A_MAIN 			EQU 64
  0041                 360     TURNIGY_AE_20A_TAIL 			EQU 65   
  0042                 361     TURNIGY_AE_20A_MULTI 			EQU 66   
  0043                 362     TURNIGY_AE_25A_MAIN 			EQU 67
  0044                 363     TURNIGY_AE_25A_TAIL 			EQU 68   
  0045                 364     TURNIGY_AE_25A_MULTI 			EQU 69   
  0046                 365     TURNIGY_AE_30A_MAIN 			EQU 70
  0047                 366     TURNIGY_AE_30A_TAIL 			EQU 71   
  0048                 367     TURNIGY_AE_30A_MULTI 			EQU 72   
  0049                 368     TURNIGY_AE_45A_MAIN 			EQU 73
  004A                 369     TURNIGY_AE_45A_TAIL 			EQU 74   
  004B                 370     TURNIGY_AE_45A_MULTI 			EQU 75   
  004C                 371     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                 372     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                 373     TURNIGY_KFORCE_40A_MULTI 		EQU 78   
  004F                 374     TURNIGY_KFORCE_70A_HV_MAIN 		EQU 79   
  0050                 375     TURNIGY_KFORCE_70A_HV_TAIL 		EQU 80   
  0051                 376     TURNIGY_KFORCE_70A_HV_MULTI 		EQU 81   
  0052                 377     TURNIGY_KFORCE_120A_HV_MAIN 		EQU 82   
  0053                 378     TURNIGY_KFORCE_120A_HV_TAIL 		EQU 83   
  0054                 379     TURNIGY_KFORCE_120A_HV_MULTI 		EQU 84   
  0055                 380     TURNIGY_KFORCE_120A_HV_V2_MAIN	EQU 85   
  0056                 381     TURNIGY_KFORCE_120A_HV_V2_TAIL 	EQU 86   
  0057                 382     TURNIGY_KFORCE_120A_HV_V2_MULTI 	EQU 87   
  0058                 383     SKYWALKER_20A_MAIN 				EQU 88
  0059                 384     SKYWALKER_20A_TAIL 				EQU 89   
  005A                 385     SKYWALKER_20A_MULTI 			EQU 90   
  005B                 386     SKYWALKER_40A_MAIN 				EQU 91
  005C                 387     SKYWALKER_40A_TAIL 				EQU 92   
  005D                 388     SKYWALKER_40A_MULTI 			EQU 93   
  005E                 389     HIMODEL_COOL_22A_MAIN 			EQU 94
  005F                 390     HIMODEL_COOL_22A_TAIL 			EQU 95   
  0060                 391     HIMODEL_COOL_22A_MULTI 			EQU 96   
  0061                 392     HIMODEL_COOL_33A_MAIN 			EQU 97
  0062                 393     HIMODEL_COOL_33A_TAIL 			EQU 98   
  0063                 394     HIMODEL_COOL_33A_MULTI 			EQU 99  
  0064                 395     HIMODEL_COOL_41A_MAIN 			EQU 100
  0065                 396     HIMODEL_COOL_41A_TAIL 			EQU 101  
  0066                 397     HIMODEL_COOL_41A_MULTI 			EQU 102  
  0067                 398     RCTIMER_6A_MAIN 				EQU 103   
  0068                 399     RCTIMER_6A_TAIL 				EQU 104  
  0069                 400     RCTIMER_6A_MULTI 				EQU 105  
  006A                 401     ALIGN_RCE_BL15X_MAIN			EQU 106   
  006B                 402     ALIGN_RCE_BL15X_TAIL 			EQU 107  
  006C                 403     ALIGN_RCE_BL15X_MULTI 			EQU 108  
  006D                 404     ALIGN_RCE_BL15P_MAIN			EQU 109  
  006E                 405     ALIGN_RCE_BL15P_TAIL 			EQU 110  
  006F                 406     ALIGN_RCE_BL15P_MULTI 			EQU 111  
  0070                 407     ALIGN_RCE_BL35X_MAIN			EQU 112  
  0071                 408     ALIGN_RCE_BL35X_TAIL 			EQU 113  
  0072                 409     ALIGN_RCE_BL35X_MULTI 			EQU 114  
  0073                 410     ALIGN_RCE_BL35P_MAIN			EQU 115   
  0074                 411     ALIGN_RCE_BL35P_TAIL 			EQU 116  
  0075                 412     ALIGN_RCE_BL35P_MULTI 			EQU 117  
  0076                 413     GAUI_GE_183_18A_MAIN			EQU 118   
  0077                 414     GAUI_GE_183_18A_TAIL 			EQU 119  
  0078                 415     GAUI_GE_183_18A_MULTI 			EQU 120  
  0079                 416     H_KING_10A_MAIN				EQU 121   
  007A                 417     H_KING_10A_TAIL 				EQU 122  
  007B                 418     H_KING_10A_MULTI 				EQU 123  
  007C                 419     H_KING_20A_MAIN				EQU 124   
  007D                 420     H_KING_20A_TAIL 				EQU 125  
  007E                 421     H_KING_20A_MULTI 				EQU 126  
  007F                 422     H_KING_35A_MAIN				EQU 127   
  0080                 423     H_KING_35A_TAIL 				EQU 128 
  0081                 424     H_KING_35A_MULTI 				EQU 129  
  0082                 425     H_KING_50A_MAIN				EQU 130   
  0083                 426     H_KING_50A_TAIL 				EQU 131  
  0084                 427     H_KING_50A_MULTI 				EQU 132  
  0085                 428     POLARIS_THUNDER_12A_MAIN			EQU 133   
  0086                 429     POLARIS_THUNDER_12A_TAIL 		EQU 134  
  0087                 430     POLARIS_THUNDER_12A_MULTI 		EQU 135  
  0088                 431     POLARIS_THUNDER_20A_MAIN			EQU 136   
  0089                 432     POLARIS_THUNDER_20A_TAIL 		EQU 137  
  008A                 433     POLARIS_THUNDER_20A_MULTI 		EQU 138  
  008B                 434     POLARIS_THUNDER_30A_MAIN			EQU 139   
  008C                 435     POLARIS_THUNDER_30A_TAIL 		EQU 140  
  008D                 436     POLARIS_THUNDER_30A_MULTI 		EQU 141  
  008E                 437     POLARIS_THUNDER_40A_MAIN			EQU 142   
  008F                 438     POLARIS_THUNDER_40A_TAIL 		EQU 143  
  0090                 439     POLARIS_THUNDER_40A_MULTI 		EQU 144  
  0091                 440     POLARIS_THUNDER_60A_MAIN			EQU 145   
  0092                 441     POLARIS_THUNDER_60A_TAIL 		EQU 146  
  0093                 442     POLARIS_THUNDER_60A_MULTI 		EQU 147  
  0094                 443     POLARIS_THUNDER_80A_MAIN			EQU 148   
  0095                 444     POLARIS_THUNDER_80A_TAIL 		EQU 149  
  0096                 445     POLARIS_THUNDER_80A_MULTI 		EQU 150  
  0097                 446     POLARIS_THUNDER_100A_MAIN		EQU 151   
  0098                 447     POLARIS_THUNDER_100A_TAIL 		EQU 152  
  0099                 448     POLARIS_THUNDER_100A_MULTI 		EQU 153  
  009A                 449     PLATINUM_PRO_30A_MAIN			EQU 154   
  009B                 450     PLATINUM_PRO_30A_TAIL 			EQU 155  
  009C                 451     PLATINUM_PRO_30A_MULTI 			EQU 156  
  009D                 452     PLATINUM_PRO_150A_MAIN			EQU 157   
  009E                 453     PLATINUM_PRO_150A_TAIL 			EQU 158  
  009F                 454     PLATINUM_PRO_150A_MULTI 			EQU 159  
  00A0                 455     PLATINUM_50AV3_MAIN				EQU 160   
  00A1                 456     PLATINUM_50AV3_TAIL 			EQU 161  
  00A2                 457     PLATINUM_50AV3_MULTI 			EQU 162  
  00A3                 458     EAZY_3AV2_MAIN					EQU 163   
  00A4                 459     EAZY_3AV2_TAIL 				EQU 164  
  00A5                 460     EAZY_3AV2_MULTI 				EQU 165  
  00A6                 461     TAROT_30A_MAIN					EQU 166   
  00A7                 462     TAROT_30A_TAIL 				EQU 167  
  00A8                 463     TAROT_30A_MULTI 				EQU 168  
  00A9                 464     SKYIII_30A_MAIN				EQU 169   
  00AA                 465     SKYIII_30A_TAIL 				EQU 170  
  00AB                 466     SKYIII_30A_MULTI 				EQU 171  
  00AC                 467     EMAX_20A_MAIN					EQU 172   
  00AD                 468     EMAX_20A_TAIL 					EQU 173  
  00AE                 469     EMAX_20A_MULTI 				EQU 174  
  00AF                 470     EMAX_40A_MAIN					EQU 175   
  00B0                 471     EMAX_40A_TAIL 					EQU 176  
  00B1                 472     EMAX_40A_MULTI 				EQU 177  
  00B2                 473     EMAX_NANO_20A_MAIN				EQU 178   
  00B3                 474     EMAX_NANO_20A_TAIL 				EQU 179  
  00B4                 475     EMAX_NANO_20A_MULTI 			EQU 180  
  00B5                 476     EMAX_LIGHTNING_20A_MAIN			EQU 181   
  00B6                 477     EMAX_LIGHTNING_20A_TAIL 			EQU 182  
  00B7                 478     EMAX_LIGHTNING_20A_MULTI 		EQU 183  
  00B8                 479     XROTOR_10A_MAIN				EQU 184   
  00B9                 480     XROTOR_10A_TAIL 				EQU 185  
  00BA                 481     XROTOR_10A_MULTI 				EQU 186  
  00BB                 482     XROTOR_20A_MAIN				EQU 187   
  00BC                 483     XROTOR_20A_TAIL 				EQU 188  
  00BD                 484     XROTOR_20A_MULTI 				EQU 189  
  00BE                 485     XROTOR_40A_MAIN				EQU 190   
  00BF                 486     XROTOR_40A_TAIL 				EQU 191  
  00C0                 487     XROTOR_40A_MULTI 				EQU 192  
  00C1                 488     MDRX62H_MAIN					EQU 193   
  00C2                 489     MDRX62H_TAIL 					EQU 194  
  00C3                 490     MDRX62H_MULTI 					EQU 195  
  00C4                 491     ROTORGEEKS_20A_MAIN				EQU 196   
  00C5                 492     ROTORGEEKS_20A_TAIL 			EQU 197  
  00C6                 493     ROTORGEEKS_20A_MULTI 			EQU 198  
  00C7                 494     ROTORGEEKS_20A_PLUS_MAIN			EQU 199   
  00C8                 495     ROTORGEEKS_20A_PLUS_TAIL 		EQU 200  
  00C9                 496     ROTORGEEKS_20A_PLUS_MULTI 		EQU 201  
  00CA                 497     FLYCOLOR_FAIRY_6A_MAIN			EQU 202   
  00CB                 498     FLYCOLOR_FAIRY_6A_TAIL 			EQU 203  
  00CC                 499     FLYCOLOR_FAIRY_6A_MULTI 			EQU 204  
  00CD                 500     FLYCOLOR_FAIRY_30A_MAIN			EQU 205   
  00CE                 501     FLYCOLOR_FAIRY_30A_TAIL 			EQU 206  
  00CF                 502     FLYCOLOR_FAIRY_30A_MULTI 		EQU 207  
  00D0                 503     FLYCOLOR_FAIRY_V2_30A_MAIN		EQU 208
  00D1                 504     FLYCOLOR_FAIRY_V2_30A_TAIL 		EQU 209  
  00D2                 505     FLYCOLOR_FAIRY_V2_30A_MULTI 		EQU 210 
  00D3                 506     FLYCOLOR_RAPTOR_20A_MAIN			EQU 211   
  00D4                 507     FLYCOLOR_RAPTOR_20A_TAIL 		EQU 212  
  00D5                 508     FLYCOLOR_RAPTOR_20A_MULTI 		EQU 213  
  00D6                 509     FLYCOLOR_RAPTOR_390_20A_MAIN		EQU 214
  00D7                 510     FLYCOLOR_RAPTOR_390_20A_TAIL 		EQU 215  
  00D8                 511     FLYCOLOR_RAPTOR_390_20A_MULTI 	EQU 216  
  00D9                 512     FVT_LITTLEBEE_12A_MAIN			EQU 217  
  00DA                 513     FVT_LITTLEBEE_12A_TAIL			EQU 218  
  00DB                 514     FVT_LITTLEBEE_12A_MULTI			EQU 219  
  00DC                 515     FVT_LITTLEBEE_20A_MAIN			EQU 220  
  00DD                 516     FVT_LITTLEBEE_20A_TAIL			EQU 221  
  00DE                 517     FVT_LITTLEBEE_20A_MULTI			EQU 222  
  00DF                 518     FVT_LITTLEBEE_20A_PRO_MAIN		EQU 223  
  00E0                 519     FVT_LITTLEBEE_20A_PRO_TAIL		EQU 224  
  00E1                 520     FVT_LITTLEBEE_20A_PRO_MULTI		EQU 225  
  00E2                 521     FVT_LITTLEBEE_30A_MAIN			EQU 226  
  00E3                 522     FVT_LITTLEBEE_30A_TAIL			EQU 227  
  00E4                 523     FVT_LITTLEBEE_30A_MULTI			EQU 228  
  00E5                 524     GRAUPNER_ULTRA_20A_MAIN			EQU 229  
  00E6                 525     GRAUPNER_ULTRA_20A_TAIL			EQU 230  
  00E7                 526     GRAUPNER_ULTRA_20A_MULTI			EQU 231  
  00E8                 527     F85_3A_MAIN					EQU 232  
  00E9                 528     F85_3A_TAIL					EQU 233  
  00EA                 529     F85_3A_MULTI					EQU 234  
  00EB                 530     ZTW_SPIDER_PRO_20A_MAIN			EQU 235  
  00EC                 531     ZTW_SPIDER_PRO_20A_TAIL			EQU 236  
  00ED                 532     ZTW_SPIDER_PRO_20A_MULTI			EQU 237  
  00EE                 533     ZTW_SPIDER_PRO_20A_PREMIUM_MAIN	EQU 238  
  00EF                 534     ZTW_SPIDER_PRO_20A_PREMIUM_TAIL	EQU 239  
  00F0                 535     ZTW_SPIDER_PRO_20A_PREMIUM_MULTI	EQU 240  
  00F1                 536     ZTW_SPIDER_PRO_20A_HV_MAIN		EQU 241  
  00F2                 537     ZTW_SPIDER_PRO_20A_HV_TAIL		EQU 242  
  00F3                 538     ZTW_SPIDER_PRO_20A_HV_MULTI		EQU 243  
  00F4                 539     ZTW_SPIDER_PRO_30A_HV_MAIN		EQU 244  
  00F5                 540     ZTW_SPIDER_PRO_30A_HV_TAIL		EQU 245  
  00F6                 541     ZTW_SPIDER_PRO_30A_HV_MULTI		EQU 246  
  00F7                 542     DYS_XM20A_MAIN					EQU 247  
  00F8                 543     DYS_XM20A_TAIL					EQU 248  
  00F9                 544     DYS_XM20A_MULTI				EQU 249  
  00FA                 545     OVERSKY_MR_20A_MAIN				EQU 250  
  00FB                 546     OVERSKY_MR_20A_TAIL				EQU 251  
  00FC                 547     OVERSKY_MR_20A_MULTI			EQU 252  
  00FD                 548     OVERSKY_MR_20A_PRO_MAIN			EQU 253  
  00FE                 549     OVERSKY_MR_20A_PRO_TAIL			EQU 254  
  00FF                 550     OVERSKY_MR_20A_PRO_MULTI			EQU 255  
  0100                 551     TBS_CUBE_12A_MAIN				EQU 256 
  0101                 552     TBS_CUBE_12A_TAIL				EQU 257  
  0102                 553     TBS_CUBE_12A_MULTI				EQU 258  
  0103                 554     DALRC_XR20A_MAIN				EQU 259  
  0104                 555     DALRC_XR20A_TAIL				EQU 260  
  0105                 556     DALRC_XR20A_MULTI				EQU 261  
  0106                 557     AIKON_BOLTLITE_30A_MAIN			EQU 262  
  0107                 558     AIKON_BOLTLITE_30A_TAIL			EQU 263  
  0108                 559     AIKON_BOLTLITE_30A_MULTI			EQU 264
  0109                 560     ALIGN_MR25_15A_MAIN				EQU 265   
  010A                 561     ALIGN_MR25_15A_TAIL 			EQU 266  
  010B                 562     ALIGN_MR25_15A_MULTI 			EQU 267   
  010C                 563     SERVOKING_MONSTER_30A_MAIN		EQU 268   
  010D                 564     SERVOKING_MONSTER_30A_TAIL 		EQU 269  
  010E                 565     SERVOKING_MONSTER_30A_MULTI 		EQU 270   
  010F                 566     SERVOKING_MONSTER_30A_PRO_MAIN	EQU 271   
  0110                 567     SERVOKING_MONSTER_30A_PRO_TAIL	EQU 272  
  0111                 568     SERVOKING_MONSTER_30A_PRO_MULTI	EQU 273   
  0112                 569     SERVOKING_MONSTER_80A_MAIN		EQU 274   
  0113                 570     SERVOKING_MONSTER_80A_TAIL 		EQU 275  
  0114                 571     SERVOKING_MONSTER_80A_MULTI 		EQU 276   
  0115                 572     HTIRC_HUMMINGBIRD_12A_MAIN		EQU 277   
  0116                 573     HTIRC_HUMMINGBIRD_12A_TAIL 		EQU 278  
  0117                 574     HTIRC_HUMMINGBIRD_12A_MULTI 		EQU 279   
  0118                 575     HTIRC_HUMMINGBIRD_20A_MAIN		EQU 280   
  0119                 576     HTIRC_HUMMINGBIRD_20A_TAIL 		EQU 281  
  011A                 577     HTIRC_HUMMINGBIRD_20A_MULTI 		EQU 282   
  011B                 578     HTIRC_HUMMINGBIRD_30A_PRO_MAIN	EQU 283   
  011C                 579     HTIRC_HUMMINGBIRD_30A_PRO_TAIL	EQU 284  
  011D                 580     HTIRC_HUMMINGBIRD_30A_PRO_MULTI	EQU 285   
                       581       
                       582     
                       583     
                       584     ;**** **** **** **** ****
                       585     ; Select the ESC and mode to use (or unselect all for use with external batch compile file)
                       586     ;BESCNO EQU XP_3A_Main 
                       587     ;BESCNO EQU XP_3A_Tail
                       588     ;BESCNO EQU XP_3A_Multi
                       589     ;BESCNO EQU XP_7A_Main
                       590     ;BESCNO EQU XP_7A_Tail
                       591     ;BESCNO EQU XP_7A_Multi 	
                       592     ;BESCNO EQU XP_7A_Fast_Main
                       593     ;BESCNO EQU XP_7A_Fast_Tail
                       594     ;BESCNO EQU XP_7A_Fast_Multi
                       595     ;BESCNO EQU XP_12A_Main
                       596     ;BESCNO EQU XP_12A_Tail 
                       597     ;BESCNO EQU XP_12A_Multi
                       598     ;BESCNO EQU XP_18A_Main 
                       599     ;BESCNO EQU XP_18A_Tail 
                       600     ;BESCNO EQU XP_18A_Multi
                       601     ;BESCNO EQU XP_25A_Main 
                       602     ;BESCNO EQU XP_25A_Tail 
                       603     ;BESCNO EQU XP_25A_Multi
                       604     ;BESCNO EQU XP_35A_SW_Main
                       605     ;BESCNO EQU XP_35A_SW_Tail 
                       606     ;BESCNO EQU XP_35A_SW_Multi
                       607     ;BESCNO EQU DP_3A_Main 						
                       608     ;BESCNO EQU DP_3A_Tail 
                       609     ;BESCNO EQU DP_3A_Multi 
                       610     ;BESCNO EQU Supermicro_3p5A_Main
                       611     ;BESCNO EQU Supermicro_3p5A_Tail 
                       612     ;BESCNO EQU Supermicro_3p5A_Multi
                       613     ;BESCNO EQU Turnigy_Plush_6A_Main 
                       614     ;BESCNO EQU Turnigy_Plush_6A_Tail 
                       615     ;BESCNO EQU Turnigy_Plush_6A_Multi
                       616     ;BESCNO EQU Turnigy_Plush_10A_Main 
                       617     ;BESCNO EQU Turnigy_Plush_10A_Tail 
                       618     ;BESCNO EQU Turnigy_Plush_10A_Multi
                       619     ;BESCNO EQU Turnigy_Plush_12A_Main 
                       620     ;BESCNO EQU Turnigy_Plush_12A_Tail 
                       621     ;BESCNO EQU Turnigy_Plush_12A_Multi 
                       622     ;BESCNO EQU Turnigy_Plush_18A_Main 
                       623     ;BESCNO EQU Turnigy_Plush_18A_Tail 
                       624     ;BESCNO EQU Turnigy_Plush_18A_Multi
                       625     ;BESCNO EQU Turnigy_Plush_25A_Main 
                       626     ;BESCNO EQU Turnigy_Plush_25A_Tail
                       627     ;BESCNO EQU Turnigy_Plush_25A_Multi
                       628     ;BESCNO EQU Turnigy_Plush_30A_Main 
                       629     ;BESCNO EQU Turnigy_Plush_30A_Tail 
                       630     ;BESCNO EQU Turnigy_Plush_30A_Multi
                       631     ;BESCNO EQU Turnigy_Plush_40A_Main 
                       632     ;BESCNO EQU Turnigy_Plush_40A_Tail 
                       633     ;BESCNO EQU Turnigy_Plush_40A_Multi 
                       634     ;BESCNO EQU Turnigy_Plush_60A_Main
                       635     ;BESCNO EQU Turnigy_Plush_60A_Tail 
                       636     ;BESCNO EQU Turnigy_Plush_60A_Multi
                       637     ;BESCNO EQU Turnigy_Plush_80A_Main
                       638     ;BESCNO EQU Turnigy_Plush_80A_Tail 
                       639     ;BESCNO EQU Turnigy_Plush_80A_Multi
                       640     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Main
                       641     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Tail 
                       642     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Multi 
                       643     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Main 
                       644     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Tail
                       645     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Multi
                       646     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Main  
                       647     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Tail 
                       648     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Multi
                       649     ;BESCNO EQU Turnigy_AE_20A_Main 
                       650     ;BESCNO EQU Turnigy_AE_20A_Tail 
                       651     ;BESCNO EQU Turnigy_AE_20A_Multi
                       652     ;BESCNO EQU Turnigy_AE_25A_Main 
                       653     ;BESCNO EQU Turnigy_AE_25A_Tail 
                       654     ;BESCNO EQU Turnigy_AE_25A_Multi
                       655     ;BESCNO EQU Turnigy_AE_30A_Main 
                       656     ;BESCNO EQU Turnigy_AE_30A_Tail 
                       657     ;BESCNO EQU Turnigy_AE_30A_Multi
                       658     ;BESCNO EQU Turnigy_AE_45A_Main
                       659     ;BESCNO EQU Turnigy_AE_45A_Tail 
                       660     ;BESCNO EQU Turnigy_AE_45A_Multi
                       661     ;BESCNO EQU Turnigy_KForce_40A_Main
                       662     ;BESCNO EQU Turnigy_KForce_40A_Tail 
                       663     ;BESCNO EQU Turnigy_KForce_40A_Multi 
                       664     ;BESCNO EQU Turnigy_KForce_70A_HV_Main
                       665     ;BESCNO EQU Turnigy_KForce_70A_HV_Tail 
                       666     ;BESCNO EQU Turnigy_KForce_70A_HV_Multi
                       667     ;BESCNO EQU Turnigy_KForce_120A_HV_Main
                       668     ;BESCNO EQU Turnigy_KForce_120A_HV_Tail 
                       669     ;BESCNO EQU Turnigy_KForce_120A_HV_Multi
                       670     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Main
                       671     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Tail 
                       672     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Multi
                       673     ;BESCNO EQU Skywalker_20A_Main
                       674     ;BESCNO EQU Skywalker_20A_Tail
                       675     ;BESCNO EQU Skywalker_20A_Multi 
                       676     ;BESCNO EQU Skywalker_40A_Main 
                       677     ;BESCNO EQU Skywalker_40A_Tail 
                       678     ;BESCNO EQU Skywalker_40A_Multi
                       679     ;BESCNO EQU HiModel_Cool_22A_Main
                       680     ;BESCNO EQU HiModel_Cool_22A_Tail
                       681     ;BESCNO EQU HiModel_Cool_22A_Multi
                       682     ;BESCNO EQU HiModel_Cool_33A_Main
                       683     ;BESCNO EQU HiModel_Cool_33A_Tail
                       684     ;BESCNO EQU HiModel_Cool_33A_Multi
                       685     ;BESCNO EQU HiModel_Cool_41A_Main
                       686     ;BESCNO EQU HiModel_Cool_41A_Tail
                       687     ;BESCNO EQU HiModel_Cool_41A_Multi
                       688     ;BESCNO EQU RCTimer_6A_Main
                       689     ;BESCNO EQU RCTimer_6A_Tail
                       690     ;BESCNO EQU RCTimer_6A_Multi
                       691     ;BESCNO EQU Align_RCE_BL15X_Main
                       692     ;BESCNO EQU Align_RCE_BL15X_Tail
                       693     ;BESCNO EQU Align_RCE_BL15X_Multi
                       694     ;BESCNO EQU Align_RCE_BL15P_Main
                       695     ;BESCNO EQU Align_RCE_BL15P_Tail
                       696     ;BESCNO EQU Align_RCE_BL15P_Multi 
                       697     ;BESCNO EQU Align_RCE_BL35X_Main 
                       698     ;BESCNO EQU Align_RCE_BL35X_Tail
                       699     ;BESCNO EQU Align_RCE_BL35X_Multi
                       700     ;BESCNO EQU Align_RCE_BL35P_Main
                       701     ;BESCNO EQU Align_RCE_BL35P_Tail
                       702     ;BESCNO EQU Align_RCE_BL35P_Multi
                       703     ;BESCNO EQU Gaui_GE_183_18A_Main
                       704     ;BESCNO EQU Gaui_GE_183_18A_Tail
                       705     ;BESCNO EQU Gaui_GE_183_18A_Multi
                       706     ;BESCNO EQU H_King_10A_Main 
                       707     ;BESCNO EQU H_King_10A_Tail 
                       708     ;BESCNO EQU H_King_10A_Multi
                       709     ;BESCNO EQU H_King_20A_Main
                       710     ;BESCNO EQU H_King_20A_Tail
                       711     ;BESCNO EQU H_King_20A_Multi
                       712     ;BESCNO EQU H_King_35A_Main
                       713     ;BESCNO EQU H_King_35A_Tail
                       714     ;BESCNO EQU H_King_35A_Multi
                       715     ;BESCNO EQU H_King_50A_Main
                       716     ;BESCNO EQU H_King_50A_Tail
                       717     ;BESCNO EQU H_King_50A_Multi
                       718     ;BESCNO EQU Polaris_Thunder_12A_Main
                       719     ;BESCNO EQU Polaris_Thunder_12A_Tail
                       720     ;BESCNO EQU Polaris_Thunder_12A_Multi
                       721     ;BESCNO EQU Polaris_Thunder_20A_Main
                       722     ;BESCNO EQU Polaris_Thunder_20A_Tail
                       723     ;BESCNO EQU Polaris_Thunder_20A_Multi
                       724     ;BESCNO EQU Polaris_Thunder_30A_Main
                       725     ;BESCNO EQU Polaris_Thunder_30A_Tail
                       726     ;BESCNO EQU Polaris_Thunder_30A_Multi
                       727     ;BESCNO EQU Polaris_Thunder_40A_Main
                       728     ;BESCNO EQU Polaris_Thunder_40A_Tail
                       729     ;BESCNO EQU Polaris_Thunder_40A_Multi
                       730     ;BESCNO EQU Polaris_Thunder_60A_Main
                       731     ;BESCNO EQU Polaris_Thunder_60A_Tail
                       732     ;BESCNO EQU Polaris_Thunder_60A_Multi
                       733     ;BESCNO EQU Polaris_Thunder_80A_Main
                       734     ;BESCNO EQU Polaris_Thunder_80A_Tail
                       735     ;BESCNO EQU Polaris_Thunder_80A_Multi
                       736     ;BESCNO EQU Polaris_Thunder_100A_Main
                       737     ;BESCNO EQU Polaris_Thunder_100A_Tail
                       738     ;BESCNO EQU Polaris_Thunder_100A_Multi
                       739     ;BESCNO EQU Platinum_Pro_30A_Main
                       740     ;BESCNO EQU Platinum_Pro_30A_Tail
                       741     ;BESCNO EQU Platinum_Pro_30A_Multi 
                       742     ;BESCNO EQU Platinum_Pro_150A_Main
                       743     ;BESCNO EQU Platinum_Pro_150A_Tail
                       744     ;BESCNO EQU Platinum_Pro_150A_Multi
                       745     ;BESCNO EQU Platinum_50Av3_Main
                       746     ;BESCNO EQU Platinum_50Av3_Tail
                       747     ;BESCNO EQU Platinum_50Av3_Multi 
                       748     ;BESCNO EQU EAZY_3Av2_Main
                       749     ;BESCNO EQU EAZY_3Av2_Tail
                       750     ;BESCNO EQU EAZY_3Av2_Multi
                       751     ;BESCNO EQU Tarot_30A_Main
                       752     ;BESCNO EQU Tarot_30A_Tail
                       753     ;BESCNO EQU Tarot_30A_Multi
                       754     ;BESCNO EQU SkyIII_30A_Main
                       755     ;BESCNO EQU SkyIII_30A_Tail
                       756     ;BESCNO EQU SkyIII_30A_Multi
                       757     ;BESCNO EQU EMAX_20A_Main
                       758     ;BESCNO EQU EMAX_20A_Tail
                       759     ;BESCNO EQU EMAX_20A_Multi 
                       760     ;BESCNO EQU EMAX_40A_Main
                       761     ;BESCNO EQU EMAX_40A_Tail
                       762     ;BESCNO EQU EMAX_40A_Multi 
                       763     ;BESCNO EQU EMAX_Nano_20A_Main
                       764     ;BESCNO EQU EMAX_Nano_20A_Tail
                       765     ;BESCNO EQU EMAX_Nano_20A_Multi 
                       766     ;BESCNO EQU EMAX_Lightning_20A_Main
                       767     ;BESCNO EQU EMAX_Lightning_20A_Tail
                       768     ;BESCNO EQU EMAX_Lightning_20A_Multi 
                       769     ;BESCNO EQU XRotor_10A_Main 
                       770     ;BESCNO EQU XRotor_10A_Tail
                       771     ;BESCNO EQU XRotor_10A_Multi 
                       772     ;BESCNO EQU XRotor_20A_Main
                       773     ;BESCNO EQU XRotor_20A_Tail
                       774     ;BESCNO EQU XRotor_20A_Multi 
                       775     ;BESCNO EQU XRotor_40A_Main
                       776     ;BESCNO EQU XRotor_40A_Tail
                       777     ;BESCNO EQU XRotor_40A_Multi 
                       778     ;BESCNO EQU MDRX62H_Main
                       779     ;BESCNO EQU MDRX62H_Tail
                       780     ;BESCNO EQU MDRX62H_Multi 
                       781     ;BESCNO EQU RotorGeeks_20A_Main
                       782     ;BESCNO EQU RotorGeeks_20A_Tail
                       783     ;BESCNO EQU RotorGeeks_20A_Multi
                       784     ;BESCNO EQU RotorGeeks_20A_Plus_Main
                       785     ;BESCNO EQU RotorGeeks_20A_Plus_Tail
                       786     ;BESCNO EQU RotorGeeks_20A_Plus_Multi
                       787     ;BESCNO EQU Flycolor_Fairy_6A_Main
                       788     ;BESCNO EQU Flycolor_Fairy_6A_Tail
                       789     ;BESCNO EQU Flycolor_Fairy_6A_Multi
                       790     ;BESCNO EQU Flycolor_Fairy_30A_Main
                       791     ;BESCNO EQU Flycolor_Fairy_30A_Tail
                       792     ;BESCNO EQU Flycolor_Fairy_30A_Multi
                       793     ;BESCNO EQU Flycolor_Fairy_V2_30A_Main
                       794     ;BESCNO EQU Flycolor_Fairy_V2_30A_Tail
                       795     ;BESCNO EQU Flycolor_Fairy_V2_30A_Multi 
                       796     ;BESCNO EQU Flycolor_Raptor_20A_Main
                       797     ;BESCNO EQU Flycolor_Raptor_20A_Tail
                       798     ;BESCNO EQU Flycolor_Raptor_20A_Multi 
                       799     ;BESCNO EQU Flycolor_Raptor_390_20A_Main
                       800     ;BESCNO EQU Flycolor_Raptor_390_20A_Tail
                       801     ;BESCNO EQU Flycolor_Raptor_390_20A_Multi
                       802     ;BESCNO EQU FVT_Littlebee_12A_Main
                       803     ;BESCNO EQU FVT_Littlebee_12A_Tail
                       804     ;BESCNO EQU FVT_Littlebee_12A_Multi
                       805     ;BESCNO EQU FVT_Littlebee_20A_Main
                       806     ;BESCNO EQU FVT_Littlebee_20A_Tail
                       807     ;BESCNO EQU FVT_Littlebee_20A_Multi 
                       808     ;BESCNO EQU FVT_Littlebee_20A_Pro_Main
                       809     ;BESCNO EQU FVT_Littlebee_20A_Pro_Tail
                       810     ;BESCNO EQU FVT_Littlebee_20A_Pro_Multi 
                       811     ;BESCNO EQU FVT_Littlebee_30A_Main
                       812     ;BESCNO EQU FVT_Littlebee_30A_Tail
                       813     ;BESCNO EQU FVT_Littlebee_30A_Multi 
                       814     ;BESCNO EQU Graupner_Ultra_20A_Main
                       815     ;BESCNO EQU Graupner_Ultra_20A_Tail
                       816     ;BESCNO EQU Graupner_Ultra_20A_Multi 
                       817     ;BESCNO EQU F85_3A_Main
                       818     ;BESCNO EQU F85_3A_Tail
                       819     ;BESCNO EQU F85_3A_Multi
                       820     ;BESCNO EQU ZTW_Spider_Pro_20A_Main
                       821     ;BESCNO EQU ZTW_Spider_Pro_20A_Tail
                       822     ;BESCNO EQU ZTW_Spider_Pro_20A_Multi 
                       823     ;BESCNO EQU ZTW_Spider_Pro_20A_Premium_Main
                       824     ;BESCNO EQU ZTW_Spider_Pro_20A_Premium_Tail
                       825     ;BESCNO EQU ZTW_Spider_Pro_20A_Premium_Multi
                       826     ;BESCNO EQU ZTW_Spider_Pro_20A_HV_Main
                       827     ;BESCNO EQU ZTW_Spider_Pro_20A_HV_Tail
                       828     ;BESCNO EQU ZTW_Spider_Pro_20A_HV_Multi 
                       829     ;BESCNO EQU ZTW_Spider_Pro_30A_HV_Main
                       830     ;BESCNO EQU ZTW_Spider_Pro_30A_HV_Tail
                       831     ;BESCNO EQU ZTW_Spider_Pro_30A_HV_Multi 
                       832     ;BESCNO EQU DYS_XM20A_Main
                       833     ;BESCNO EQU DYS_XM20A_Tail
                       834     ;BESCNO EQU DYS_XM20A_Multi
                       835     ;BESCNO EQU Oversky_MR_20A_Main
                       836     ;BESCNO EQU Oversky_MR_20A_Tail
                       837     ;BESCNO EQU Oversky_MR_20A_Multi 
                       838     ;BESCNO EQU Oversky_MR_20A_Pro_Main
                       839     ;BESCNO EQU Oversky_MR_20A_Pro_Tail
                       840     ;BESCNO EQU Oversky_MR_20A_Pro_Multi
                       841     ;BESCNO EQU TBS_Cube_12A_Main	 
                       842     ;BESCNO EQU TBS_Cube_12A_Tail	  
                       843     ;BESCNO EQU TBS_Cube_12A_Multi 
                       844     ;BESCNO EQU DALRC_XR20A_Main	 
                       845     ;BESCNO EQU DALRC_XR20A_Tail	  
                       846     ;BESCNO EQU DALRC_XR20A_Multi 	 
                       847     ;BESCNO EQU AIKON_Boltlite_30A_Main	 
                       848     ;BESCNO EQU AIKON_Boltlite_30A_Tail	  
                       849     ;BESCNO EQU AIKON_Boltlite_30A_Multi 
                       850     ;BESCNO EQU Align_MR25_15A_Main	 
                       851     ;BESCNO EQU Align_MR25_15A_Tail	  
                       852     ;BESCNO EQU Align_MR25_15A_Multi
                       853     ;BESCNO EQU Servoking_Monster_30A_Main	 
                       854     ;BESCNO EQU Servoking_Monster_30A_Tail	  
                       855     ;BESCNO EQU Servoking_Monster_30A_Multi 
                       856     ;BESCNO EQU Servoking_Monster_30A_Pro_Main	 
                       857     ;BESCNO EQU Servoking_Monster_30A_Pro_Tail	  
                       858     ;BESCNO EQU Servoking_Monster_30A_Pro_Multi 
                       859     ;BESCNO EQU Servoking_Monster_80A_Main	 
                       860     ;BESCNO EQU Servoking_Monster_80A_Tail	  
                       861     ;BESCNO EQU Servoking_Monster_80A_Multi 
                       862     ;BESCNO EQU HTIRC_Hummingbird_12A_Main	 
                       863     ;BESCNO EQU HTIRC_Hummingbird_12A_Tail 	 
                       864     ;BESCNO EQU HTIRC_Hummingbird_12A_Multi  
                       865     ;BESCNO EQU HTIRC_Hummingbird_20A_Main	 
                       866     ;BESCNO EQU HTIRC_Hummingbird_20A_Tail 	 
                       867     ;BESCNO EQU HTIRC_Hummingbird_20A_Multi  
                       868     ;BESCNO EQU HTIRC_Hummingbird_30A_Pro_Main	 
                       869     ;BESCNO EQU HTIRC_Hummingbird_30A_Pro_Tail 	 
                       870     ;BESCNO EQU HTIRC_Hummingbird_30A_Pro_Multi  
                       871     
                       872     
                       873     ;**** **** **** **** ****
                       874     ; ESC selection statements
                       875     IF BESCNO == XP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       879     
                       880     IF BESCNO == XP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       884     
                       885     IF BESCNO == XP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       889     
                       890     IF BESCNO == XP_7A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       894     
                       895     IF BESCNO == XP_7A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       899     
                       900     IF BESCNO == XP_7A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       904     
                       905     IF BESCNO == XP_7A_FAST_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       909     
                       910     IF BESCNO == XP_7A_FAST_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       914     
                       915     IF BESCNO == XP_7A_FAST_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       919     
                       920     IF BESCNO == XP_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       924     
                       925     IF BESCNO == XP_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       929     
                       930     IF BESCNO == XP_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       934     
                       935     IF BESCNO == XP_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       939     
                       940     IF BESCNO == XP_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       944     
                       945     IF BESCNO == XP_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       949     
                       950     IF BESCNO == XP_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       954     
                       955     IF BESCNO == XP_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       959     
                       960     IF BESCNO == XP_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       964     
                       965     IF BESCNO == XP_35A_SW_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       969     
                       970     IF BESCNO == XP_35A_SW_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       974     
                       975     IF BESCNO == XP_35A_SW_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       979     
                       980     IF BESCNO == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       984     
                       985     IF BESCNO == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       989     
                       990     IF BESCNO == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       994     
                       995     IF BESCNO == SUPERMICRO_3P5A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       999     
                      1000     IF BESCNO == SUPERMICRO_3P5A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                      1004     
                      1005     IF BESCNO == SUPERMICRO_3P5A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                      1009     
                      1010     IF BESCNO == TURNIGY_PLUSH_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                      1014     
                      1015     IF BESCNO == TURNIGY_PLUSH_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                      1019     
                      1020     IF BESCNO == TURNIGY_PLUSH_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                      1024     
                      1025     IF BESCNO == TURNIGY_PLUSH_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                      1029     
                      1030     IF BESCNO == TURNIGY_PLUSH_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                      1034     
                      1035     IF BESCNO == TURNIGY_PLUSH_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                      1039     
                      1040     IF BESCNO == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                      1044     
                      1045     IF BESCNO == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                      1049     
                      1050     IF BESCNO == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                      1054     
                      1055     IF BESCNO == TURNIGY_PLUSH_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                      1059     
                      1060     IF BESCNO == TURNIGY_PLUSH_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                      1064     
                      1065     IF BESCNO == TURNIGY_PLUSH_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                      1069     
                      1070     IF BESCNO == TURNIGY_PLUSH_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                      1074     
                      1075     IF BESCNO == TURNIGY_PLUSH_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                      1079     
                      1080     IF BESCNO == TURNIGY_PLUSH_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                      1084     
                      1085     IF BESCNO == TURNIGY_PLUSH_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                      1089     
                      1090     IF BESCNO == TURNIGY_PLUSH_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                      1094     
                      1095     IF BESCNO == TURNIGY_PLUSH_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                      1099     
                      1100     IF BESCNO == TURNIGY_PLUSH_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                      1104     
                      1105     IF BESCNO == TURNIGY_PLUSH_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                      1109     
                      1110     IF BESCNO == TURNIGY_PLUSH_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                      1114     
                      1115     IF BESCNO == TURNIGY_PLUSH_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                      1119     
                      1120     IF BESCNO == TURNIGY_PLUSH_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                      1124     
                      1125     IF BESCNO == TURNIGY_PLUSH_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                      1129     
                      1130     IF BESCNO == TURNIGY_PLUSH_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                      1134     
                      1135     IF BESCNO == TURNIGY_PLUSH_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                      1139     
                      1140     IF BESCNO == TURNIGY_PLUSH_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                      1144     
                      1145     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                      1149     
                      1150     IF BESCNO == TURNIGY_PLUSH_NFET_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                      1154     
                      1155     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                      1159     
                      1160     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1164     
                      1165     IF BESCNO == TURNIGY_PLUSH_NFET_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1169     
                      1170     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1174     
                      1175     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1179     
                      1180     IF BESCNO == TURNIGY_PLUSH_NFET_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1184     
                      1185     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1189     
                      1190     IF BESCNO == TURNIGY_AE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1194     
                      1195     IF BESCNO == TURNIGY_AE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1199     
                      1200     IF BESCNO == TURNIGY_AE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1204     
                      1205     IF BESCNO == TURNIGY_AE_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1209     
                      1210     IF BESCNO == TURNIGY_AE_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1214     
                      1215     IF BESCNO == TURNIGY_AE_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1219     
                      1220     IF BESCNO == TURNIGY_AE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1224     
                      1225     IF BESCNO == TURNIGY_AE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1229     
                      1230     IF BESCNO == TURNIGY_AE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1234     
                      1235     IF BESCNO == TURNIGY_AE_45A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1239     
                      1240     IF BESCNO == TURNIGY_AE_45A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1244     
                      1245     IF BESCNO == TURNIGY_AE_45A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1249     
                      1250     IF BESCNO == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1254     
                      1255     IF BESCNO == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1259     
                      1260     IF BESCNO == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1264     
                      1265     IF BESCNO == TURNIGY_KFORCE_70A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1269     
                      1270     IF BESCNO == TURNIGY_KFORCE_70A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1274     
                      1275     IF BESCNO == TURNIGY_KFORCE_70A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1279     
                      1280     IF BESCNO == TURNIGY_KFORCE_120A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1284     
                      1285     IF BESCNO == TURNIGY_KFORCE_120A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1289     
                      1290     IF BESCNO == TURNIGY_KFORCE_120A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1294     
                      1295     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1299     
                      1300     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1304     
                      1305     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1309     
                      1310     IF BESCNO == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1314     
                      1315     IF BESCNO == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1319     
                      1320     IF BESCNO == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1324     
                      1325     IF BESCNO == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1329     
                      1330     IF BESCNO == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1334     
                      1335     IF BESCNO == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1339     
                      1340     IF BESCNO == HIMODEL_COOL_22A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1344     
                      1345     IF BESCNO == HIMODEL_COOL_22A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1349     
                      1350     IF BESCNO == HIMODEL_COOL_22A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1354     
                      1355     IF BESCNO == HIMODEL_COOL_33A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1359     
                      1360     IF BESCNO == HIMODEL_COOL_33A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1364     
                      1365     IF BESCNO == HIMODEL_COOL_33A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1369     
                      1370     IF BESCNO == HIMODEL_COOL_41A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1374     
                      1375     IF BESCNO == HIMODEL_COOL_41A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1379     
                      1380     IF BESCNO == HIMODEL_COOL_41A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1384     
                      1385     IF BESCNO == RCTIMER_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1389     
                      1390     IF BESCNO == RCTIMER_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1394     
                      1395     IF BESCNO == RCTIMER_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1399     
                      1400     IF BESCNO == ALIGN_RCE_BL15X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1404     
                      1405     IF BESCNO == ALIGN_RCE_BL15X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1409     
                      1410     IF BESCNO == ALIGN_RCE_BL15X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1414     
                      1415     IF BESCNO == ALIGN_RCE_BL15P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1419     
                      1420     IF BESCNO == ALIGN_RCE_BL15P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1424     
                      1425     IF BESCNO == ALIGN_RCE_BL15P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1429     
                      1430     IF BESCNO == ALIGN_RCE_BL35X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1434     
                      1435     IF BESCNO == ALIGN_RCE_BL35X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1439     
                      1440     IF BESCNO == ALIGN_RCE_BL35X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1444     
                      1445     IF BESCNO == ALIGN_RCE_BL35P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1449     
                      1450     IF BESCNO == ALIGN_RCE_BL35P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1454     
                      1455     IF BESCNO == ALIGN_RCE_BL35P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1459     
                      1460     IF BESCNO == GAUI_GE_183_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1464     
                      1465     IF BESCNO == GAUI_GE_183_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1469     
                      1470     IF BESCNO == GAUI_GE_183_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1474     
                      1475     IF BESCNO == H_KING_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1479     
                      1480     IF BESCNO == H_KING_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1484     
                      1485     IF BESCNO == H_KING_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1489     
                      1490     IF BESCNO == H_KING_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1494     
                      1495     IF BESCNO == H_KING_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1499     
                      1500     IF BESCNO == H_KING_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1504     
                      1505     IF BESCNO == H_KING_35A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1509     
                      1510     IF BESCNO == H_KING_35A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1514     
                      1515     IF BESCNO == H_KING_35A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1519     
                      1520     IF BESCNO == H_KING_50A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1524     
                      1525     IF BESCNO == H_KING_50A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1529     
                      1530     IF BESCNO == H_KING_50A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1534     
                      1535     IF BESCNO == POLARIS_THUNDER_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1539     
                      1540     IF BESCNO == POLARIS_THUNDER_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1544     
                      1545     IF BESCNO == POLARIS_THUNDER_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1549     
                      1550     IF BESCNO == POLARIS_THUNDER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1554     
                      1555     IF BESCNO == POLARIS_THUNDER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1559     
                      1560     IF BESCNO == POLARIS_THUNDER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1564     
                      1565     IF BESCNO == POLARIS_THUNDER_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1569     
                      1570     IF BESCNO == POLARIS_THUNDER_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1574     
                      1575     IF BESCNO == POLARIS_THUNDER_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1579     
                      1580     IF BESCNO == POLARIS_THUNDER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1584     
                      1585     IF BESCNO == POLARIS_THUNDER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1589     
                      1590     IF BESCNO == POLARIS_THUNDER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1594     
                      1595     IF BESCNO == POLARIS_THUNDER_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1599     
                      1600     IF BESCNO == POLARIS_THUNDER_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1604     
                      1605     IF BESCNO == POLARIS_THUNDER_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1609     
                      1610     IF BESCNO == POLARIS_THUNDER_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1614     
                      1615     IF BESCNO == POLARIS_THUNDER_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1619     
                      1620     IF BESCNO == POLARIS_THUNDER_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1624     
                      1625     IF BESCNO == POLARIS_THUNDER_100A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1629     
                      1630     IF BESCNO == POLARIS_THUNDER_100A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1634     
                      1635     IF BESCNO == POLARIS_THUNDER_100A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1639     
                      1640     IF BESCNO == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1644     
                      1645     IF BESCNO == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1649     
                      1650     IF BESCNO == PLATINUM_PRO_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1654     
                      1655     IF BESCNO == PLATINUM_PRO_150A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1659     
                      1660     IF BESCNO == PLATINUM_PRO_150A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1664     
                      1665     IF BESCNO == PLATINUM_PRO_150A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1669     
                      1670     IF BESCNO == PLATINUM_50AV3_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1674     
                      1675     IF BESCNO == PLATINUM_50AV3_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1679     
                      1680     IF BESCNO == PLATINUM_50AV3_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1684     
                      1685     IF BESCNO == EAZY_3AV2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1689     
                      1690     IF BESCNO == EAZY_3AV2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1694     
                      1695     IF BESCNO == EAZY_3AV2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1699     
                      1700     IF BESCNO == TAROT_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1704     
                      1705     IF BESCNO == TAROT_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1709     
                      1710     IF BESCNO == TAROT_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1714     
                      1715     IF BESCNO == SKYIII_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1719     
                      1720     IF BESCNO == SKYIII_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1724     
                      1725     IF BESCNO == SKYIII_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1729     
                      1730     IF BESCNO == EMAX_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1734     
                      1735     IF BESCNO == EMAX_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1739     
                      1740     IF BESCNO == EMAX_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1744     
                      1745     IF BESCNO == EMAX_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1749     
                      1750     IF BESCNO == EMAX_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1754     
                      1755     IF BESCNO == EMAX_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1759     
                      1760     IF BESCNO == EMAX_NANO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1764     
                      1765     IF BESCNO == EMAX_NANO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1769     
                      1770     IF BESCNO == EMAX_NANO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1774     
                      1775     IF BESCNO == EMAX_LIGHTNING_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_LIGHTNING_20A.INC)	; Select EMAX Lightning 20A pinout
                               ENDIF
                      1779     
                      1780     IF BESCNO == EMAX_LIGHTNING_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_LIGHTNING_20A.INC)	; Select EMAX Lightning 20A pinout
                               ENDIF
                      1784     
                      1785     IF BESCNO == EMAX_LIGHTNING_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_LIGHTNING_20A.INC)	; Select EMAX Lightning 20A pinout
                               ENDIF
                      1789     
                      1790     IF BESCNO == XROTOR_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1794     
                      1795     IF BESCNO == XROTOR_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1799     
                      1800     IF BESCNO == XROTOR_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1804     
                      1805     IF BESCNO == XROTOR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1809     
                      1810     IF BESCNO == XROTOR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1814     
                      1815     IF BESCNO == XROTOR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1819     
                      1820     IF BESCNO == XROTOR_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      1824     
                      1825     IF BESCNO == XROTOR_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      1829     
                      1830     IF BESCNO == XROTOR_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      1834     
                      1835     IF BESCNO == MDRX62H_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      1839     
                      1840     IF BESCNO == MDRX62H_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      1844     
                      1845     IF BESCNO == MDRX62H_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      1849     
                      1850     IF BESCNO == ROTORGEEKS_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      1854     
                      1855     IF BESCNO == ROTORGEEKS_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      1859     
                      1860     IF BESCNO == ROTORGEEKS_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      1864     
                      1865     IF BESCNO == ROTORGEEKS_20A_PLUS_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ROTORGEEKS_20A_PLUS.INC)	; Select RotorGeeks 20A Plus pinout
                               ENDIF
                      1869     
                      1870     IF BESCNO == ROTORGEEKS_20A_PLUS_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ROTORGEEKS_20A_PLUS.INC)	; Select RotorGeeks 20A Plus pinout
                               ENDIF
                      1874     
                      1875     IF BESCNO == ROTORGEEKS_20A_PLUS_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ROTORGEEKS_20A_PLUS.INC)	; Select RotorGeeks 20A Plus pinout
                               ENDIF
                      1879     
                      1880     IF BESCNO == FLYCOLOR_FAIRY_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      1884     
                      1885     IF BESCNO == FLYCOLOR_FAIRY_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      1889     
                      1890     IF BESCNO == FLYCOLOR_FAIRY_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      1894     
                      1895     IF BESCNO == FLYCOLOR_FAIRY_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      1899     
                      1900     IF BESCNO == FLYCOLOR_FAIRY_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      1904     
                      1905     IF BESCNO == FLYCOLOR_FAIRY_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      1909     
                      1910     IF BESCNO == FLYCOLOR_FAIRY_V2_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_V2_30A.INC)	; Select Flycolor Fairy V2 30A pinout
                               ENDIF
                      1914     
                      1915     IF BESCNO == FLYCOLOR_FAIRY_V2_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_V2_30A.INC)	; Select Flycolor Fairy V2 30A pinout
                               ENDIF
                      1919     
                      1920     IF BESCNO == FLYCOLOR_FAIRY_V2_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_V2_30A.INC)	; Select Flycolor Fairy V2 30A pinout
                               ENDIF
                      1924     
                      1925     IF BESCNO == FLYCOLOR_RAPTOR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_RAPTOR_20A.INC)	; Select Flycolor Raptor 20A pinout
                               ENDIF
                      1929     
                      1930     IF BESCNO == FLYCOLOR_RAPTOR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_RAPTOR_20A.INC)	; Select Flycolor Raptor 20A pinout
                               ENDIF
                      1934     
                      1935     IF BESCNO == FLYCOLOR_RAPTOR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_RAPTOR_20A.INC)	; Select Flycolor Raptor 20A pinout
                               ENDIF
                      1939     
                      1940     IF BESCNO == FLYCOLOR_RAPTOR_390_20A_MAIN
                               MODE 	EQU 	0					; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_RAPTOR_390_20A.INC)	; Select Flycolor Raptor 390 20A pinout
                               ENDIF
                      1944     
                      1945     IF BESCNO == FLYCOLOR_RAPTOR_390_20A_TAIL
                               MODE 	EQU 	1					; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_RAPTOR_390_20A.INC)	; Select Flycolor Raptor 390 20A pinout
                               ENDIF
                      1949     
                      1950     IF BESCNO == FLYCOLOR_RAPTOR_390_20A_MULTI
                               MODE 	EQU 	2					; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_RAPTOR_390_20A.INC)	; Select Flycolor Raptor 390 20A pinout
                               ENDIF
                      1954     
                      1955     IF BESCNO == FVT_LITTLEBEE_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_12A.INC)	; Select Favourite Littlebee 12A pinout
                               ENDIF
                      1959     
                      1960     IF BESCNO == FVT_LITTLEBEE_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_12A.INC)	; Select Favourite Littlebee 12A pinout
                               ENDIF
                      1964     
                      1965     IF BESCNO == FVT_LITTLEBEE_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_12A.INC)	; Select Favourite Littlebee 12A pinout
                               ENDIF
                      1969     
                      1970     IF BESCNO == FVT_LITTLEBEE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      1974     
                      1975     IF BESCNO == FVT_LITTLEBEE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      1979     
                      1980     IF BESCNO == FVT_LITTLEBEE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      1984     
                      1985     IF BESCNO == FVT_LITTLEBEE_20A_PRO_MAIN
                               MODE 	EQU 	0					; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_20A_PRO.INC)	; Select Favourite Littlebee 20A Pro pinout
                               ENDIF
                      1989     
                      1990     IF BESCNO == FVT_LITTLEBEE_20A_PRO_TAIL
                               MODE 	EQU 	1					; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_20A_PRO.INC)	; Select Favourite Littlebee 20A Pro pinout
                               ENDIF
                      1994     
                      1995     IF BESCNO == FVT_LITTLEBEE_20A_PRO_MULTI
                               MODE 	EQU 	2					; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_20A_PRO.INC)	; Select Favourite Littlebee 20A Pro pinout
                               ENDIF
                      1999     
                      2000     IF BESCNO == FVT_LITTLEBEE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2004     
                      2005     IF BESCNO == FVT_LITTLEBEE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2009     
                      2010     IF BESCNO == FVT_LITTLEBEE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2014     
                      2015     IF BESCNO == GRAUPNER_ULTRA_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2019     
                      2020     IF BESCNO == GRAUPNER_ULTRA_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2024     
                      2025     IF BESCNO == GRAUPNER_ULTRA_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2029     
                      2030     IF BESCNO == F85_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2034     
                      2035     IF BESCNO == F85_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2039     
                      2040     IF BESCNO == F85_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2044     
                      2045     IF BESCNO == ZTW_SPIDER_PRO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2049     
                      2050     IF BESCNO == ZTW_SPIDER_PRO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2054     
                      2055     IF BESCNO == ZTW_SPIDER_PRO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2059     
                      2060     IF BESCNO == ZTW_SPIDER_PRO_20A_PREMIUM_MAIN
                               MODE 	EQU 	0						; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_PREMIUM.INC)	; Select ZTW Spider Pro 20A Premium pinout
                               ENDIF
                      2064     
                      2065     IF BESCNO == ZTW_SPIDER_PRO_20A_PREMIUM_TAIL
                               MODE 	EQU 	1						; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_PREMIUM.INC)	; Select ZTW Spider Pro 20A Premium pinout
                               ENDIF
                      2069     
                      2070     IF BESCNO == ZTW_SPIDER_PRO_20A_PREMIUM_MULTI
                               MODE 	EQU 	2						; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_PREMIUM.INC)	; Select ZTW Spider Pro 20A Premium pinout
                               ENDIF
                      2074     
                      2075     IF BESCNO == ZTW_SPIDER_PRO_20A_HV_MAIN
                               MODE 	EQU 	0					; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_HV.INC)	; Select ZTW Spider Pro 20A HV pinout
                               ENDIF
                      2079     
                      2080     IF BESCNO == ZTW_SPIDER_PRO_20A_HV_TAIL
                               MODE 	EQU 	1					; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_HV.INC)	; Select ZTW Spider Pro 20A HV pinout
                               ENDIF
                      2084     
                      2085     IF BESCNO == ZTW_SPIDER_PRO_20A_HV_MULTI
                               MODE 	EQU 	2					; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_20A_HV.INC)	; Select ZTW Spider Pro 20A HV pinout
                               ENDIF
                      2089     
                      2090     IF BESCNO == ZTW_SPIDER_PRO_30A_HV_MAIN
                               MODE 	EQU 	0					; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_30A_HV.INC)	; Select ZTW Spider Pro 30A HV pinout
                               ENDIF
                      2094     
                      2095     IF BESCNO == ZTW_SPIDER_PRO_30A_HV_TAIL
                               MODE 	EQU 	1					; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_30A_HV.INC)	; Select ZTW Spider Pro 30A HV pinout
                               ENDIF
                      2099     
                      2100     IF BESCNO == ZTW_SPIDER_PRO_30A_HV_MULTI
                               MODE 	EQU 	2					; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_30A_HV.INC)	; Select ZTW Spider Pro 30A HV pinout
                               ENDIF
                      2104     
                      2105     IF BESCNO == DYS_XM20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DYS_XM20A.INC)			; Select DYS XM20A pinout
                               ENDIF
                      2109     
                      2110     IF BESCNO == DYS_XM20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DYS_XM20A.INC)			; Select DYS XM20A pinout
                               ENDIF
                      2114     
                      2115     IF BESCNO == DYS_XM20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DYS_XM20A.INC)			; Select DYS XM20A pinout
                               ENDIF
                      2119     
                      2120     IF BESCNO == OVERSKY_MR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (OVERSKY_MR_20A.INC)		; Select Oversky MR-20A pinout
                               ENDIF
                      2124     
                      2125     IF BESCNO == OVERSKY_MR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (OVERSKY_MR_20A.INC)		; Select Oversky MR-20A pinout
                               ENDIF
                      2129     
                      2130     IF BESCNO == OVERSKY_MR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (OVERSKY_MR_20A.INC)		; Select Oversky MR-20A pinout
                               ENDIF
                      2134     
                      2135     IF BESCNO == OVERSKY_MR_20A_PRO_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (OVERSKY_MR_20A_PRO.INC)	; Select Oversky MR-20A Pro pinout
                               ENDIF
                      2139     
                      2140     IF BESCNO == OVERSKY_MR_20A_PRO_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (OVERSKY_MR_20A_PRO.INC)	; Select Oversky MR-20A Pro pinout
                               ENDIF
                      2144     
                      2145     IF BESCNO == OVERSKY_MR_20A_PRO_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (OVERSKY_MR_20A_PRO.INC)	; Select Oversky MR-20A Pro pinout
                               ENDIF
                      2149     
                      2150     IF BESCNO == TBS_CUBE_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TBS_CUBE_12A.INC)		; Select TBS Cube 12A pinout
                               ENDIF
                      2154     
                      2155     IF BESCNO == TBS_CUBE_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TBS_CUBE_12A.INC)		; Select TBS Cube 12A pinout
                               ENDIF
                      2159     
                      2160     IF BESCNO == TBS_CUBE_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TBS_CUBE_12A.INC)		; Select TBS Cube 12A pinout
                               ENDIF
                      2164     
                      2165     IF BESCNO == DALRC_XR20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DALRC_XR20A.INC)		; Select DALRC 20A pinout
                               ENDIF
                      2169     
                      2170     IF BESCNO == DALRC_XR20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DALRC_XR20A.INC)		; Select DALRC 20A pinout
                               ENDIF
                      2174     
                      2175     IF BESCNO == DALRC_XR20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DALRC_XR20A.INC)		; Select DALRC 20A pinout
                               ENDIF
                      2179     
                      2180     IF BESCNO == AIKON_BOLTLITE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (AIKON_BOLTLITE_30A.INC)	; Select AIKON_Boltlite 30A pinout
                               ENDIF
                      2184     
                      2185     IF BESCNO == AIKON_BOLTLITE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (AIKON_BOLTLITE_30A.INC)	; Select AIKON_Boltlite 30A pinout
                               ENDIF
                      2189     
                      2190     IF BESCNO == AIKON_BOLTLITE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (AIKON_BOLTLITE_30A.INC)	; Select AIKON_Boltlite 30A pinout
                               ENDIF
                      2194     
                      2195     IF BESCNO == ALIGN_MR25_15A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_MR25_15A.INC)		; Select Align MR25 15A pinout
                               ENDIF
                      2199     
                      2200     IF BESCNO == ALIGN_MR25_15A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_MR25_15A.INC)		; Select Align MR25 15A pinout
                               ENDIF
                      2204     
                      2205     IF BESCNO == ALIGN_MR25_15A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_MR25_15A.INC)		; Select Align MR25 15A pinout
                               ENDIF
                      2209     
                      2210     IF BESCNO == SERVOKING_MONSTER_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SERVOKING_MONSTER_30A.INC)	; Select Servoking Monster 30A pinout
                               ENDIF
                      2214     
                      2215     IF BESCNO == SERVOKING_MONSTER_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SERVOKING_MONSTER_30A.INC)	; Select Servoking Monster 30A pinout
                               ENDIF
                      2219     
                      2220     IF BESCNO == SERVOKING_MONSTER_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SERVOKING_MONSTER_30A.INC)	; Select Servoking Monster 30A pinout
                               ENDIF
                      2224     
                      2225     IF BESCNO == SERVOKING_MONSTER_30A_PRO_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SERVOKING_MONSTER_30A_PRO.INC)	; Select Servoking Monster 30A Pro pinout
                               ENDIF
                      2229     
                      2230     IF BESCNO == SERVOKING_MONSTER_30A_PRO_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SERVOKING_MONSTER_30A_PRO.INC)	; Select Servoking Monster 30A Pro pinout
                               ENDIF
                      2234     
                      2235     IF BESCNO == SERVOKING_MONSTER_30A_PRO_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SERVOKING_MONSTER_30A_PRO.INC)	; Select Servoking Monster 30A Pro pinout
                               ENDIF
                      2239     
                      2240     IF BESCNO == SERVOKING_MONSTER_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SERVOKING_MONSTER_80A.INC)	; Select Servoking Monster 80A pinout
                               ENDIF
                      2244     
                      2245     IF BESCNO == SERVOKING_MONSTER_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SERVOKING_MONSTER_80A.INC)	; Select Servoking Monster 80A pinout
                               ENDIF
                      2249     
                      2250     IF BESCNO == SERVOKING_MONSTER_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SERVOKING_MONSTER_80A.INC)	; Select Servoking Monster 80A pinout
                               ENDIF
                      2254     
                      2255     IF BESCNO == HTIRC_HUMMINGBIRD_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_12A.INC)	; Select HTIRC Hummingbird 12A pinout
                               ENDIF
                      2259     
                      2260     IF BESCNO == HTIRC_HUMMINGBIRD_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_12A.INC)	; Select HTIRC Hummingbird 12A pinout
                               ENDIF
                      2264     
                      2265     IF BESCNO == HTIRC_HUMMINGBIRD_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HTIRC_HUMMINGBIRD_12A.INC)	; Select HTIRC Hummingbird 12A pinout
                               ENDIF
                      2269     
                      2270     IF BESCNO == HTIRC_HUMMINGBIRD_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_20A.INC)	; Select HTIRC Hummingbird 20A pinout
                               ENDIF
                      2274     
                      2275     IF BESCNO == HTIRC_HUMMINGBIRD_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_20A.INC)	; Select HTIRC Hummingbird 20A pinout
                               ENDIF
                      2279     
                      2280     IF BESCNO == HTIRC_HUMMINGBIRD_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HTIRC_HUMMINGBIRD_20A.INC)	; Select HTIRC Hummingbird 20A pinout
                               ENDIF
                      2284     
                      2285     IF BESCNO == HTIRC_HUMMINGBIRD_30A_PRO_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_30A_PRO.INC)	; Select HTIRC Hummingbird 30A Pro pinout
                               ENDIF
                      2289     
                      2290     IF BESCNO == HTIRC_HUMMINGBIRD_30A_PRO_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HTIRC_HUMMINGBIRD_30A_PRO.INC)	; Select HTIRC Hummingbird 30A Pro pinout
                               ENDIF
                      2294     
                      2295     IF BESCNO == HTIRC_HUMMINGBIRD_30A_PRO_MULTI
  0002                2296     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                      2297     $INCLUDE (HTIRC_HUMMINGBIRD_30A_PRO.INC)	; Select HTIRC Hummingbird 30A Pro pinout
                      2899     ENDIF
                      2900     
                      2901     
                      2902     
                      2903     ;**** **** **** **** ****
                      2904     ; TX programming defaults
                      2905     ;
                      2906     ; Parameter dependencies:
                      2907     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                      2908     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                      2909     ;
                      2910     ; MAIN
  0007                2911     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                2912     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                2913     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                2914     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                2915     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                2916     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2917     IF DAMPED_MODE_ENABLE == 1
  0002                2918     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
                      2919     ELSE
                               DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low	
                               ENDIF
  0001                2922     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2923     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                2924     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                2925     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                2926     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                2927     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                2928     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                2929     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                      2930     
                      2931     ; TAIL
  0003                2932     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                2933     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                2934     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2935     IF DAMPED_MODE_ENABLE == 1
  0003                2936     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low 		3=DampedLight 
                      2937     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		
                               ENDIF
  0001                2940     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2941     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2942     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                2943     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                2944     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                2945     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2946     DEFAULT_PGM_TAIL_PWM_DITHER		EQU 3 	; 1=Off		2=3			3=7			4=15			5=31
                      2947     
                      2948     ; MULTI
  0009                2949     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                2950     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                2951     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                2952     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0003                2953     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2954     IF DAMPED_MODE_ENABLE == 1
  0003                2955     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low 		3=DampedLight 
                      2956     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low
                               ENDIF
  0002                2959     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                2960     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2961     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0028                2962     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 40	; Beep strength
  0050                2963     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 80	; Beacon strength
  0004                2964     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2965     DEFAULT_PGM_MULTI_PWM_DITHER		EQU 3 	; 1=Off		2=3			3=7			4=15			5=31
                      2966     
                      2967     ; COMMON
  0001                2968     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 1 	; 1=Enabled 	0=Disabled
  0025                2969     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 37	; 4*37+1000=1148
  00D0                2970     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 208	; 4*208+1000=1832
  007A                2971     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 122	; 4*122+1000=1488 (used in bidirectional mode)
  0000                2972     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0=Low		1+= High or higher	
  0001                2973     DEFAULT_PGM_ENABLE_TEMP_PROT	 	EQU 1 	; 1=Enabled 	0=Disabled
  0001                2974     DEFAULT_PGM_ENABLE_POWER_PROT 	EQU 1 	; 1=Enabled 	0=Disabled
  0000                2975     DEFAULT_PGM_ENABLE_PWM_INPUT	 	EQU 0 	; 1=Enabled 	0=Disabled
  0000                2976     DEFAULT_PGM_BRAKE_ON_STOP	 	EQU 0 	; 1=Enabled 	0=Disabled
                      2977     
                      2978     ;**** **** **** **** ****
                      2979     ; Constant definitions for main
                      2980     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2999     ; Constant definitions for tail
                      3000     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      3019     ; Constant definitions for multi
                      3020     IF MODE == 2
                      3021     
  0001                3022     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
  000A                3023     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                3024     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                3025     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                3026     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                3027     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                3028     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                3029     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                3030     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                      3031     
  0032                3032     PWM_START			EQU	50 	; PWM used as max power during start
                      3033     
  0001                3034     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                      3035     
  0008                3036     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                      3037     
                      3038     ENDIF
                      3039     
                      3040     ;**** **** **** **** ****
                      3041     ; Temporary register definitions
  REG                 3042     TEMP1		EQU	R0
  REG                 3043     TEMP2		EQU	R1
  REG                 3044     TEMP3		EQU	R2
  REG                 3045     TEMP4		EQU	R3
  REG                 3046     TEMP5		EQU	R4
  REG                 3047     TEMP6		EQU	R5
  REG                 3048     TEMP7		EQU	R6
  REG                 3049     TEMP8		EQU	R7
                      3050     
                      3051     ;**** **** **** **** ****
                      3052     ; Register definitions
------                3053     DSEG AT 20H					; Variables segment 
                      3054     
0020                  3055     BIT_ACCESS: 				DS	1		; MUST BE AT THIS ADDRESS. Variable at bit accessible address (for non interrupt routines)
0021                  3056     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                      3057     
0022                  3058     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                  3059     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                  3060     CURRENT_PWM: 				DS	1		; Current pwm
0025                  3061     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited
0026                  3062     CURRENT_PWM_LIM_DITH: 		DS	1		; Current pwm that is limited and dithered (applied to the motor output)
0027                  3063     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0028                  3064     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0029                  3065     RCP_OUTSIDE_RANGE_CNT: 		DS	1		; RC pulse outside range counter (incrementing) 
002A                  3066     RCP_TIMEOUT_CNTD: 			DS	1		; RC pulse timeout counter (decrementing) 
002B                  3067     RCP_SKIP_CNTD: 				DS	1		; RC pulse skip counter (decrementing) 
                      3068     
002C                  3069     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                3070     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                3071     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                3072     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                3073     PWM_TIMER0_OVERFLOW			EQU	3		; Set for 48MHz MCUs when PWM timer 0 overflows
  0004                3074     DEMAG_DETECTED				EQU 	4		; Set when excessive demag time is detected
  0005                3075     DEMAG_CUT_POWER			EQU 	5		; Set when demag compensation cuts power
  0006                3076     HIGH_RPM					EQU 	6		; Set when motor rpm is high (Comm_Period4x_H less than 2)
                      3077     ;						EQU 	7	
                      3078     
002D                  3079     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                3080     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                3081     STARTUP_PHASE				EQU 	1		; Set when in startup phase
  0002                3082     INITIAL_RUN_PHASE			EQU	2		; Set when in initial run phase, before synchronized run is achieved
  0003                3083     MOTOR_STARTED				EQU 	3		; Set when motor is started
  0004                3084     DIR_CHANGE_BRAKE			EQU 	4		; Set when braking before direction change
  0005                3085     COMP_TIMED_OUT				EQU 	5		; Set when comparator reading timed out
  0006                3086     GOV_ACTIVE				EQU 	6		; Set when governor is active (enabled when speed is above minimum)
  0007                3087     SKIP_DAMP_ON				EQU 	7 		; Set when turning damping fet on is skipped
                      3088     
002E                  3089     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                3090     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                3091     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                3092     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode
  0003                3093     PGM_PWM_HIGH_FREQ			EQU	3		; Progremmed pwm high frequency
  0004                3094     RCP_PPM					EQU 	4		; RC pulse ppm type input (set also when oneshot is set)
  0005                3095     RCP_PPM_ONESHOT125			EQU 	5		; RC pulse ppm type input is OneShot125
  0006                3096     RCP_DIR_REV				EQU 	6		; RC pulse direction in bidirectional mode
                      3097     ;						EQU 	7	
                      3098     
002F                  3099     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                3100     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                3101     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                3102     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                3103     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                3104     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                3105     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                3106     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                3107     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                      3108     
                      3109     
                      3110     ;**** **** **** **** ****
                      3111     ; RAM definitions
------                3112     DSEG AT 30H						; Ram data segment, direct addressing
                      3113     
0030                  3114     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                      3115     
0031                  3116     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                  3117     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                      3118     
0033                  3119     STARTUP_CNT: 				DS	1		; Startup phase commutations counter (incrementing)
0034                  3120     STARTUP_ZC_TIMEOUT_CNTD: 		DS	1		; Startup zero cross timeout counter (decrementing)
0035                  3121     INITIAL_RUN_ROT_CNTD: 		DS	1		; Initial run rotations counter (decrementing)
0036                  3122     STALL_CNT: 				DS	1		; Counts start/run attempts that resulted in stall. Reset upon a proper stop
0037                  3123     DEMAG_DETECTED_METRIC: 		DS	1		; Metric used to gauge demag event frequency
0038                  3124     DEMAG_PWR_OFF_THRESH: 		DS	1		; Metric threshold above which power is cut
0039                  3125     LOW_RPM_PWR_SLOPE: 			DS	1		; Sets the slope of power increase for low rpms
                      3126     
003A                  3127     TIMER2_X: 					DS	1		; Timer 2 extended byte
003B                  3128     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003C                  3129     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003D                  3130     PREV_COMM_X: 				DS	1		; Previous commutation timer3 timestamp (ext byte)
003E                  3131     PREV_PREV_COMM_L: 			DS	1		; Pre-previous commutation timer3 timestamp (lo byte)
003F                  3132     PREV_PREV_COMM_H: 			DS	1		; Pre-previous commutation timer3 timestamp (hi byte)
0040                  3133     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
0041                  3134     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
0042                  3135     COMM_PHASE: 				DS	1		; Current commutation phase
0043                  3136     COMPARATOR_READ_CNT:  		DS	1		; Number of comparator reads done
                      3137     
0044                  3138     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0045                  3139     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0046                  3140     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0047                  3141     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0048                  3142     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0049                  3143     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
004A                  3144     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
004B                  3145     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
004C                  3146     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
                      3147     
004D                  3148     WT_ADV_START_L: 			DS	1		; Timer3 start point for commutation advance timing (lo byte)
004E                  3149     WT_ADV_START_H: 			DS	1		; Timer3 start point for commutation advance timing (hi byte)
004F                  3150     WT_ZC_SCAN_START_L: 			DS	1		; Timer3 start point from commutation to zero cross scan (lo byte)
0050                  3151     WT_ZC_SCAN_START_H: 			DS	1		; Timer3 start point from commutation to zero cross scan (hi byte)
0051                  3152     WT_ZC_TOUT_START_L: 			DS	1		; Timer3 start point for zero cross scan timeout (lo byte)
0052                  3153     WT_ZC_TOUT_START_H: 			DS	1		; Timer3 start point for zero cross scan timeout (hi byte)
0053                  3154     WT_COMM_START_L: 			DS	1		; Timer3 start point from zero cross to commutation (lo byte)
0054                  3155     WT_COMM_START_H: 			DS	1		; Timer3 start point from zero cross to commutation (hi byte)
                      3156     
0055                  3157     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0056                  3158     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0057                  3159     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0058                  3160     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0059                  3161     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
005A                  3162     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
005B                  3163     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
005C                  3164     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005D                  3165     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005E                  3166     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005F                  3167     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
0060                  3168     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                      3169     
0061                  3170     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
0062                  3171     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup
0063                  3172     PWM_LIMIT_BY_RPM: 			DS	1		; Maximum allowed pwm for low or high rpms
0064                  3173     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0065                  3174     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0066                  3175     PWM_DITHER_DECODED: 			DS	1		; Decoded pwm dither value
0067                  3176     PWM_DITHER_EXCESS_POWER: 		DS	1		; Excess power (above max) from pwm dither
0068                  3177     RANDOM: 					DS	1		; Random number from LFSR 
                      3178     
0069                  3179     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
006A                  3180     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
006B                  3181     MAIN_SPOOLUP_TIME_3X: 		DS	1		; Main spoolup time x3
006C                  3182     MAIN_SPOOLUP_TIME_10X: 		DS	1		; Main spoolup time x10
006D                  3183     MAIN_SPOOLUP_TIME_15X: 		DS	1		; Main spoolup time x15
                      3184     
006E                  3185     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006F                  3186     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
0070                  3187     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                      3188     
0071                  3189     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                      3190     
0072                  3191     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
0073                  3192     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                      3193     
0074                  3194     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0075                  3195     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0076                  3196     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                      3197     
0077                  3198     SKIP_T2_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 interrupt shall be ignored 
0078                  3199     SKIP_T2H_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 high interrupt shall be ignored 
0079                  3200     TIMER0_OVERFLOW_VALUE: 		DS	1		; Remaining timer 0 wait time used with 48MHz MCUs
007A                  3201     CLOCK_SET_AT_48MHZ: 			DS	1		; Variable set if 48MHz MCUs run at 48MHz
007B                  3202     DAMPINGFET: 				DS	1		; Port position of fet used for damping
                      3203     
007C                  3204     FLASH_KEY_1: 				DS	1		; Flash key one
007D                  3205     FLASH_KEY_2: 				DS	1		; Flash key two
                      3206     
                      3207     ; Indirect addressing data segment. The variables below must be in this sequence
------                3208     ISEG AT 080H					
0080                  3209     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  3210     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  3211     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  3212     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  3213     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  3214     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  3215     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  3216     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  3217     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  3218     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  3219     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  3220     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  3221     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  3222     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  3223     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  3224     _PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm (unused - place holder)
0090                  3225     _PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration (unused - place holder)
0091                  3226     _PGM_VOLT_COMP: 			DS	1		; Place holder
0092                  3227     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  3228     _PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force (unused - place holder)
0094                  3229     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  3230     _PGM_STARTUP_METHOD: 		DS	1		; Programmed startup method (unused - place holder)
0096                  3231     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  3232     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  3233     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  3234     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  3235     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  3236     _PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate (unused - place holder)
009C                  3237     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  3238     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  3239     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
009F                  3240     PGM_MAIN_SPOOLUP_TIME: 		DS	1		; Programmed main spoolup time
00A0                  3241     PGM_ENABLE_TEMP_PROT: 		DS	1		; Programmed temperature protection enable
00A1                  3242     PGM_ENABLE_POWER_PROT: 		DS	1		; Programmed low rpm power protection enable
00A2                  3243     PGM_ENABLE_PWM_INPUT: 		DS	1		; Programmed PWM input signal enable
00A3                  3244     PGM_PWM_DITHER: 			DS	1		; Programmed output PWM dither
00A4                  3245     PGM_BRAKE_ON_STOP: 			DS	1		; Programmed braking when throttle is zero
                      3246     
                      3247     ; The sequence of the variables below is no longer of importance
00A5                  3248     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A6                  3249     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A7                  3250     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
                      3251     
                      3252     
                      3253     ; Indirect addressing data segment
------                3254     ISEG AT 0D0H					
00D0                  3255     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      3256     
                      3257     
                      3258     ;**** **** **** **** ****
------                3259     CSEG AT 1A00H            ; "Eeprom" segment
  000E                3260     EEPROM_FW_MAIN_REVISION		EQU	14		; Main revision of the firmware
  004B                3261     EEPROM_FW_SUB_REVISION		EQU	75		; Sub revision of the firmware
  0015                3262     EEPROM_LAYOUT_REVISION		EQU	21		; Revision of the EEPROM layout
                      3263     
1A00    0E            3264     EEP_FW_MAIN_REVISION:  DB 14 
1A01    4B            3265     EEP_FW_SUB_REVISION:  DB 75 
1A02    15            3266     EEP_LAYOUT_REVISION:  DB 21 
                      3267     
                      3268     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH	
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH	
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH						
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH	
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH	
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							
                               EEP_PGM_MAIN_SPOOLUP_TIME:	DB	DEFAULT_PGM_MAIN_SPOOLUP_TIME		; EEPROM copy of programmed main spoolup time
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               _EEP_PGM_PWM_DITHER:		DB	0FFH	
                               EEP_PGM_BRAKE_ON_STOP:		DB	DEFAULT_PGM_BRAKE_ON_STOP		; EEPROM copy of programmed braking when throttle is zero
                               ENDIF 
                      3307     
                      3308     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               _EEP_PGM_MAIN_SPOOLUP_TIME:	DB	0FFH
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               EEP_PGM_PWM_DITHER:			DB	DEFAULT_PGM_TAIL_PWM_DITHER		; EEPROM copy of programmed output PWM dither
                               EEP_PGM_BRAKE_ON_STOP:		DB	DEFAULT_PGM_BRAKE_ON_STOP		; EEPROM copy of programmed braking when throttle is zero
                               ENDIF
                      3347     
                      3348     IF MODE == 2
1A03    09            3349     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            3350     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            3351     EEP_PGM_GOV_MODE:  DB 4 
1A06    FF            3352     _EEP_PGM_LOW_VOLTAGE_LIM: 	DB	0FFH							
1A07    03            3353     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            3354     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    0A            3355     EEP_PGM_STARTUP_PWR:  DB 10 
1A0A    03            3356     EEP_PGM_PWM_FREQ:  DB 3 
1A0B    01            3357     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            3358     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            3359     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            3360     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    01            3361     EEP_ENABLE_TX_PROGRAM:  DB 1 
1A10    FF            3362     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            3363     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    FF            3364     _EEP_PGM_STARTUP_RPM: 		DB	0FFH
1A13    FF            3365     _EEP_PGM_STARTUP_ACCEL: 		DB	0FFH
1A14    FF            3366     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            3367     EEP_PGM_COMM_TIMING:  DB 3 
1A16    FF            3368     _EEP_PGM_DAMPING_FORCE: 		DB	0FFH
1A17    FF            3369     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    FF            3370     _EEP_PGM_STARTUP_METHOD: 		DB	0FFH
1A19    25            3371     EEP_PGM_PPM_MIN_THROTTLE:  DB 37 
1A1A    D0            3372     EEP_PGM_PPM_MAX_THROTTLE:  DB 208 
1A1B    28            3373     EEP_PGM_BEEP_STRENGTH:  DB 40 
1A1C    50            3374     EEP_PGM_BEACON_STRENGTH:  DB 80 
1A1D    04            3375     EEP_PGM_BEACON_DELAY:  DB 4 
1A1E    FF            3376     _EEP_PGM_THROTTLE_RATE: 		DB	0FFH
1A1F    02            3377     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            3378     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7A            3379     EEP_PGM_PPM_CENTER_THROTTLE:  DB 122 
1A22    FF            3380     _EEP_PGM_MAIN_SPOOLUP_TIME: 	DB	0FFH
1A23    01            3381     EEP_PGM_TEMP_PROT_ENABLE:  DB 1 
1A24    01            3382     EEP_PGM_ENABLE_POWER_PROT:  DB 1 
1A25    00            3383     EEP_PGM_ENABLE_PWM_INPUT:  DB 0 
1A26    03            3384     EEP_PGM_PWM_DITHER:  DB 3 
1A27    00            3385     EEP_PGM_BRAKE_ON_STOP:  DB 0 
                      3386     ENDIF
                      3387     
1A28    FF            3388     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      3389     
------                3390     CSEG AT 1A60H
1A60    20202020      3391     EEP_NAME: 					DB	"                "				; Name tag (16 Bytes)
1A64    20202020
1A68    20202020
1A6C    20202020
                      3392     
                      3393     ;**** **** **** **** ****
                      3394     		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                3394+1   CSEG AT 0  ; CODE SEGMENT START
0000    0219FD        3394+1   JMP RESET 
------                3394+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200AA        3394+1   JMP T0_INT 
------                3394+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    020187        3394+1   JMP T2_INT 
------                3394+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    02033B        3394+1   JMP PCA_INT 
------                3394+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    020328        3394+1   JMP T3_INT 
------                3395     CSEG AT 80H			; Code segment after interrupt vectors 
                      3396     
                      3397     ;**** **** **** **** ****
                      3398     
                      3399     ; Table definitions
0080    02030406      3400     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    0406080C      3401     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
0091    10182030
0095    406080A0
0099    C0
009A    0003070F      3402     PWM_DITHER_TABLE:   		DB 	00H, 03H, 07H, 0FH, 1FH
009E    1F
                      3403     IF MODE == 0
                                 IF DAMPED_MODE_ENABLE == 1
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 3, 3, 2, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 2, 3, 2, 2
                                 ENDIF
                               ENDIF
                      3411     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 3, 5, 3, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF
                               ENDIF
                      3419     IF MODE == 2
                      3420       IF DAMPED_MODE_ENABLE == 1
009F    0D0D0405      3421     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 13, 5, 3, 5, 3, 3, 2
00A3    0D050305
00A7    030302
                      3422       ENDIF
                      3423       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF 
                      3426     ENDIF
                      3427     
                      3428     
                      3429     
                      3430     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3431     ;
                      3432     ; Timer0 interrupt routine
                      3433     ;
                      3434     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      3435     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      3436     ;
                      3437     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3438     T0_INT: 	; Used for pwm control
00AA    C2AF          3439     	CLR 	EA			; Disable all interrupts
                      3440     IF MCU_48MHZ == 1
                      3441     	; Check overflow flag
00AC    306308        3442     JNB FLAGS0 . 3 , T0_INT_START 
                      3443     
00AF    C263          3444     CLR FLAGS0 . 3 
00B1    85798A        3445     	MOV	TL0, TIMER0_OVERFLOW_VALUE	; Set timer 
00B4    D2AF          3446     	SETB	EA			; Enable all interrupts
00B6    32            3447     	RETI
                      3448     
                      3449     T0_INT_START: 
                      3450     ENDIF
00B7    C0D0          3451     	PUSH	PSW			; Preserve registers through interrupt
00B9    C0E0          3452     	PUSH	ACC		
                      3453     	; Check if pwm is on
00BB    206221        3454     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      3455     
                      3456     	; Pwm on cycle
00BE    E525          3457     	MOV	A, CURRENT_PWM_LIMITED
00C0    6016          3458     	JZ	T0_INT_PWM_ON_RET
                      3459     
00C2    E4            3460     	CLR	A					
00C3    73            3461     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      3462     
                      3463     T0_INT_PWM_ON_EXIT: 
                      3464     	; Set timer for coming on cycle length
00C4    E525          3465     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
00C6    F4            3466     	CPL	A						; cpl is 255-x
                      3467     IF MCU_48MHZ == 0
                               	MOV	TL0, A					; Write start point for timer
                               ELSE
00C7    C3            3470     	CLR	C
00C8    33            3471     	RLC	A
00C9    4009          3472     	JC	T0_INT_PWM_ON_SET_TIMER
                      3473     
00CB    758A00        3474     	MOV	TL0, #0
00CE    D263          3475     SETB FLAGS0 . 3 
00D0    F579          3476     	MOV	TIMER0_OVERFLOW_VALUE, A
00D2    01D6          3477     	AJMP	T0_INT_PWM_ON_TIMER_SET
                      3478     
                      3479     T0_INT_PWM_ON_SET_TIMER: 
00D4    F58A          3480     	MOV	TL0, A
                      3481     T0_INT_PWM_ON_TIMER_SET: 
                      3482     ENDIF
                      3483     	; Set other variables
00D6    D262          3484     SETB FLAGS0 . 2 
                      3485     T0_INT_PWM_ON_RET: 
                      3486     	; Exit interrupt
00D8    D0E0          3487     	POP	ACC			; Restore preserved registers
00DA    D0D0          3488     	POP	PSW
00DC    D2AF          3489     	SETB	EA			; Enable all interrupts
00DE    32            3490     	RETI
                      3491     
                      3492     
                      3493     	; Pwm off cycle
                      3494     T0_INT_PWM_OFF: 
                      3495     IF MCU_48MHZ == 0
                               	MOV	TL0, CURRENT_PWM_LIM_DITH	; Load new timer setting
                               ELSE
00DF    C3            3498     	CLR	C
00E0    E526          3499     	MOV	A, CURRENT_PWM_LIM_DITH
00E2    33            3500     	RLC	A
00E3    4009          3501     	JC	T0_INT_PWM_OFF_SET_TIMER 
                      3502     
00E5    758A00        3503     	MOV	TL0, #0
00E8    D263          3504     SETB FLAGS0 . 3 
00EA    F579          3505     	MOV	TIMER0_OVERFLOW_VALUE, A
00EC    01F0          3506     	AJMP	T0_INT_PWM_OFF_TIMER_SET
                      3507     
                      3508     T0_INT_PWM_OFF_SET_TIMER: 
00EE    F58A          3509     	MOV	TL0, A
                      3510     T0_INT_PWM_OFF_TIMER_SET: 
                      3511     ENDIF
                      3512     	; Clear pwm on flag
00F0    C262          3513     CLR FLAGS0 . 2 
                      3514     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00F2    E526          3515     	MOV	A, CURRENT_PWM_LIM_DITH		; Load current pwm
00F4    F4            3516     	CPL	A						; Full pwm?
00F5    602F          3517     	JZ	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      3518     
                      3519     IF DAMPED_MODE_ENABLE == 1
                      3520     	; Do not execute pwm off when stopped
00F7    306825        3521     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_EXIT 
                      3522     
                      3523     	; If damped operation, set pFETs on in pwm_off
00FA    20720D        3524     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      3525     ENDIF
                      3526     
                      3527     T0_INT_PWM_OFF_EXIT_NFETS_OFF: 	
                      3528     	; Separate exit commands here for minimum delay
                      3529     IF NFETON_DELAY == 0
                               	EN_OFF			; For EN/PWM style drivers. Uses accumulator
                               ENDIF
00FD    D0E0          3532     	POP	ACC			; Restore preserved registers
00FF    D0D0          3533     	POP	PSW
                      3534     IF NFETON_DELAY NE 0
                      3535     	ALL_NFETS_OFF 		; Switch off all nfets
0101    C295          3535+1   CLR P1 . 5 
0103    C293          3535+1   CLR P1 . 3 
0105    C297          3535+1   CLR P1 . 7 
                      3536     ENDIF
0107    D2AF          3537     	SETB	EA			; Enable all interrupts
0109    32            3538     	RETI
                      3539     
                      3540     T0_INT_PWM_OFF_DAMPED: 
                      3541     IF PFETON_DELAY < 128
                      3542     IF PFETON_DELAY NE 0
                      3543     	ALL_NFETS_OFF 				; Switch off all nfets
010A    C295          3543+1   CLR P1 . 5 
010C    C293          3543+1   CLR P1 . 3 
010E    C297          3543+1   CLR P1 . 7 
                      3544     ELSE
                               	EN_OFF
                               ENDIF
0110    206F0C        3547     JB FLAGS1 . 7 , T0_INT_PWM_OFF_DAMP_DONE 
0113    206509        3548     JB FLAGS0 . 5 , T0_INT_PWM_OFF_DAMP_DONE 
                      3549     IF PFETON_DELAY NE 0
0116    7418          3550     MOV A , # 24 
0118    D5E0FD        3551     	DJNZ	ACC, $	
                      3552     ENDIF
                      3553     	DAMPING_FET_ON
011B    E57B          3553+1   MOV A , DAMPINGFET 
011D    4290          3553+1   ORL P1 , A 
                      3554     T0_INT_PWM_OFF_DAMP_DONE: 
                      3555     ENDIF
                      3556     IF PFETON_DELAY >= 128			; "Negative", 1's complement
                               	JB	FLAGS1.SKIP_DAMP_ON, T0_INT_PWM_OFF_DAMP_DONE
                               	JB	FLAGS0.DEMAG_CUT_POWER, T0_INT_PWM_OFF_DAMP_DONE 
                               	DAMPING_FET_ON				; Damping fet on
                               	MOV	A, #PFETON_DELAY
                               	CPL	A
                               	DJNZ	ACC, $	
                               T0_INT_PWM_OFF_DAMP_DONE:
                               	ALL_NFETS_OFF 				; Switch off all nfets
                               ENDIF
                      3566     T0_INT_PWM_OFF_EXIT: 	
011F    D0E0          3567     	POP	ACC			; Restore preserved registers
0121    D0D0          3568     	POP	PSW
0123    D2AF          3569     	SETB	EA			; Enable all interrupts
0125    32            3570     	RETI
                      3571     
                      3572     T0_INT_PWM_OFF_FULLPOWER_EXIT:  
0126    758A00        3573     	MOV	TL0, #0		; Set long time till next interrupt
                      3574     IF MCU_48MHZ == 1
0129    D263          3575     SETB FLAGS0 . 3 
012B    757900        3576     	MOV	TIMER0_OVERFLOW_VALUE, #0
                      3577     ENDIF
012E    C28D          3578     	CLR	TF0			; Clear interrupt flag
0130    D262          3579     SETB FLAGS0 . 2 
0132    211F          3580     	AJMP	T0_INT_PWM_OFF_EXIT
                      3581     
                      3582     
                      3583     PWM_NOFET: 	; Dummy pwm on cycle
0134    01C4          3584     	AJMP	T0_INT_PWM_ON_EXIT
                      3585     
                      3586     PWM_AFET: 		; Pwm on cycle afet on
0136    306805        3587     JNB FLAGS1 . 0 , PWM_AFET_EXIT 
0139    206502        3588     JB FLAGS0 . 5 , PWM_AFET_EXIT 
                      3589     	ANFET_ON	
013C    D295          3589+1   SETB P1 . 5 
                      3590     PWM_AFET_EXIT: 
013E    01C4          3591     	AJMP	T0_INT_PWM_ON_EXIT
                      3592     
                      3593     PWM_BFET: 		; Pwm on cycle bfet on
0140    306805        3594     JNB FLAGS1 . 0 , PWM_BFET_EXIT 
0143    206502        3595     JB FLAGS0 . 5 , PWM_BFET_EXIT 
                      3596     	BNFET_ON
0146    D297          3596+1   SETB P1 . 7 
                      3597     PWM_BFET_EXIT: 
0148    01C4          3598     	AJMP	T0_INT_PWM_ON_EXIT
                      3599     
                      3600     PWM_CFET: 		; Pwm on cycle cfet on
014A    306805        3601     JNB FLAGS1 . 0 , PWM_CFET_EXIT 
014D    206502        3602     JB FLAGS0 . 5 , PWM_CFET_EXIT 
                      3603     	CNFET_ON
0150    D293          3603+1   SETB P1 . 3 
                      3604     PWM_CFET_EXIT: 
0152    01C4          3605     	AJMP	T0_INT_PWM_ON_EXIT
                      3606     
                      3607     PWM_AFET_DAMPED: 	
                      3608     IF NFETON_DELAY NE 0
                      3609     	APFET_OFF
0154    C294          3609+1   CLR P1 . 4 
                      3610     ENDIF
0156    30680A        3611     JNB FLAGS1 . 0 , PWM_AFET_DAMPED_EXIT 
0159    206507        3612     JB FLAGS0 . 5 , PWM_AFET_DAMPED_EXIT 
                      3613     IF NFETON_DELAY NE 0
015C    7418          3614     MOV A , # 24 
015E    D5E0FD        3615     	DJNZ ACC,	$
                      3616     ENDIF
                      3617     PWM_AFET_DAMPED_DONE: 
                      3618     	ANFET_ON								; Switch nFET
0161    D295          3618+1   SETB P1 . 5 
                      3619     PWM_AFET_DAMPED_EXIT: 
0163    01C4          3620     	AJMP	T0_INT_PWM_ON_EXIT
                      3621     
                      3622     PWM_BFET_DAMPED: 
                      3623     IF NFETON_DELAY NE 0
                      3624     	BPFET_OFF
0165    C296          3624+1   CLR P1 . 6 
                      3625     ENDIF
0167    30680A        3626     JNB FLAGS1 . 0 , PWM_BFET_DAMPED_EXIT 
016A    206507        3627     JB FLAGS0 . 5 , PWM_BFET_DAMPED_EXIT 
                      3628     IF NFETON_DELAY NE 0
016D    7418          3629     MOV A , # 24 
016F    D5E0FD        3630     	DJNZ ACC,	$
                      3631     ENDIF
                      3632     PWM_BFET_DAMPED_DONE: 
                      3633     	BNFET_ON								; Switch nFET
0172    D297          3633+1   SETB P1 . 7 
                      3634     PWM_BFET_DAMPED_EXIT: 
0174    01C4          3635     	AJMP	T0_INT_PWM_ON_EXIT
                      3636     
                      3637     PWM_CFET_DAMPED: 	
                      3638     IF NFETON_DELAY NE 0
                      3639     	CPFET_OFF
0176    C292          3639+1   CLR P1 . 2 
                      3640     ENDIF
0178    30680A        3641     JNB FLAGS1 . 0 , PWM_CFET_DAMPED_EXIT 
017B    206507        3642     JB FLAGS0 . 5 , PWM_CFET_DAMPED_EXIT 
                      3643     IF NFETON_DELAY NE 0
017E    7418          3644     MOV A , # 24 
0180    D5E0FD        3645     	DJNZ ACC,	$
                      3646     ENDIF
                      3647     PWM_CFET_DAMPED_DONE: 
                      3648     	CNFET_ON								; Switch nFET
0183    D293          3648+1   SETB P1 . 3 
                      3649     PWM_CFET_DAMPED_EXIT:  
0185    01C4          3650     	AJMP	T0_INT_PWM_ON_EXIT
                      3651     
                      3652     
                      3653     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3654     ;
                      3655     ; Timer2 interrupt routine
                      3656     ;
                      3657     ; No assumptions
                      3658     ;
                      3659     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3660     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
0187    C2AF          3661     	CLR	EA
0189    C2AD          3662     	CLR	ET2			; Disable timer2 interrupts
018B    53E6EF        3663     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
018E    C0D0          3664     	PUSH	PSW			; Preserve registers through interrupt
0190    C0E0          3665     	PUSH	ACC
0192    D2D3          3666     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0194    D2AF          3667     	SETB	EA
                      3668     IF MCU_48MHZ == 1
0196    E57A          3669     	MOV	A, CLOCK_SET_AT_48MHZ
0198    6009          3670     	JZ 	T2_INT_START
                      3671     
                      3672     	; Check skip variable
019A    E577          3673     	MOV	A, SKIP_T2_INT
019C    6005          3674     	JZ	T2_INT_START				; Execute this interrupt
                      3675     
019E    757700        3676     	MOV	SKIP_T2_INT, #0
01A1    41D5          3677     	AJMP	T2_INT_EXIT
                      3678     
                      3679     T2_INT_START: 
01A3    757701        3680     	MOV	SKIP_T2_INT, #1			; Skip next interrupt
                      3681     ENDIF
                      3682     	; Clear low byte interrupt flag
01A6    C2CE          3683     	CLR	TF2L						; Clear interrupt flag
                      3684     	; Check RC pulse timeout counter
01A8    E52A          3685     	MOV	A, RCP_TIMEOUT_CNTD			; RC pulse timeout count zero?
01AA    6007          3686     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      3687     
                      3688     	; Decrement timeout counter (if PWM)
01AC    207449        3689     JB FLAGS2 . 4 , T2_INT_SKIP_START 
                      3690     
01AF    152A          3691     	DEC	RCP_TIMEOUT_CNTD			; No - decrement
01B1    21F8          3692     	AJMP	T2_INT_SKIP_START
                      3693     
                      3694     T2_INT_PULSES_ABSENT: 
                      3695     	; Timeout counter has reached zero, pulses are absent
01B3    7800          3696     MOV R0 , # 0 
01B5    7900          3697     MOV R1 , # 0 
01B7    20742E        3698     JB FLAGS2 . 4 , T2_INT_PULSES_ABSENT_NO_MAX 
                      3699     
                      3700     	READ_RCP_INT 					; Look at value of Rcp_In
01BA    E580          3700+1   MOV A , P0 
01BC    307E01        3700+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
01BF    F4            3700+1   CPL A  ; YES - INVERT
01C0    30E502        3701     JNB ACC . 5 , ( $+5 ) 
01C3    78FF          3702     MOV R0 , # 255 
                      3703     	RCP_INT_FIRST 					; Set interrupt trig to first again
01C5    53DACF        3703+1   ANL PCA0CPM0 , # 0CFH 
01C8    207E03        3703+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
01CB    43DA20        3703+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
01CE    307E03        3703+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
01D1    43DA10        3703+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3704     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
01D4    C2D8          3704+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
01D6    C271          3705     CLR FLAGS2 . 1 
                      3706     	READ_RCP_INT 					; Look once more at value of Rcp_In
01D8    E580          3706+1   MOV A , P0 
01DA    307E01        3706+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
01DD    F4            3706+1   CPL A  ; YES - INVERT
01DE    30E502        3707     JNB ACC . 5 , ( $+5 ) 
01E1    79FF          3708     MOV R1 , # 255 
01E3    C3            3709     	CLR	C
01E4    E8            3710     MOV A , R0 
01E5    99            3711     SUBB A , R1 
01E6    70CB          3712     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      3713     
                      3714     T2_INT_PULSES_ABSENT_NO_MAX: 
01E8    306103        3715     JNB FLAGS0 . 1 , ( $+6 ) 
                      3716     
01EB    752A18        3717     MOV RCP_TIMEOUT_CNTD , # 24 
                      3718     
01EE    207403        3719     JB FLAGS2 . 4 , T2_INT_PPM_TIMEOUT_SET 
                      3720     
01F1    752A18        3721     MOV RCP_TIMEOUT_CNTD , # 24 
                      3722     
                      3723     T2_INT_PPM_TIMEOUT_SET: 
01F4    885C          3724     MOV NEW_RCP , R0 
01F6    D270          3725     SETB FLAGS2 . 0 
                      3726     
                      3727     T2_INT_SKIP_START: 
01F8    20740D        3728     JB FLAGS2 . 4 , T2_INT_RCP_UPDATE_START 
                      3729     
                      3730     	; Check RC pulse skip counter
01FB    E52B          3731     	MOV	A, RCP_SKIP_CNTD			
01FD    6004          3732     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      3733     	
                      3734     	; Decrement skip counter (only if edge counter is zero)
01FF    152B          3735     	DEC	RCP_SKIP_CNTD				; Decrement
0201    4108          3736     	AJMP	T2_INT_RCP_UPDATE_START
                      3737     
                      3738     T2_INT_SKIP_END: 
                      3739     	; Skip counter has reached zero, start looking for RC pulses again
                      3740     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0203    43DA01        3740+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      3741     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0206    C2D8          3741+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3742     	
                      3743     T2_INT_RCP_UPDATE_START: 
                      3744     	; Process updated RC pulse
0208    207002        3745     JB FLAGS2 . 0 , ( $+5 ) 
020B    4177          3746     	AJMP	T2_INT_CURRENT_PWM_UPDATE	; No - update pwm limits and exit
                      3747     
020D    A85C          3748     MOV R0 , NEW_RCP 
020F    206102        3749     JB FLAGS0 . 1 , ( $+5 ) 
                      3750     
0212    C270          3751     CLR FLAGS2 . 0 
                      3752     
                      3753     	; Use a gain of 1.0625x for pwm input if not governor mode
0214    207436        3754     JB FLAGS2 . 4 , T2_INT_PWM_MIN_RUN 
                      3755     
                      3756     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ELSE
                      3759     
                      3760     IF MODE == 2	; Multi 
0217    7982          3761     MOV R1 , # PGM_GOV_MODE 
0219    B70431        3762     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      3763     ENDIF
                      3764     
                      3765     	; Limit the maximum value to avoid wrap when scaled to pwm range
021C    C3            3766     	CLR	C
021D    E8            3767     MOV A , R0 
021E    94F0          3768     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0220    4003          3769     	JC	T2_INT_RCP_UPDATE_MULT
                      3770     
0222    74F0          3771     	MOV	A, #240			; Set requested pwm to max
0224    F8            3772     MOV R0 , A 
                      3773     
                      3774     T2_INT_RCP_UPDATE_MULT: 	
                      3775     	; Multiply by 1.0625 (optional adjustment gyro gain)
0225    E8            3776     MOV A , R0 
0226    C4            3777     	SWAP	A			; After this "0.0625"
0227    540F          3778     	ANL	A, #0FH
0229    28            3779     ADD A , R0 
022A    F8            3780     MOV R0 , A 
                      3781     	; Adjust tail gain
022B    7984          3782     MOV R1 , # PGM_MOTOR_GAIN 
022D    B70302        3783     CJNE @ R1 , # 3 , ( $+5 ) 
0230    414D          3784     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      3785     
0232    C3            3786     	CLR	C
0233    13            3787     	RRC	A			; After this "0.5"
0234    C3            3788     	CLR	C
0235    13            3789     	RRC	A			; After this "0.25"
0236    8721          3790     MOV BIT_ACCESS_INT , @ R1 
0238    200802        3791     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      3792     
023B    C3            3793     	CLR	C
023C    13            3794     	RRC	A			; After this "0.125"
                      3795     
                      3796     T2_INT_RCP_GAIN_CORR: 
023D    200A06        3797     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      3798     
0240    C3            3799     	CLR	C
0241    C8            3800     XCH A , R0 
0242    98            3801     SUBB A , R0 
0243    F8            3802     MOV R0 , A 
0244    414D          3803     	AJMP	T2_INT_PWM_MIN_RUN
                      3804     
                      3805     T2_INT_RCP_GAIN_POS: 
0246    28            3806     ADD A , R0 
0247    F8            3807     MOV R0 , A 
0248    5003          3808     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      3809     
024A    74FF          3810     	MOV	A, #0FFH					; Yes - limit
024C    F8            3811     MOV R0 , A 
                      3812     ENDIF
                      3813     
                      3814     T2_INT_PWM_MIN_RUN:  
                      3815     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      3825     
                      3826     T2_INT_PWM_UPDATE:  
                      3827     	; Update requested_pwm
024D    8822          3828     MOV REQUESTED_PWM , R0 
                      3829     IF MODE >= 1	; Tail or multi
                      3830     	; Boost pwm during direct start
024F    E52D          3831     	MOV	A, FLAGS1
0251    5406          3832     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0253    6022          3833     	JZ	T2_INT_CURRENT_PWM_UPDATE
                      3834     
0255    206B1F        3835     JB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      3836     
0258    E536          3837     	MOV	A, STALL_CNT				; Add an extra power boost for each attempt
025A    C3            3838     	CLR	C
025B    33            3839     	RLC	A
025C    C3            3840     	CLR	C
025D    33            3841     	RLC	A
025E    F8            3842     MOV R0 , A 
025F    E564          3843     	MOV	A, PWM_SPOOLUP_BEG			; Set 25% of max startup power as minimum power
0261    C3            3844     	CLR	C
0262    13            3845     	RRC	A
0263    C3            3846     	CLR	C
0264    13            3847     	RRC	A
0265    F9            3848     MOV R1 , A 
0266    C3            3849     	CLR	C
0267    9522          3850     	SUBB	A, REQUESTED_PWM
0269    4002          3851     	JC	($+4)
                      3852     
026B    8922          3853     MOV REQUESTED_PWM , R1 
                      3854     
026D    E8            3855     MOV A , R0 
026E    2522          3856     	ADD	A, REQUESTED_PWM			
0270    F522          3857     	MOV	REQUESTED_PWM, A
0272    5003          3858     	JNC	($+5)
                      3859     
0274    7522FF        3860     	MOV	REQUESTED_PWM, #0FFH
                      3861     
                      3862     ENDIF
                      3863     T2_INT_CURRENT_PWM_UPDATE:  
                      3864     IF MODE == 0 OR MODE == 2	; Main or multi
0277    7882          3865     MOV R0 , # PGM_GOV_MODE 
0279    B60459        3866     CJNE @ R0 , # 4 , T2_INT_EXIT 
                      3867     ENDIF
                      3868     
027C    852224        3869     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      3870     IF MODE >= 1	; Tail or multi
                      3871     	; Set current_pwm_limited
027F    A824          3872     MOV R0 , CURRENT_PWM 
0281    C3            3873     	CLR	C
0282    E524          3874     	MOV	A, CURRENT_PWM				; Check against limit
0284    9561          3875     	SUBB	A, PWM_LIMIT
0286    4002          3876     	JC	($+4)					; If current pwm below limit - branch
                      3877     
0288    A861          3878     MOV R0 , PWM_LIMIT 
                      3879     
                      3880     IF MODE == 2	; Multi
                      3881     	; Limit pwm for low rpms
028A    C3            3882     	CLR	C
028B    E8            3883     MOV A , R0 
028C    9563          3884     	SUBB	A, PWM_LIMIT_BY_RPM
028E    4002          3885     	JC	($+4)					; If current pwm below limit - branch
                      3886     
0290    A863          3887     MOV R0 , PWM_LIMIT_BY_RPM 
                      3888     
                      3889     ENDIF
0292    8825          3890     MOV CURRENT_PWM_LIMITED , R0 
                      3891     	; Dither
0294    E566          3892     	MOV	A, PWM_DITHER_DECODED		; Load pwm dither
0296    7002          3893     	JNZ	($+4)					; If active - branch
0298    41C8          3894     	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                      3895     
029A    C3            3896     	CLR	C
029B    E8            3897     MOV A , R0 
029C    AA66          3898     MOV R2 , PWM_DITHER_DECODED 
029E    9A            3899     SUBB A , R2 
029F    5003          3900     	JNC	T2_INT_CURRENT_PWM_FULL_DITHER; If pwm more than dither value, then do full dither
                      3901     
02A1    E8            3902     MOV A , R0 
02A2    FA            3903     MOV R2 , A 
02A3    E4            3904     	CLR	A						; Set pwm minus dither
                      3905     
                      3906     T2_INT_CURRENT_PWM_FULL_DITHER: 
02A4    F9            3907     MOV R1 , A 
02A5    EA            3908     MOV A , R2 
02A6    C3            3909     	CLR	C
02A7    33            3910     	RLC	A						; Shift left once
02A8    FB            3911     MOV R3 , A 
02A9    E568          3912     	MOV	A, RANDOM					; Load random number
02AB    F4            3913     	CPL	A						; Invert to create proper DC bias in random code
02AC    5B            3914     ANL A , R3 
02AD    29            3915     ADD A , R1 
02AE    400D          3916     	JC	T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER	; If dither cause power above max - branch and increase excess 
                      3917     
02B0    2567          3918     	ADD	A, PWM_DITHER_EXCESS_POWER	; Add excess power from previous cycles
02B2    F8            3919     MOV R0 , A 
02B3    E567          3920     	MOV	A, PWM_DITHER_EXCESS_POWER	; Decrement excess power
02B5    6002          3921     	JZ	($+4)
02B7    1567          3922     	DEC	PWM_DITHER_EXCESS_POWER
02B9    400B          3923     	JC	T2_INT_CURRENT_PWM_DITHER_MAX_POWER; If dither cause power above max - branch
                      3924     
02BB    41C8          3925     	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                      3926     
                      3927     T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER: 
02BD    0A            3928     INC R2 
02BE    C3            3929     	CLR	C
02BF    E567          3930     	MOV	A, PWM_DITHER_EXCESS_POWER
02C1    9A            3931     SUBB A , R2 
02C2    5002          3932     	JNC	($+4)
02C4    0567          3933     	INC	PWM_DITHER_EXCESS_POWER
                      3934     
                      3935     T2_INT_CURRENT_PWM_DITHER_MAX_POWER: 
02C6    78FF          3936     MOV R0 , # 255 
                      3937     
                      3938     T2_INT_CURRENT_PWM_NO_DITHER: 
02C8    8826          3939     MOV CURRENT_PWM_LIM_DITH , R0 
                      3940     IF DAMPED_MODE_ENABLE == 1
                      3941     	; Skip damping fet switching for high throttle
02CA    C26F          3942     CLR FLAGS1 . 7 
02CC    C3            3943     	CLR	C
02CD    E526          3944     	MOV	A, CURRENT_PWM_LIM_DITH
02CF    94F8          3945     	SUBB	A, #248
02D1    4002          3946     	JC	T2_INT_EXIT
02D3    D26F          3947     SETB FLAGS1 . 7 
                      3948     ENDIF
                      3949     ENDIF
                      3950     T2_INT_EXIT: 	
                      3951     	; Check if high byte flag is set
02D5    20CF0A        3952     	JB	TF2H, T2H_INT		
02D8    D0E0          3953     	POP	ACC			; Restore preserved registers
02DA    D0D0          3954     	POP	PSW
02DC    43E610        3955     	ORL	EIE1, #10H	; Enable PCA0 interrupts
02DF    D2AD          3956     	SETB	ET2			; Enable timer2 interrupts
02E1    32            3957     	RETI
                      3958     
                      3959     T2H_INT: 
                      3960     	; High byte interrupt (happens every 32ms)
02E2    C2CF          3961     	CLR	TF2H					; Clear interrupt flag
02E4    053A          3962     	INC	TIMER2_X
                      3963     IF MCU_48MHZ == 1
02E6    E57A          3964     	MOV	A, CLOCK_SET_AT_48MHZ
02E8    6009          3965     	JZ 	T2H_INT_START
                      3966     
                      3967     	; Check skip variable
02EA    E578          3968     	MOV	A, SKIP_T2H_INT
02EC    6005          3969     	JZ	T2H_INT_START				; Execute this interrupt
                      3970     
02EE    757800        3971     	MOV	SKIP_T2H_INT, #0
02F1    611E          3972     	AJMP	T2H_INT_EXIT
                      3973     
                      3974     T2H_INT_START: 
02F3    757801        3975     	MOV	SKIP_T2H_INT, #1			; Skip next interrupt
                      3976     ENDIF
02F6    7801          3977     MOV R0 , # 1 
                      3978     	; Check RC pulse timeout counter (used here for PPM only)
02F8    E52A          3979     	MOV	A, RCP_TIMEOUT_CNTD			; RC pulse timeout count zero?
02FA    6005          3980     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      3981     
                      3982     	; Decrement timeout counter (if PPM)
02FC    307402        3983     JNB FLAGS2 . 4 , T2H_INT_RCP_STOP_CHECK 
                      3984     
02FF    152A          3985     	DEC	RCP_TIMEOUT_CNTD			; No flag set (PPM) - decrement
                      3986     
                      3987     T2H_INT_RCP_STOP_CHECK: 
                      3988     	; Check RC pulse against stop value
0301    C3            3989     	CLR	C
0302    E55C          3990     	MOV	A, NEW_RCP				; Load new pulse value
0304    9401          3991     SUBB A , # 1 
0306    4005          3992     	JC	T2H_INT_RCP_STOP
                      3993     
                      3994     	; RC pulse higher than stop value, reset stop counter
0308    755F00        3995     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
030B    611E          3996     	AJMP	T2H_INT_RCP_GOV_PWM
                      3997     
                      3998     T2H_INT_RCP_STOP: 	
                      3999     	; RC pulse less than stop value
030D    756000        4000     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
0310    756900        4001     	MOV	SPOOLUP_LIMIT_CNT, #0
0313    E55F          4002     	MOV	A, RCP_STOP_CNT			; Increment stop counter
0315    2401          4003     	ADD	A, #1
0317    F55F          4004     	MOV	RCP_STOP_CNT, A
0319    5003          4005     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      4006     
031B    755FFF        4007     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      4008     
                      4009     T2H_INT_RCP_GOV_PWM: 
                      4010     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	JNB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_GOV_BY_TX; If governor not active - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	JNB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_GOV_BY_TX; If governor not active - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #8						; Default fast increase for spoolup time of zero
                               	MOV	A, MAIN_SPOOLUP_TIME_3X
                               	JZ	T2H_INT_RCP_INC_LIMIT			; Jump for spoolup time of zero
                               
                               	MOV	TEMP1, #5						; Default fast increase
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_3X			; No spoolup until 3*N*32ms
                               
                               	JC	T2H_INT_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_10X			; Slow spoolup until "100"*N*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_15X			; Faster spoolup until "150"*N*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	JB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_INC_LIMIT	; If governor active - branch 
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, MAIN_SPOOLUP_TIME_3X	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_EXIT					; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      4140     T2H_INT_EXIT: 
031E    D0E0          4141     	POP	ACC			; Restore preserved registers
0320    D0D0          4142     	POP	PSW
0322    43E610        4143     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0325    D2AD          4144     	SETB	ET2			; Enable timer2 interrupts
0327    32            4145     	RETI
                      4146     
                      4147     
                      4148     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4149     ;
                      4150     ; Timer3 interrupt routine
                      4151     ;
                      4152     ; No assumptions
                      4153     ;
                      4154     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4155     T3_INT: 	; Used for commutation timing
0328    C2AF          4156     	CLR 	EA				; Disable all interrupts
032A    53E67F        4157     	ANL	EIE1, #7FH		; Disable timer3 interrupts
032D    7592FA        4158     	MOV	TMR3RLL, #0FAH		; Set a short delay before next interrupt
0330    7593FF        4159     	MOV	TMR3RLH, #0FFH
0333    C260          4160     CLR FLAGS0 . 0 
0335    759104        4161     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
0338    D2AF          4162     	SETB	EA				; Enable all interrupts
033A    32            4163     	RETI
                      4164     
                      4165     
                      4166     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4167     ;
                      4168     ; PCA interrupt routine
                      4169     ;
                      4170     ; No assumptions
                      4171     ;
                      4172     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4173     PCA_INT: 	; Used for RC pulse timing
033B    C2AF          4174     	CLR	EA
033D    53E6EF        4175     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
0340    C2AD          4176     	CLR	ET2			; Disable timer2 interrupts
0342    C0D0          4177     	PUSH	PSW			; Preserve registers through interrupt
0344    C0E0          4178     	PUSH	ACC
0346    C0F0          4179     	PUSH	B
0348    D2D3          4180     	SETB	PSW.3		; Select register bank 1 for interrupt routines
034A    D2AF          4181     	SETB	EA
                      4182     	; Get the PCA counter values
                      4183     	GET_RCP_CAPTURE_VALUES
034C    A8FB          4183+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
034E    A9FC          4183+1   MOV R1 , PCA0CPH0 
                      4183+1   IF 1 ==1 
0350    E57A          4183+1   MOV A , CLOCK_SET_AT_48MHZ 
0352    6007          4183+1   JZ GET_RCP_END 
0354    C3            4183+1   CLR C 
0355    E9            4183+1   MOV A , R1 
0356    13            4183+1   RRC A 
0357    F9            4183+1   MOV R1 , A 
0358    E8            4183+1   MOV A , R0 
0359    13            4183+1   RRC A 
035A    F8            4183+1   MOV R0 , A 
                      4183+1   GET_RCP_END:  
                      4184     	; Clear interrupt flag
                      4185     	RCP_CLEAR_INT_FLAG 				
035B    C2D8          4185+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      4186     	; Check which edge it is
035D    307102        4187     JNB FLAGS2 . 1 , ( $+5 ) 
0360    61AD          4188     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      4189     
                      4190     	RCP_INT_SECOND					; Yes - set second edge trig
0362    53DACF        4190+1   ANL PCA0CPM0 , # 0CFH 
0365    207E03        4190+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0368    43DA10        4190+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
036B    307E03        4190+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
036E    43DA20        4190+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0371    D271          4191     SETB FLAGS2 . 1 
                      4192     	; Read RC signal level
                      4193     	READ_RCP_INT			
0373    E580          4193+1   MOV A , P0 
0375    307E01        4193+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0378    F4            4193+1   CPL A  ; YES - INVERT
                      4194     	; Test RC signal level
0379    20E502        4195     JB ACC . 5 , ( $+5 ) 
037C    6184          4196     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      4197     
                      4198     	; RC pulse was high, store RC pulse start timestamp
037E    8827          4199     MOV RCP_PREV_EDGE_L , R0 
0380    8928          4200     MOV RCP_PREV_EDGE_H , R1 
0382    A1D2          4201     	AJMP	PCA_INT_EXIT				; Exit
                      4202     
                      4203     PCA_INT_FAIL_MINIMUM: 
                      4204     	; Prepare for next interrupt
                      4205     	RCP_INT_FIRST					; Set interrupt trig to first again
0384    53DACF        4205+1   ANL PCA0CPM0 , # 0CFH 
0387    207E03        4205+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
038A    43DA20        4205+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
038D    307E03        4205+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0390    43DA10        4205+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      4206     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0393    C2D8          4206+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0395    C271          4207     CLR FLAGS2 . 1 
0397    307402        4208     JNB FLAGS2 . 4 , ( $+5 ) 
                      4209     
039A    A1BE          4210     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      4211     
039C    7800          4212     MOV R0 , # 0 
                      4213     	READ_RCP_INT 					; Test RC signal level again
039E    E580          4213+1   MOV A , P0 
03A0    307E01        4213+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
03A3    F4            4213+1   CPL A  ; YES - INVERT
03A4    30E502        4214     JNB ACC . 5 , ( $+5 ) 
                      4215     
03A7    A1BE          4216     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      4217     
03A9    885C          4218     MOV NEW_RCP , R0 
03AB    A1A6          4219     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      4220     
                      4221     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      4222     	; Prepare for next interrupt
                      4223     	RCP_INT_FIRST 					; Set first edge trig
03AD    53DACF        4223+1   ANL PCA0CPM0 , # 0CFH 
03B0    207E03        4223+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03B3    43DA20        4223+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
03B6    307E03        4223+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03B9    43DA10        4223+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
03BC    C271          4224     CLR FLAGS2 . 1 
                      4225     	; Check if pwm frequency shall be measured
03BE    206102        4226     JB FLAGS0 . 1 , ( $+5 ) 
03C1    8186          4227     	AJMP	PCA_INT_FALL				; No - skip measurements
                      4228     
                      4229     	; Set second edge trig only during pwm frequency measurement
                      4230     	RCP_INT_SECOND 				; Set second edge trig
03C3    53DACF        4230+1   ANL PCA0CPM0 , # 0CFH 
03C6    207E03        4230+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03C9    43DA10        4230+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
03CC    307E03        4230+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03CF    43DA20        4230+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      4231     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
03D2    C2D8          4231+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
03D4    D271          4232     SETB FLAGS2 . 1 
                      4233     	; Store edge data to RAM
03D6    8857          4234     MOV RCP_EDGE_L , R0 
03D8    8958          4235     MOV RCP_EDGE_H , R1 
                      4236     	; Calculate pwm frequency
03DA    C3            4237     	CLR	C
03DB    E8            4238     MOV A , R0 
03DC    9555          4239     	SUBB	A, RCP_PREPREV_EDGE_L	
03DE    F8            4240     MOV R0 , A 
03DF    E9            4241     MOV A , R1 
03E0    9556          4242     	SUBB	A, RCP_PREPREV_EDGE_H
03E2    F9            4243     MOV R1 , A 
03E3    7B00          4244     MOV R3 , # 0 
03E5    7E08          4245     MOV R6 , # 8 
03E7    7A00          4246     MOV R2 , # 0 
                      4247     	; Check if pulse is too short
03E9    C3            4248     	CLR	C
03EA    E8            4249     MOV A , R0 
03EB    948C          4250     	SUBB	A, #LOW(140)				; If pulse below 70us, not accepted
03ED    E9            4251     MOV A , R1 
03EE    9400          4252     	SUBB	A, #HIGH(140)
03F0    5005          4253     	JNC	PCA_INT_CHECK_12KHZ
                      4254     
03F2    755B00        4255     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0	; Set not accepted 
03F5    8178          4256     	AJMP	PCA_INT_STORE_DATA
                      4257     
                      4258     PCA_INT_CHECK_12KHZ: 
03F7    8821          4259     MOV BIT_ACCESS_INT , R0 
03F9    78A2          4260     MOV R0 , # PGM_ENABLE_PWM_INPUT 
03FB    E6            4261     MOV A , @ R0 
03FC    A821          4262     MOV R0 , BIT_ACCESS_INT 
03FE    6055          4263     	JZ	PCA_INT_RESTORE_EDGE		; If it is not - branch
                      4264     
                      4265     	; Check if pwm frequency is 12kHz
0400    C3            4266     	CLR	C
0401    E8            4267     MOV A , R0 
0402    94C8          4268     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
0404    E9            4269     MOV A , R1 
0405    9400          4270     	SUBB	A, #HIGH(200)
0407    5008          4271     	JNC	PCA_INT_CHECK_8KHZ
                      4272     
0409    E4            4273     	CLR	A
040A    D2E4          4274     SETB ACC . 4 
040C    FB            4275     MOV R3 , A 
040D    7A0A          4276     MOV R2 , # 10 
040F    8153          4277     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      4278     
                      4279     PCA_INT_CHECK_8KHZ: 
                      4280     	; Check if pwm frequency is 8kHz
0411    C3            4281     	CLR	C
0412    E8            4282     MOV A , R0 
0413    9468          4283     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0415    E9            4284     MOV A , R1 
0416    9401          4285     	SUBB	A, #HIGH(360)
0418    5008          4286     	JNC	PCA_INT_CHECK_4KHZ
                      4287     
041A    E4            4288     	CLR	A
041B    D2E3          4289     SETB ACC . 3 
041D    FB            4290     MOV R3 , A 
041E    7A0F          4291     MOV R2 , # 15 
0420    8153          4292     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      4293     
                      4294     PCA_INT_CHECK_4KHZ: 
                      4295     	; Check if pwm frequency is 4kHz
0422    C3            4296     	CLR	C
0423    E8            4297     MOV A , R0 
0424    94D0          4298     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0426    E9            4299     MOV A , R1 
0427    9402          4300     	SUBB	A, #HIGH(720)
0429    5008          4301     	JNC	PCA_INT_CHECK_2KHZ
                      4302     
042B    E4            4303     	CLR	A
042C    D2E2          4304     SETB ACC . 2 
042E    FB            4305     MOV R3 , A 
042F    7A1E          4306     MOV R2 , # 30 
0431    8153          4307     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      4308     
                      4309     PCA_INT_CHECK_2KHZ: 
                      4310     	; Check if pwm frequency is 2kHz
0433    C3            4311     	CLR	C
0434    E8            4312     MOV A , R0 
0435    94A0          4313     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0437    E9            4314     MOV A , R1 
0438    9405          4315     	SUBB	A, #HIGH(1440)
043A    5008          4316     	JNC	PCA_INT_CHECK_1KHZ
                      4317     
043C    E4            4318     	CLR	A
043D    D2E1          4319     SETB ACC . 1 
043F    FB            4320     MOV R3 , A 
0440    7A3C          4321     MOV R2 , # 60 
0442    8153          4322     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      4323     
                      4324     PCA_INT_CHECK_1KHZ: 
                      4325     	; Check if pwm frequency is 1kHz
0444    C3            4326     	CLR	C
0445    E8            4327     MOV A , R0 
0446    9498          4328     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0448    E9            4329     MOV A , R1 
0449    9408          4330     	SUBB	A, #HIGH(2200)
044B    5008          4331     	JNC	PCA_INT_RESTORE_EDGE
                      4332     
044D    E4            4333     	CLR	A
044E    D2E0          4334     SETB ACC . 0 
0450    FB            4335     MOV R3 , A 
0451    7A78          4336     MOV R2 , # 120 
                      4337     
                      4338     PCA_INT_RESTORE_EDGE_SET_MSB: 
0453    7E00          4339     MOV R6 , # 0 
                      4340     PCA_INT_RESTORE_EDGE: 
                      4341     	; Calculate difference between this period and previous period
0455    C3            4342     	CLR	C
0456    E8            4343     MOV A , R0 
0457    9559          4344     	SUBB	A, RCP_PREV_PERIOD_L
0459    FC            4345     MOV R4 , A 
045A    E9            4346     MOV A , R1 
045B    955A          4347     	SUBB	A, RCP_PREV_PERIOD_H
045D    FD            4348     MOV R5 , A 
                      4349     	; Make positive
045E    30E70A        4350     	JNB	ACC.7, PCA_INT_CHECK_DIFF
0461    EC            4351     MOV A , R4 
0462    F4            4352     	CPL	A
0463    2401          4353     	ADD	A, #1
0465    FC            4354     MOV R4 , A 
0466    ED            4355     MOV A , R5 
0467    F4            4356     	CPL	A
0468    3400          4357     	ADDC	A, #0
046A    FD            4358     MOV R5 , A 
                      4359     
                      4360     PCA_INT_CHECK_DIFF: 
                      4361     	; Check difference
046B    755B00        4362     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
046E    C3            4363     	CLR	C
046F    EC            4364     MOV A , R4 
0470    9A            4365     SUBB A , R2 
0471    ED            4366     MOV A , R5 
0472    9E            4367     SUBB A , R6 
0473    5003          4368     	JNC	PCA_INT_STORE_DATA
                      4369     
0475    755B01        4370     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      4371     
                      4372     PCA_INT_STORE_DATA: 
                      4373     	; Store previous period
0478    8859          4374     MOV RCP_PREV_PERIOD_L , R0 
047A    895A          4375     MOV RCP_PREV_PERIOD_H , R1 
                      4376     	; Store pre previous edge
047C    855755        4377     	MOV	RCP_PREPREV_EDGE_L, RCP_EDGE_L
047F    855856        4378     	MOV	RCP_PREPREV_EDGE_H, RCP_EDGE_H
0482    7802          4379     MOV R0 , # 2 
0484    A1A6          4380     	AJMP	PCA_INT_LIMITED
                      4381     
                      4382     PCA_INT_FALL: 
                      4383     	; RC pulse edge was second, calculate new pulse length
0486    C3            4384     	CLR	C
0487    E8            4385     MOV A , R0 
0488    9527          4386     	SUBB	A, RCP_PREV_EDGE_L	
048A    F8            4387     MOV R0 , A 
048B    E9            4388     MOV A , R1 
048C    9528          4389     	SUBB	A, RCP_PREV_EDGE_H
048E    F9            4390     MOV R1 , A 
                      4391     	
                      4392     	; Rescale our Multishot signal to a Oneshot125 Signal range		
                      4393     	
048F    C3            4394     	CLR	C			; clear carry flag		
0490    E9            4395     MOV A , R1 
0491    13            4396     	RRC	A			; rotate right through the carry flag		
0492    F9            4397     MOV R1 , A 
0493    E8            4398     MOV A , R0 
0494    13            4399     	RRC	A			; rotate right through the carry flag		
0495    F8            4400     MOV R0 , A 
                      4401     					;60-300; 61-306		
0496    C3            4402     	CLR	C					; clear carry flag		
0497    E8            4403     MOV A , R0 
0498    24B4          4404       ADD A,	#180     		;Add the second low-byte to the accumulator		
049A    FC            4405     MOV R4 , A 
049B    E9            4406     MOV A , R1 
049C    3400          4407       ADDC A,	#0     			;Add the second high-byte to the accumulator, plus carry.		
049E    FD            4408     MOV R5 , A 
                      4409     											;240 - 480		
049F    81C0          4410     	AJMP	PCA_INT_FALL_CHECK_RANGE;   consider this a valid MS signal - move to I_Temp5/6 		
                      4411     					
                      4412     	; End Multishot to Oneshot Signal Scaling		
                      4413     
                      4414     
                      4415     PCA_INT_FALL_NOT_ONESHOT: 
04A1    E9            4416     MOV A , R1 
04A2    C3            4417     	CLR	C
04A3    13            4418     	RRC	A
04A4    F9            4419     MOV R1 , A 
04A5    E8            4420     MOV A , R0 
04A6    13            4421     	RRC	A
04A7    F8            4422     MOV R0 , A 
                      4423     
04A8    307902        4424     JNB FLAGS3 . 1 , ( $+5 ) 
04AB    A183          4425     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      4426     
04AD    E9            4427     MOV A , R1 
04AE    C3            4428     	CLR	C
04AF    13            4429     	RRC	A
04B0    F9            4430     MOV R1 , A 
04B1    E8            4431     MOV A , R0 
04B2    13            4432     	RRC	A
04B3    F8            4433     MOV R0 , A 
                      4434     
04B4    307802        4435     JNB FLAGS3 . 0 , ( $+5 ) 
04B7    A183          4436     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      4437     
04B9    E9            4438     MOV A , R1 
04BA    C3            4439     	CLR	C
04BB    13            4440     	RRC	A
04BC    FD            4441     MOV R5 , A 
04BD    E8            4442     MOV A , R0 
04BE    13            4443     	RRC	A
04BF    FC            4444     MOV R4 , A 
                      4445     PCA_INT_FALL_CHECK_RANGE: 
                      4446     	; Skip range limitation if pwm frequency measurement
04C0    20612C        4447     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      4448     
                      4449     	; Check if 2160us or above (in order to ignore false pulses)
04C3    C3            4450     	CLR	C
04C4    EC            4451     MOV A , R4 
04C5    9482          4452     	SUBB	A, #130						; Multishot Re-scale
04C7    ED            4453     MOV A , R5 
04C8    9402          4454     	SUBB A, #2
04CA    4002          4455     	JC	($+4)						; No - proceed
                      4456     
04CC    81D7          4457     	AJMP	PCA_INT_PPM_OUTSIDE_RANGE		; Yes - ignore pulse
                      4458     
                      4459     PCA_INT_PPM_BELOW_FULL_RANGE: 
                      4460     	; Check if below 800us (in order to ignore false pulses)
04CE    ED            4461     MOV A , R5 
04CF    701E          4462     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      4463     
04D1    C3            4464     	CLR	C
04D2    EC            4465     MOV A , R4 
04D3    94C8          4466     	SUBB	A, #200
04D5    5018          4467     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      4468     
                      4469     PCA_INT_PPM_OUTSIDE_RANGE: 
04D7    0529          4470     	INC	RCP_OUTSIDE_RANGE_CNT
04D9    E529          4471     	MOV	A, RCP_OUTSIDE_RANGE_CNT
04DB    7002          4472     	JNZ	($+4)
                      4473     
04DD    1529          4474     	DEC	RCP_OUTSIDE_RANGE_CNT
                      4475     
04DF    C3            4476     	CLR	C
04E0    E529          4477     	MOV	A, RCP_OUTSIDE_RANGE_CNT
04E2    940A          4478     	SUBB	A, #10						; Allow a given number of outside pulses
04E4    5002          4479     	JNC	($+4)			
04E6    A1BE          4480     	AJMP	PCA_INT_SET_TIMEOUT				; If below limit - ignore pulse
                      4481     
04E8    755C00        4482     	MOV	NEW_RCP, #0					; Set pulse length to zero
04EB    D270          4483     SETB FLAGS2 . 0 
04ED    A1BE          4484     	AJMP	PCA_INT_SET_TIMEOUT			
                      4485     
                      4486     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      4487     	; Decrement outside range counter
04EF    E529          4488     	MOV	A, RCP_OUTSIDE_RANGE_CNT
04F1    6002          4489     	JZ	($+4)
                      4490     
04F3    1529          4491     	DEC	RCP_OUTSIDE_RANGE_CNT
                      4492     
                      4493     	; Calculate "1000us" plus throttle minimum
                      4494     IF MODE >= 1	; Tail or multi
04F5    7888          4495     MOV R0 , # PGM_DIRECTION 
04F7    E6            4496     MOV A , @ R0 
04F8    F9            4497     MOV R1 , A 
                      4498     ENDIF
04F9    7400          4499     	MOV	A, #0						; Set 1000us as default minimum
04FB    207F08        4500     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      4501     
04FE    7896          4502     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      4503     IF MODE >= 1	; Tail or multi
0500    B90302        4504     CJNE R1 , # 3 , ( $+5 ) 
                      4505     
0503    789E          4506     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      4507     ENDIF
0505    E6            4508     MOV A , @ R0 
                      4509     
                      4510     PCA_INT_PPM_CALCULATE: 
0506    24FA          4511     	ADD	A, #250						; Add 1000us to minimum
0508    FE            4512     MOV R6 , A 
0509    E4            4513     	CLR	A
050A    3400          4514     	ADDC	A, #0
050C    FF            4515     MOV R7 , A 
                      4516     
050D    C3            4517     	CLR	C
050E    EC            4518     MOV A , R4 
050F    9E            4519     SUBB A , R6 
0510    FC            4520     MOV R4 , A 
0511    ED            4521     MOV A , R5 
0512    9F            4522     SUBB A , R7 
0513    FD            4523     MOV R5 , A 
                      4524     IF MODE >= 1	; Tail or multi
0514    9208          4525     	MOV	BIT_ACCESS_INT.0, C
0516    B90310        4526     CJNE R1 , # 3 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4527     
0519    A208          4528     	MOV	C, BIT_ACCESS_INT.0
051B    5007          4529     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      4530     
                      4531     PCA_INT_PPM_BIDIR_REV: 
051D    207609        4532     JB FLAGS2 . 6 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4533     
0520    D276          4534     SETB FLAGS2 . 6 
0522    A129          4535     	AJMP	PCA_INT_PPM_BIDIR_DIR_SET
                      4536     
                      4537     PCA_INT_PPM_BIDIR_FWD: 
0524    307602        4538     JNB FLAGS2 . 6 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4539     
0527    C276          4540     CLR FLAGS2 . 6 
                      4541     
                      4542     PCA_INT_PPM_BIDIR_DIR_SET: 
0529    A208          4543     	MOV	C, BIT_ACCESS_INT.0
                      4544     ENDIF
052B    5016          4545     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      4546     
                      4547     IF MODE >= 1	; Tail or multi
052D    B9030D        4548     CJNE R1 , # 3 , PCA_INT_PPM_UNIDIR_NEG 
                      4549     
0530    EC            4550     MOV A , R4 
0531    F4            4551     	CPL	A
0532    2401          4552     	ADD	A, #1
0534    FC            4553     MOV R4 , A 
0535    ED            4554     MOV A , R5 
0536    F4            4555     	CPL	A
0537    3400          4556     	ADDC	A, #0
0539    FD            4557     MOV R5 , A 
053A    020543        4558     	JMP	PCA_INT_PPM_NEG_CHECKED
                      4559     
                      4560     PCA_INT_PPM_UNIDIR_NEG: 
                      4561     ENDIF
053D    7800          4562     MOV R0 , # 0 
053F    7900          4563     MOV R1 , # 0 
0541    A18A          4564     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4565     
                      4566     PCA_INT_PPM_NEG_CHECKED: 
                      4567     IF MODE >= 1	; Tail or multi
0543    B90315        4568     CJNE R1 , # 3 , PCA_INT_PPM_BIDIR_DONE 
                      4569     
0546    EC            4570     MOV A , R4 
0547    33            4571     	RLC	A
0548    FC            4572     MOV R4 , A 
0549    ED            4573     MOV A , R5 
054A    33            4574     	RLC	A
054B    FD            4575     MOV R5 , A 
054C    C3            4576     	CLR	C							; Subtract deadband
054D    EC            4577     MOV A , R4 
054E    940A          4578     	SUBB	A, #10		
0550    FC            4579     MOV R4 , A 
0551    ED            4580     MOV A , R5 
0552    9400          4581     	SUBB	A, #0
0554    FD            4582     MOV R5 , A 
0555    5004          4583     	JNC	PCA_INT_PPM_BIDIR_DONE
                      4584     
0557    7C00          4585     MOV R4 , # 0 
0559    7D00          4586     MOV R5 , # 0 
                      4587     
                      4588     PCA_INT_PPM_BIDIR_DONE: 
                      4589     ENDIF
055B    C3            4590     	CLR	C							; Check that RC pulse is within legal range (max 255)
055C    EC            4591     MOV A , R4 
055D    94FF          4592     SUBB A , # 255 
055F    ED            4593     MOV A , R5 
0560    9400          4594     	SUBB	A, #0
0562    4006          4595     	JC	PCA_INT_PPM_MAX_CHECKED
                      4596     
0564    78FF          4597     MOV R0 , # 255 
0566    7900          4598     MOV R1 , # 0 
0568    A18A          4599     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4600     
                      4601     PCA_INT_PPM_MAX_CHECKED: 
056A    EC            4602     MOV A , R4 
056B    8572F0        4603     	MOV	B, PPM_THROTTLE_GAIN
056E    A4            4604     	MUL	AB
056F    C5F0          4605     	XCH	A, B
0571    A2F7          4606     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0573    33            4607     	RLC	A
0574    F8            4608     MOV R0 , A 
0575    7900          4609     MOV R1 , # 0 
0577    4003          4610     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      4611     	
0579    0205A6        4612     	JMP	PCA_INT_LIMITED			
                      4613     
                      4614     PCA_INT_PPM_LIMIT_AFTER_MULT: 
057C    78FF          4615     MOV R0 , # 255 
057E    7900          4616     MOV R1 , # 0 
0580    0205A6        4617     	JMP	PCA_INT_LIMITED			
                      4618     
                      4619     PCA_INT_PWM_DIVIDE: 
0583    E9            4620     MOV A , R1 
0584    C3            4621     	CLR	C
0585    13            4622     	RRC	A
0586    F9            4623     MOV R1 , A 
0587    E8            4624     MOV A , R0 
0588    13            4625     	RRC	A
0589    F8            4626     MOV R0 , A 
                      4627     
                      4628     PCA_INT_PWM_DIVIDE_DONE: 
058A    307C0E        4629     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
058D    E9            4630     MOV A , R1 
058E    6002          4631     	JZ	($+4)
                      4632     
0590    78FF          4633     MOV R0 , # 255 
                      4634     
0592    C3            4635     	CLR	C
0593    E8            4636     MOV A , R0 
0594    13            4637     	RRC	A
0595    38            4638     ADDC A , R0 
0596    F8            4639     MOV R0 , A 
0597    E4            4640     	CLR	A
0598    3400          4641     	ADDC	A, #0
059A    F9            4642     MOV R1 , A 
                      4643     
                      4644     PCA_INT_CHECK_LEGAL_RANGE: 
                      4645     	; Check that RC pulse is within legal range
059B    C3            4646     	CLR	C
059C    E8            4647     MOV A , R0 
059D    94FF          4648     SUBB A , # 255 
059F    E9            4649     MOV A , R1 
05A0    9400          4650     	SUBB	A, #0
05A2    4002          4651     	JC	PCA_INT_LIMITED
                      4652     
05A4    78FF          4653     MOV R0 , # 255 
                      4654     
                      4655     PCA_INT_LIMITED: 
                      4656     	; RC pulse value accepted
05A6    885C          4657     MOV NEW_RCP , R0 
05A8    D270          4658     SETB FLAGS2 . 0 
05AA    206102        4659     JB FLAGS0 . 1 , ( $+5 ) 
                      4660     
05AD    A1BE          4661     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      4662     
05AF    741F          4663     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
05B1    F4            4664     	CPL	A
05B2    552F          4665     	ANL	A, FLAGS3					; Clear all pwm frequency flags
05B4    4B            4666     ORL A , R3 
05B5    F52F          4667     	MOV	FLAGS3, A
05B7    C274          4668     CLR FLAGS2 . 4 
05B9    EB            4669     MOV A , R3 
05BA    7002          4670     	JNZ	PCA_INT_SET_TIMEOUT
                      4671     
05BC    D274          4672     SETB FLAGS2 . 4 
                      4673     
                      4674     PCA_INT_SET_TIMEOUT: 
05BE    752A18        4675     MOV RCP_TIMEOUT_CNTD , # 24 
05C1    307403        4676     JNB FLAGS2 . 4 , PCA_INT_PPM_TIMEOUT_SET 
                      4677     
05C4    752A0A        4678     MOV RCP_TIMEOUT_CNTD , # 10 
                      4679     
                      4680     PCA_INT_PPM_TIMEOUT_SET: 
05C7    306102        4681     JNB FLAGS0 . 1 , ( $+5 ) 
                      4682     
05CA    A1D2          4683     	AJMP PCA_INT_EXIT				; Yes - exit
                      4684     
05CC    207403        4685     JB FLAGS2 . 4 , PCA_INT_EXIT 
                      4686     
                      4687     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
05CF    53DAFE        4687+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      4688     
                      4689     PCA_INT_EXIT: 	; Exit interrupt routine	
05D2    207403        4690     JB FLAGS2 . 4 , ( $+6 ) 
                      4691     
05D5    752B06        4692     MOV RCP_SKIP_CNTD , # 6 
                      4693     
05D8    D0F0          4694     	POP	B			; Restore preserved registers
05DA    D0E0          4695     	POP	ACC			
05DC    D0D0          4696     	POP	PSW
05DE    D2AD          4697     	SETB	ET2			; Enable timer2 interrupts
05E0    43E610        4698     	ORL	EIE1, #10H	; Enable PCA0 interrupts
05E3    32            4699     	RETI
                      4700     
                      4701     
                      4702     
                      4703     
                      4704     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4705     ;
                      4706     ; Wait xms ~(x*4*250)  (Different entry points)	
                      4707     ;
                      4708     ; No assumptions
                      4709     ;
                      4710     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4711     WAIT1MS: 	
05E4    7901          4712     MOV R1 , # 1 
05E6    020602        4713     	JMP	WAITXMS_O
                      4714     
                      4715     WAIT3MS: 	
05E9    7903          4716     MOV R1 , # 3 
05EB    020602        4717     	JMP	WAITXMS_O
                      4718     
                      4719     WAIT10MS: 	
05EE    790A          4720     MOV R1 , # 10 
05F0    020602        4721     	JMP	WAITXMS_O
                      4722     
                      4723     WAIT30MS: 	
05F3    791E          4724     MOV R1 , # 30 
05F5    020602        4725     	JMP	WAITXMS_O
                      4726     
                      4727     WAIT100MS: 	
05F8    7964          4728     MOV R1 , # 100 
05FA    020602        4729     	JMP	WAITXMS_O
                      4730     
                      4731     WAIT200MS: 	
05FD    79C8          4732     MOV R1 , # 200 
05FF    020602        4733     	JMP	WAITXMS_O
                      4734     
                      4735     WAITXMS_O: 	; Outer loop
0602    7817          4736     MOV R0 , # 23 
                      4737     WAITXMS_M: 	; Middle loop
0604    E4            4738     	CLR	A
0605    D5E0FD        4739      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
0608    D8FA          4740     DJNZ R0 , WAITXMS_M 
060A    D9F6          4741     DJNZ R1 , WAITXMS_O 
060C    22            4742     	RET
                      4743     
                      4744     
                      4745     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4746     ;
                      4747     ; Beeper routines (4 different entry points) 
                      4748     ;
                      4749     ; No assumptions
                      4750     ;
                      4751     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4752     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
060D    7A14          4753     MOV R2 , # 20 
060F    7B78          4754     MOV R3 , # 120 
0611    020629        4755     	JMP	BEEP
                      4756     
                      4757     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
0614    7A10          4758     MOV R2 , # 16 
0616    7B8C          4759     MOV R3 , # 140 
0618    020629        4760     	JMP	BEEP
                      4761     
                      4762     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
061B    7A0D          4763     MOV R2 , # 13 
061D    7BB4          4764     MOV R3 , # 180 
061F    020629        4765     	JMP	BEEP
                      4766     
                      4767     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
0622    7A0B          4768     MOV R2 , # 11 
0624    7BC8          4769     MOV R3 , # 200 
0626    020629        4770     	JMP	BEEP
                      4771     
                      4772     BEEP: 	; Beep loop start
0629    E573          4773     	MOV	A, BEEP_STRENGTH
062B    D5E001        4774     	DJNZ	ACC, BEEP_START 
062E    22            4775     	RET
                      4776     
                      4777     BEEP_START:     
062F    7902          4778     MOV R1 , # 2 
                      4779     BEEP_ONOFF: 
0631    E4            4780     	CLR	A
                      4781     	BPFET_OFF			; BpFET off
0632    C296          4781+1   CLR P1 . 6 
0634    D5E0FD        4782     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      4783     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
0637    D297          4783+1   SETB P1 . 7 
0639    D5E0FD        4784     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      4785     	BNFET_OFF			; BnFET off again
063C    C297          4785+1   CLR P1 . 7 
063E    D5E0FD        4786     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      4787     	BPFET_ON			; BpFET on
0641    D296          4787+1   SETB P1 . 6 
0643    D5E0FD        4788     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      4789     	; Turn on nfet
0646    E9            4790     MOV A , R1 
0647    20E002        4791     	JB	ACC.0, BEEP_ANFET_ON
                      4792     	ANFET_ON			; AnFET on
064A    D295          4792+1   SETB P1 . 5 
                      4793     BEEP_ANFET_ON: 
064C    30E002        4794     	JNB	ACC.0, BEEP_CNFET_ON
                      4795     	CNFET_ON			; CnFET on
064F    D293          4795+1   SETB P1 . 3 
                      4796     BEEP_CNFET_ON: 
0651    E573          4797     	MOV	A, BEEP_STRENGTH
0653    D5E0FD        4798     	DJNZ	ACC, $		
                      4799     	; Turn off nfet
0656    E9            4800     MOV A , R1 
0657    20E002        4801     	JB	ACC.0, BEEP_ANFET_OFF
                      4802     	ANFET_OFF			; AnFET off
065A    C295          4802+1   CLR P1 . 5 
                      4803     BEEP_ANFET_OFF: 
065C    30E002        4804     	JNB	ACC.0, BEEP_CNFET_OFF
                      4805     	CNFET_OFF			; CnFET off
065F    C293          4805+1   CLR P1 . 3 
                      4806     BEEP_CNFET_OFF: 
0661    7496          4807     	MOV	A, #150		; 25s off
0663    D5E0FD        4808     	DJNZ	ACC, $		
0666    D9C9          4809     DJNZ R1 , BEEP_ONOFF 
                      4810     	; Copy variable
0668    EA            4811     MOV A , R2 
0669    F8            4812     MOV R0 , A 
                      4813     BEEP_OFF: 		; Fets off loop
066A    D5E0FD        4814     	DJNZ	ACC, $
066D    D8FB          4815     DJNZ R0 , BEEP_OFF 
066F    DBB8          4816     DJNZ R3 , BEEP 
                      4817     	BPFET_OFF			; BpFET off
0671    C296          4817+1   CLR P1 . 6 
0673    22            4818     	RET
                      4819     
                      4820     
                      4821     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4822     ;
                      4823     ; Division 16bit unsigned by 16bit unsigned
                      4824     ;
                      4825     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      4826     ; Result will be in Temp2/Temp1
                      4827     ;
                      4828     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4829     DIV_U16_BY_U16: 	
0674    C3            4830     	CLR	C       
0675    7C00          4831     MOV R4 , # 0 
0677    7D00          4832     MOV R5 , # 0 
0679    75F000        4833     	MOV	B, #0
                      4834     DIV_U16_BY_U16_DIV1: 
067C    05F0          4835     	INC	B      			; Increment counter for each left shift
067E    EA            4836     MOV A , R2 
067F    33            4837     	RLC	A      		
0680    FA            4838     MOV R2 , A 
0681    EB            4839     MOV A , R3 
0682    33            4840     	RLC	A      	  	
0683    FB            4841     MOV R3 , A 
0684    50F6          4842     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      4843     DIV_U16_BY_U16_DIV2:         
0686    EB            4844     MOV A , R3 
0687    13            4845     	RRC	A      
0688    FB            4846     MOV R3 , A 
0689    EA            4847     MOV A , R2 
068A    13            4848     	RRC	A      
068B    FA            4849     MOV R2 , A 
068C    C3            4850     	CLR	C      
068D    E9            4851     MOV A , R1 
068E    FF            4852     MOV R7 , A 
068F    E8            4853     MOV A , R0 
0690    FE            4854     MOV R6 , A 
0691    E8            4855     MOV A , R0 
0692    9A            4856     SUBB A , R2 
0693    F8            4857     MOV R0 , A 
0694    E9            4858     MOV A , R1 
0695    9B            4859     SUBB A , R3 
0696    F9            4860     MOV R1 , A 
0697    5004          4861     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
0699    EF            4862     MOV A , R7 
069A    F9            4863     MOV R1 , A 
069B    EE            4864     MOV A , R6 
069C    F8            4865     MOV R0 , A 
                      4866     DIV_U16_BY_U16_DIV3: 
069D    B3            4867     	CPL	C      			; Invert carry, so it can be directly copied into result
069E    EC            4868     MOV A , R4 
069F    33            4869     	RLC	A      			; Shift carry flag into temporary result
06A0    FC            4870     MOV R4 , A 
06A1    ED            4871     MOV A , R5 
06A2    33            4872     	RLC	A
06A3    FD            4873     MOV R5 , A 
06A4    D5F0DF        4874     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
06A7    ED            4875     MOV A , R5 
06A8    F9            4876     MOV R1 , A 
06A9    EC            4877     MOV A , R4 
06AA    F8            4878     MOV R0 , A 
06AB    22            4879     	RET
                      4880     
                      4881     
                      4882     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4883     ;
                      4884     ; Multiplication 16bit signed by 8bit unsigned
                      4885     ;
                      4886     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      4887     ; Result will be in Temp2/Temp1. Result will divided by 16
                      4888     ;
                      4889     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4890     MULT_S16_BY_U8_DIV_16: 
06AC    E8            4891     MOV A , R0 
06AD    89F0          4892     MOV B , R1 
06AF    8A20          4893     MOV BIT_ACCESS , R2 
06B1    D2D4          4894     	SETB	PSW.4		; Select register bank 2 for math routines
06B3    F8            4895     MOV R0 , A 
06B4    A9F0          4896     MOV R1 , B 
06B6    7B00          4897     MOV R3 , # 0 
06B8    30F70B        4898     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      4899     
06BB    7BFF          4900     MOV R3 , # 0FFH 
06BD    F4            4901     	CPL	A
06BE    2401          4902     	ADD	A, #1
06C0    F8            4903     MOV R0 , A 
06C1    E9            4904     MOV A , R1 
06C2    F4            4905     	CPL	A
06C3    3400          4906     	ADDC	A, #0
06C5    F9            4907     MOV R1 , A 
                      4908     MULT_S16_BY_U8_POSITIVE: 
06C6    E8            4909     MOV A , R0 
06C7    8520F0        4910     	MOV	B, BIT_ACCESS
06CA    A4            4911     	MUL	AB
06CB    ADF0          4912     MOV R5 , B 
06CD    F8            4913     MOV R0 , A 
06CE    E9            4914     MOV A , R1 
06CF    8520F0        4915     	MOV	B, BIT_ACCESS
06D2    A4            4916     	MUL	AB
06D3    AFF0          4917     MOV R7 , B 
06D5    FE            4918     MOV R6 , A 
06D6    ED            4919     MOV A , R5 
06D7    2E            4920     ADD A , R6 
06D8    F9            4921     MOV R1 , A 
06D9    7400          4922     	MOV	A, #0
06DB    3F            4923     ADDC A , R7 
06DC    FA            4924     MOV R2 , A 
06DD    7C04          4925     MOV R4 , # 4 
                      4926     MULT_S16_BY_U8_DIV_LOOP: 
06DF    C3            4927     	CLR	C			; Rotate right 
06E0    EA            4928     MOV A , R2 
06E1    13            4929     	RRC	A
06E2    FA            4930     MOV R2 , A 
06E3    E9            4931     MOV A , R1 
06E4    13            4932     	RRC	A
06E5    F9            4933     MOV R1 , A 
06E6    E8            4934     MOV A , R0 
06E7    13            4935     	RRC	A
06E8    F8            4936     MOV R0 , A 
06E9    DCF4          4937     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      4938     
06EB    8BF0          4939     MOV B , R3 
06ED    30F70A        4940     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      4941     
06F0    E8            4942     MOV A , R0 
06F1    F4            4943     	CPL	A
06F2    2401          4944     	ADD	A, #1
06F4    F8            4945     MOV R0 , A 
06F5    E9            4946     MOV A , R1 
06F6    F4            4947     	CPL	A
06F7    3400          4948     	ADDC	A, #0
06F9    F9            4949     MOV R1 , A 
                      4950     
                      4951     MULT_S16_BY_U8_EXIT: 
06FA    E8            4952     MOV A , R0 
06FB    89F0          4953     MOV B , R1 
06FD    C2D4          4954     	CLR	PSW.4		; Select normal register bank
06FF    F8            4955     MOV R0 , A 
0700    A9F0          4956     MOV R1 , B 
0702    22            4957     	RET
                      4958     
                      4959     
                      4960     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4961     ;
                      4962     ; Calculate governor routines
                      4963     ;
                      4964     ; No assumptions
                      4965     ;
                      4966     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      4967     ; The governor task is split into several routines in order to distribute processing time
                      4968     ;
                      4969     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4970     ; First governor routine - calculate governor target
                      4971     IF MODE == 0	; Main
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	JB	FLAGS1.GOV_ACTIVE, GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	JNB	FLAGS1.GOV_ACTIVE, GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                                
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	CLR	FLAGS1.GOV_ACTIVE
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	SETB	FLAGS1.GOV_ACTIVE
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      5109     IF MODE == 1	; Tail
                               CALC_GOVERNOR_TARGET:
                               	RET						
                               ENDIF
                      5113     IF MODE == 2	; Multi
                      5114     CALC_GOVERNOR_TARGET: 
0703    7882          5115     MOV R0 , # PGM_GOV_MODE 
0705    B60403        5116     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
0708    02075E        5117     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      5118     
                      5119     GOVERNOR_TARGET_CALC: 
                      5120     	; Stop governor for stop RC pulse	
070B    C3            5121     	CLR	C
070C    E55C          5122     	MOV	A, NEW_RCP				; Check RC pulse against stop value
070E    9401          5123     SUBB A , # 1 
0710    4003          5124     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      5125     
0712    020728        5126     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      5127     
                      5128     GOVERNOR_DEACTIVATE: 
0715    852224        5129     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
0718    E4            5130     	CLR	A
0719    F544          5131     	MOV	GOV_TARGET_L, A			; Set target to zero
071B    F545          5132     	MOV	GOV_TARGET_H, A
071D    F546          5133     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
071F    F547          5134     	MOV	GOV_INTEGRAL_H, A
0721    F548          5135     	MOV	GOV_INTEGRAL_X, A
0723    C26E          5136     CLR FLAGS1 . 6 
0725    02075E        5137     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      5138     
                      5139     GOVERNOR_ACTIVATE: 
0728    7882          5140     MOV R0 , # PGM_GOV_MODE 
072A    E6            5141     MOV A , @ R0 
072B    FC            5142     MOV R4 , A 
072C    D26E          5143     SETB FLAGS1 . 6 
072E    E522          5144     	MOV	A, REQUESTED_PWM			; Load requested pwm
0730    F523          5145     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      5146     	; Calculate comm period target 2*(51000/Requested_Pwm)
0732    7838          5147     MOV R0 , # 38H 
0734    79C7          5148     MOV R1 , # 0C7H 
0736    AA40          5149     MOV R2 , COMM_PERIOD4X_L 
0738    AB41          5150     MOV R3 , COMM_PERIOD4X_H 
                      5151     	; Set speed range 
073A    C3            5152     	CLR	C
073B    EB            5153     MOV A , R3 
073C    13            5154     	RRC	A
073D    FB            5155     MOV R3 , A 
073E    EA            5156     MOV A , R2 
073F    13            5157     	RRC	A
0740    FA            5158     MOV R2 , A 
                      5159     	; Check range
0741    EC            5160     MOV A , R4 
0742    14            5161     	DEC	A
0743    6013          5162     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      5163     GOVERNOR_ACTIVATE_100K: 
0745    C3            5164     	CLR	C
0746    EB            5165     MOV A , R3 
0747    13            5166     	RRC	A
0748    FB            5167     MOV R3 , A 
0749    EA            5168     MOV A , R2 
074A    13            5169     	RRC	A
074B    FA            5170     MOV R2 , A 
074C    EC            5171     MOV A , R4 
074D    14            5172     	DEC	A
074E    14            5173     	DEC	A
074F    6007          5174     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      5175     GOVERNOR_ACTIVATE_50K: 
0751    C3            5176     	CLR	C
0752    EB            5177     MOV A , R3 
0753    13            5178     	RRC	A
0754    FB            5179     MOV R3 , A 
0755    EA            5180     MOV A , R2 
0756    13            5181     	RRC	A
0757    FA            5182     MOV R2 , A 
                      5183     GOVERNOR_ACTIVATE_RANGE_SET: 
0758    D174          5184     	CALL	DIV_U16_BY_U16
                      5185     	; Store governor target
075A    8844          5186     MOV GOV_TARGET_L , R0 
075C    8945          5187     MOV GOV_TARGET_H , R1 
                      5188     CALC_GOVERNOR_TARGET_EXIT: 
075E    22            5189     	RET						
                      5190     ENDIF
                      5191     
                      5192     
                      5193     ; Second governor routine - calculate governor proportional error
                      5194     CALC_GOVERNOR_PROP_ERROR: 
                      5195     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      5213     IF MODE == 2	; Multi
                      5214     	; Calculate error
075F    C3            5215     	CLR	C
0760    E544          5216     	MOV	A, GOV_TARGET_L
0762    9523          5217     	SUBB	A, GOVERNOR_REQ_PWM
0764    F8            5218     MOV R0 , A 
0765    E545          5219     	MOV	A, GOV_TARGET_H
0767    9400          5220     	SUBB	A, #0
0769    F9            5221     MOV R1 , A 
                      5222     ENDIF
                      5223     	; Check error and limit
076A    500C          5224     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      5225     
076C    C3            5226     	CLR	C
076D    E8            5227     MOV A , R0 
076E    9480          5228     	SUBB	A, #80H					; Is error too negative?
0770    E9            5229     MOV A , R1 
0771    94FF          5230     	SUBB	A, #0FFH
0773    4016          5231     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
0775    02078F        5232     	JMP	GOVERNOR_STORE_PROP_ERROR
                      5233     
                      5234     GOVERNOR_CHECK_PROP_LIMIT_POS: 
0778    C3            5235     	CLR	C
0779    E8            5236     MOV A , R0 
077A    947F          5237     	SUBB	A, #7FH					; Is error too positive?
077C    E9            5238     MOV A , R1 
077D    9400          5239     	SUBB	A, #00H
077F    5003          5240     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
0781    02078F        5241     	JMP	GOVERNOR_STORE_PROP_ERROR
                      5242     
                      5243     GOVERNOR_LIMIT_PROP_ERROR_POS: 
0784    787F          5244     MOV R0 , # 7FH 
0786    7900          5245     MOV R1 , # 00H 
0788    02078F        5246     	JMP	GOVERNOR_STORE_PROP_ERROR
                      5247     
                      5248     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
078B    7880          5249     MOV R0 , # 80H 
078D    79FF          5250     MOV R1 , # 0FFH 
                      5251     
                      5252     GOVERNOR_STORE_PROP_ERROR: 
                      5253     	; Store proportional
078F    8849          5254     MOV GOV_PROPORTIONAL_L , R0 
0791    894A          5255     MOV GOV_PROPORTIONAL_H , R1 
                      5256     CALC_GOVERNOR_PROP_ERROR_EXIT: 
0793    22            5257     	RET						
                      5258     
                      5259     
                      5260     ; Third governor routine - calculate governor integral error
                      5261     CALC_GOVERNOR_INT_ERROR: 
                      5262     	; Add proportional to integral
0794    E549          5263     	MOV	A, GOV_PROPORTIONAL_L
0796    2546          5264     	ADD	A, GOV_INTEGRAL_L
0798    F8            5265     MOV R0 , A 
0799    E54A          5266     	MOV	A, GOV_PROPORTIONAL_H
079B    3547          5267     	ADDC	A, GOV_INTEGRAL_H
079D    F9            5268     MOV R1 , A 
079E    854A20        5269     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
07A1    E4            5270     	CLR	A
07A2    300701        5271     	JNB	BIT_ACCESS.7, ($+4)			
07A5    F4            5272     	CPL	A
07A6    3548          5273     	ADDC	A, GOV_INTEGRAL_X
07A8    FA            5274     MOV R2 , A 
                      5275     	; Check integral and limit
07A9    30E709        5276     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      5277     
07AC    C3            5278     	CLR	C
07AD    EA            5279     MOV A , R2 
07AE    94F0          5280     	SUBB	A, #0F0H					; Is error too negative?
07B0    4015          5281     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
07B2    0207CD        5282     	JMP	GOVERNOR_CHECK_PWM
                      5283     
                      5284     GOVERNOR_CHECK_INT_LIMIT_POS: 
07B5    C3            5285     	CLR	C
07B6    EA            5286     MOV A , R2 
07B7    940F          5287     	SUBB	A, #0FH					; Is error too positive?
07B9    5003          5288     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
07BB    0207CD        5289     	JMP	GOVERNOR_CHECK_PWM
                      5290     
                      5291     GOVERNOR_LIMIT_INT_ERROR_POS: 
07BE    78FF          5292     MOV R0 , # 0FFH 
07C0    79FF          5293     MOV R1 , # 0FFH 
07C2    7A0F          5294     MOV R2 , # 0FH 
07C4    0207CD        5295     	JMP	GOVERNOR_CHECK_PWM
                      5296     
                      5297     GOVERNOR_LIMIT_INT_ERROR_NEG: 
07C7    7800          5298     MOV R0 , # 00H 
07C9    7900          5299     MOV R1 , # 00H 
07CB    7AF0          5300     MOV R2 , # 0F0H 
                      5301     
                      5302     GOVERNOR_CHECK_PWM: 
                      5303     	; Check current pwm
07CD    C3            5304     	CLR	C
07CE    E524          5305     	MOV	A, CURRENT_PWM
07D0    9561          5306     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
07D2    500A          5307     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      5308     
07D4    C3            5309     	CLR	C
07D5    7401          5310     	MOV	A, #1
07D7    9524          5311     	SUBB	A, CURRENT_PWM				; Is current pwm at minimum?
07D9    500B          5312     	JNC	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      5313     
07DB    0207EB        5314     	JMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      5315     
                      5316     GOVERNOR_INT_MAX_PWM: 
07DE    E54A          5317     	MOV	A, GOV_PROPORTIONAL_H
07E0    20E70E        5318     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      5319     
07E3    0207EB        5320     	JMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      5321     
                      5322     GOVERNOR_INT_MIN_PWM: 
07E6    E54A          5323     	MOV	A, GOV_PROPORTIONAL_H
07E8    30E706        5324     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      5325     
                      5326     GOVERNOR_STORE_INT_ERROR: 
                      5327     	; Store integral
07EB    8846          5328     MOV GOV_INTEGRAL_L , R0 
07ED    8947          5329     MOV GOV_INTEGRAL_H , R1 
07EF    8A48          5330     MOV GOV_INTEGRAL_X , R2 
                      5331     CALC_GOVERNOR_INT_ERROR_EXIT: 
07F1    22            5332     	RET						
                      5333     
                      5334     
                      5335     ; Fourth governor routine - calculate governor proportional correction
                      5336     CALC_GOVERNOR_PROP_CORRECTION: 
                      5337     	; Load proportional gain
07F2    78A5          5338     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
07F4    E6            5339     MOV A , @ R0 
07F5    FA            5340     MOV R2 , A 
                      5341     	; Load proportional
07F6    C3            5342     	CLR	C
07F7    E549          5343     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
07F9    33            5344     	RLC	A
07FA    F8            5345     MOV R0 , A 
07FB    E54A          5346     	MOV	A, GOV_PROPORTIONAL_H
07FD    33            5347     	RLC	A
07FE    F9            5348     MOV R1 , A 
                      5349     	; Apply gain
07FF    1206AC        5350     	CALL	MULT_S16_BY_U8_DIV_16
                      5351     	; Check error and limit (to low byte)
0802    E9            5352     MOV A , R1 
0803    30E70B        5353     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      5354     
0806    C3            5355     	CLR	C
0807    E8            5356     MOV A , R0 
0808    9480          5357     	SUBB	A, #80H					; Is error too negative?
080A    E9            5358     MOV A , R1 
080B    94FF          5359     	SUBB	A, #0FFH
080D    4013          5360     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
080F    0126          5361     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      5362     
                      5363     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0811    C3            5364     	CLR	C
0812    E8            5365     MOV A , R0 
0813    947F          5366     	SUBB	A, #7FH					; Is error too positive?
0815    E9            5367     MOV A , R1 
0816    9400          5368     	SUBB	A, #00H
0818    5002          5369     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
081A    0126          5370     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      5371     
                      5372     GOVERNOR_LIMIT_PROP_CORR_POS: 
081C    787F          5373     MOV R0 , # 7FH 
081E    7900          5374     MOV R1 , # 00H 
0820    0126          5375     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      5376     
                      5377     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0822    7880          5378     MOV R0 , # 80H 
0824    79FF          5379     MOV R1 , # 0FFH 
                      5380     
                      5381     GOVERNOR_APPLY_PROP_CORR: 
                      5382     	; Test proportional sign
0826    E8            5383     MOV A , R0 
0827    20E715        5384     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      5385     
                      5386     	; Subtract positive proportional
082A    C3            5387     	CLR	C
082B    E523          5388     	MOV	A, GOVERNOR_REQ_PWM
082D    98            5389     SUBB A , R0 
082E    F8            5390     MOV R0 , A 
                      5391     	; Check result
082F    4009          5392     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      5393     
0831    C3            5394     	CLR	C
0832    E8            5395     MOV A , R0 
0833    9401          5396     	SUBB	A, #1
0835    4003          5397     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0837    02084D        5398     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      5399     
                      5400     GOVERNOR_CORR_PROP_MIN_PWM: 
083A    7801          5401     MOV R0 , # 1 
083C    02084D        5402     	JMP	GOVERNOR_STORE_PROP_CORR
                      5403     
                      5404     GOVERNOR_CORR_NEG_PROP: 
                      5405     	; Add negative proportional
083F    E8            5406     MOV A , R0 
0840    F4            5407     	CPL	A
0841    2401          5408     	ADD	A, #1
0843    2523          5409     	ADD	A, GOVERNOR_REQ_PWM
0845    F8            5410     MOV R0 , A 
                      5411     	; Check result
0846    4003          5412     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0848    02084D        5413     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      5414     
                      5415     GOVERNOR_CORR_PROP_MAX_PWM: 
084B    78FF          5416     MOV R0 , # 255 
                      5417     GOVERNOR_STORE_PROP_CORR: 
                      5418     	; Store proportional pwm
084D    884B          5419     MOV GOV_PROP_PWM , R0 
                      5420     CALC_GOVERNOR_PROP_CORR_EXIT: 
084F    22            5421     	RET
                      5422     
                      5423     
                      5424     ; Fifth governor routine - calculate governor integral correction
                      5425     CALC_GOVERNOR_INT_CORRECTION: 
                      5426     	; Load integral gain
0850    78A6          5427     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0852    E6            5428     MOV A , @ R0 
0853    FA            5429     MOV R2 , A 
                      5430     	; Load integral
0854    A847          5431     MOV R0 , GOV_INTEGRAL_H 
0856    A948          5432     MOV R1 , GOV_INTEGRAL_X 
                      5433     	; Apply gain
0858    1206AC        5434     	CALL	MULT_S16_BY_U8_DIV_16
                      5435     	; Check integral and limit
085B    E9            5436     MOV A , R1 
085C    30E70C        5437     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      5438     
085F    C3            5439     	CLR	C
0860    E8            5440     MOV A , R0 
0861    9401          5441     	SUBB	A, #01H					; Is integral too negative?
0863    E9            5442     MOV A , R1 
0864    94FF          5443     	SUBB	A, #0FFH
0866    4016          5444     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0868    020882        5445     	JMP	GOVERNOR_APPLY_INT_CORR
                      5446     
                      5447     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
086B    C3            5448     	CLR	C
086C    E8            5449     MOV A , R0 
086D    94FF          5450     	SUBB	A, #0FFH					; Is integral too positive?
086F    E9            5451     MOV A , R1 
0870    9400          5452     	SUBB	A, #00H
0872    5003          5453     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0874    020882        5454     	JMP	GOVERNOR_APPLY_INT_CORR
                      5455     
                      5456     GOVERNOR_LIMIT_INT_CORR_POS: 
0877    78FF          5457     MOV R0 , # 0FFH 
0879    7900          5458     MOV R1 , # 00H 
087B    020882        5459     	JMP	GOVERNOR_APPLY_INT_CORR
                      5460     
                      5461     GOVERNOR_LIMIT_INT_CORR_NEG: 
087E    7801          5462     MOV R0 , # 01H 
0880    79FF          5463     MOV R1 , # 0FFH 
                      5464     
                      5465     GOVERNOR_APPLY_INT_CORR: 
                      5466     	; Test integral sign
0882    E9            5467     MOV A , R1 
0883    20E715        5468     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      5469     
                      5470     	; Subtract positive integral
0886    C3            5471     	CLR	C
0887    E54B          5472     	MOV	A, GOV_PROP_PWM
0889    98            5473     SUBB A , R0 
088A    F8            5474     MOV R0 , A 
                      5475     	; Check result
088B    4009          5476     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      5477     
088D    C3            5478     	CLR	C
088E    E8            5479     MOV A , R0 
088F    9401          5480     	SUBB	A, #1
0891    4003          5481     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0893    0208A9        5482     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      5483     
                      5484     GOVERNOR_CORR_INT_MIN_PWM: 
0896    7801          5485     MOV R0 , # 1 
0898    0208A9        5486     	JMP	GOVERNOR_STORE_INT_CORR
                      5487     
                      5488     GOVERNOR_CORR_NEG_INT: 
                      5489     	; Add negative integral
089B    E8            5490     MOV A , R0 
089C    F4            5491     	CPL	A
089D    2401          5492     	ADD	A, #1
089F    254B          5493     	ADD	A, GOV_PROP_PWM
08A1    F8            5494     MOV R0 , A 
                      5495     	; Check result
08A2    4003          5496     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
08A4    0208A9        5497     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      5498     
                      5499     GOVERNOR_CORR_INT_MAX_PWM: 
08A7    78FF          5500     MOV R0 , # 255 
                      5501     GOVERNOR_STORE_INT_CORR: 
                      5502     	; Store current pwm
08A9    8824          5503     MOV CURRENT_PWM , R0 
                      5504     CALC_GOVERNOR_INT_CORR_EXIT: 
08AB    22            5505     	RET
                      5506     
                      5507     
                      5508     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5509     ;
                      5510     ; Set pwm limit low rpm
                      5511     ;
                      5512     ; No assumptions
                      5513     ;
                      5514     ; Sets power limit for low rpms and disables demag for low rpms
                      5515     ;
                      5516     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5517     SET_PWM_LIMIT_LOW_RPM: 
                      5518     	; Set pwm limit and demag disable for low rpms
08AC    78FF          5519     MOV R0 , # 0FFH 
08AE    206928        5520     JB FLAGS1 . 1 , SET_PWM_LIMIT_LOW_RPM_EXIT 
                      5521     
08B1    79A1          5522     MOV R1 , # PGM_ENABLE_POWER_PROT 
08B3    E7            5523     MOV A , @ R1 
08B4    6023          5524     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Exit if disabled
                      5525     
08B6    E541          5526     	MOV	A, COMM_PERIOD4X_H
08B8    601F          5527     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Avoid divide by zero
                      5528     
08BA    74FF          5529     	MOV	A, #255						; Divide 255 by Comm_Period4x_H
08BC    8541F0        5530     	MOV	B, COMM_PERIOD4X_H
08BF    84            5531     	DIV	AB
08C0    8539F0        5532     	MOV	B, LOW_RPM_PWR_SLOPE			; Multiply by slope
08C3    306A03        5533     JNB FLAGS1 . 2 , ( $+6 ) 
08C6    75F005        5534     	MOV	B, #5
08C9    A4            5535     	MUL	AB
08CA    F8            5536     MOV R0 , A 
08CB    C5F0          5537     	XCH	A, B
08CD    6002          5538     	JZ	($+4)						; Limit to max
                      5539     	
08CF    78FF          5540     MOV R0 , # 0FFH 
                      5541     
08D1    C3            5542     	CLR	C
08D2    E8            5543     MOV A , R0 
08D3    9564          5544     	SUBB	A, PWM_SPOOLUP_BEG
08D5    5002          5545     	JNC	SET_PWM_LIMIT_LOW_RPM_EXIT
                      5546     
08D7    A864          5547     MOV R0 , PWM_SPOOLUP_BEG 
                      5548     
                      5549     SET_PWM_LIMIT_LOW_RPM_EXIT: 
08D9    8863          5550     MOV PWM_LIMIT_BY_RPM , R0 
08DB    22            5551     	RET
                      5552     	
                      5553     
                      5554     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5555     ;
                      5556     ; Set pwm limit high rpm
                      5557     ;
                      5558     ; No assumptions
                      5559     ;
                      5560     ; Sets power limit for high rpms
                      5561     ;
                      5562     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5563     SET_PWM_LIMIT_HIGH_RPM: 
                      5564     IF MCU_48MHZ == 1
08DC    C3            5565     	CLR	C
08DD    E540          5566     	MOV	A, COMM_PERIOD4X_L
08DF    94C8          5567     	SUBB	A, #0C8H				; Limit Comm_Period to 200, which is 400k erpm
08E1    E541          5568     	MOV	A, COMM_PERIOD4X_H
08E3    9400          5569     	SUBB	A, #00H
                      5570     ELSE
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_L
                               	SUBB	A, #40H				; Limit Comm_Period to 320, which is 250k erpm
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, #01H
                               ENDIF
08E5    E563          5577     	MOV	A, PWM_LIMIT_BY_RPM
08E7    5003          5578     	JNC	SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT
                      5579     	
08E9    14            5580     	DEC	A
08EA    01ED          5581     	AJMP	SET_PWM_LIMIT_HIGH_RPM_STORE
                      5582     	
                      5583     SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT: 
08EC    04            5584     	INC	A
                      5585     SET_PWM_LIMIT_HIGH_RPM_STORE: 
08ED    6002          5586     	JZ	($+4)
                      5587     
08EF    F563          5588     	MOV	PWM_LIMIT_BY_RPM, A
                      5589     
08F1    22            5590     	RET
                      5591     
                      5592     
                      5593     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5594     ;
                      5595     ; Measure lipo cells
                      5596     ;
                      5597     ; No assumptions
                      5598     ;
                      5599     ; Measure voltage and calculate lipo cells
                      5600     ;
                      5601     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5602     MEASURE_LIPO_CELLS: 
                      5603     IF MODE >= 1	; Tail or multi
                      5604     	; If not supported, then exit
08F2    0208F5        5605     	JMP	MEASURE_LIPO_EXIT
                      5606     ENDIF
                      5607     IF MODE == 0	; Main
                               	; Load programmed low voltage limit
                               	MOV	TEMP1, #PGM_LOW_VOLTAGE_LIM	; Load limit
                               	MOV	A, @TEMP1				
                               	MOV	BIT_ACCESS, A				; Store in Bit_Access
                               	; Set commutation to BpFET on
                               	CALL	COMM5COMM6			
                               	; Start adc
                               	START_ADC 
                               	; Wait for ADC reference to settle, and then start again
                               	CALL	WAIT1MS
                               	START_ADC
                               	; Wait for ADC conversion to complete
                               MEASURE_LIPO_WAIT_ADC:
                               	JNB	AD0INT, MEASURE_LIPO_WAIT_ADC
                               	; Read ADC result
                               	READ_ADC_RESULT
                               	; Stop ADC
                               	STOP_ADC
                               	; Switch power off
                               	CALL	SWITCH_POWER_OFF		
                               	; Set limit step
                               	MOV	LIPO_ADC_LIMIT_L, #ADC_LIMIT_L
                               	MOV	LIPO_ADC_LIMIT_H, #ADC_LIMIT_H
                               	CLR	C
                               	MOV	A, #ADC_LIMIT_H		; Divide 3.0V value by 2
                               	RRC	A
                               	MOV	TEMP6, A
                               	MOV	A, #ADC_LIMIT_L
                               	JZ	MEASURE_LIPO_EXIT		; Exit if disabled
                               
                               	RRC	A
                               	MOV	TEMP5, A
                               	MOV	A, #ADC_LIMIT_L		; Calculate 1.5*3.0V=4.5V value
                               	ADD	A, TEMP5
                               	MOV	TEMP5, A
                               	MOV	A, #ADC_LIMIT_H		
                               	ADDC	A, TEMP6
                               	MOV	TEMP6, A
                               	MOV	A, TEMP5				; Copy step
                               	MOV	TEMP3, A
                               	MOV	A, TEMP6	
                               	MOV	TEMP4, A
                               MEASURE_LIPO_CELL_LOOP:
                               	; Check voltage against xS lower limit
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, TEMP3				; Voltage above limit?
                               	MOV	A, TEMP2
                               	SUBB A, TEMP4
                               	JC	MEASURE_LIPO_ADJUST		; No - branch
                               
                               	; Set xS voltage limit
                               	MOV	A, LIPO_ADC_LIMIT_L		
                               	ADD	A, #ADC_LIMIT_L
                               	MOV	LIPO_ADC_LIMIT_L, A
                               	MOV	A, LIPO_ADC_LIMIT_H		
                               	ADDC	A, #ADC_LIMIT_H
                               	MOV	LIPO_ADC_LIMIT_H, A
                               	; Set (x+1)S lower limit
                               	MOV	A, TEMP3
                               	ADD	A, TEMP5				; Add step
                               	MOV	TEMP3, A
                               	MOV	A, TEMP4
                               	ADDC	A, TEMP6
                               	MOV	TEMP4, A
                               	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                               
                               MEASURE_LIPO_ADJUST:
                               	MOV	TEMP7, LIPO_ADC_LIMIT_L
                               	MOV	TEMP8, LIPO_ADC_LIMIT_H
                               	; Calculate 3.125%
                               	CLR	C
                               	MOV	A, LIPO_ADC_LIMIT_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, LIPO_ADC_LIMIT_L	
                               	RRC	A
                               	MOV	TEMP1, A			; After this 50%
                               	CLR	C
                               	MOV	A, TEMP2
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1	
                               	RRC	A
                               	MOV	TEMP1, A			; After this 25%
                               	; Divide three times to get to 3.125%
                               	MOV	TEMP3, #3
                               MEASURE_LIPO_DIVIDE_LOOP:
                               	CLR	C
                               	MOV	A, TEMP2
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1	
                               	RRC	A
                               	MOV	TEMP1, A			
                               	DJNZ	TEMP3, MEASURE_LIPO_DIVIDE_LOOP
                               
                               	; Add the programmed number of 0.1V (or 3.125% increments)
                               	MOV	TEMP3, BIT_ACCESS		; Load programmed limit (Bit_Access has Pgm_Low_Voltage_Lim)
                               	DEC	TEMP3
                               	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                               
                               	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
                               	MOV	LIPO_ADC_LIMIT_H, #0
                               	JMP	MEASURE_LIPO_EXIT	
                               
                               MEASURE_LIPO_LIMIT_ON:
                               	DEC	TEMP3
                               	MOV	A, TEMP3
                               	JZ	MEASURE_LIPO_UPDATE
                               
                               MEASURE_LIPO_ADD_LOOP:
                               	MOV	A, TEMP7			; Add 3.125%
                               	ADD	A, TEMP1
                               	MOV	TEMP7, A
                               	MOV	A, TEMP8
                               	ADDC	A, TEMP2
                               	MOV	TEMP8, A
                               	DJNZ	TEMP3, MEASURE_LIPO_ADD_LOOP
                               
                               MEASURE_LIPO_UPDATE:
                               	; Set ADC limit
                               	MOV	LIPO_ADC_LIMIT_L, TEMP7
                               	MOV	LIPO_ADC_LIMIT_H, TEMP8
                               ENDIF
                      5733     MEASURE_LIPO_EXIT: 
08F5    22            5734     	RET
                      5735     
                      5736     
                      5737     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5738     ;
                      5739     ; Start ADC conversion
                      5740     ;
                      5741     ; No assumptions
                      5742     ;
                      5743     ; Start conversion used for measuring power supply voltage
                      5744     ;
                      5745     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5746     START_ADC_CONVERSION: 
                      5747     	; Start adc
                      5748     	START_ADC 
08F6    75E890        5748+1   MOV ADC0CN , # 90H  ; ADC START
08F9    22            5749     	RET
                      5750     
                      5751     
                      5752     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5753     ;
                      5754     ; Check temperature, power supply voltage and limit power
                      5755     ;
                      5756     ; No assumptions
                      5757     ;
                      5758     ; Used to limit main motor power in order to maintain the required voltage
                      5759     ;
                      5760     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5761     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      5762     	; Load programmed low voltage limit
08FA    7883          5763     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
08FC    E6            5764     MOV A , @ R0 
08FD    FF            5765     MOV R7 , A 
                      5766     	; Wait for ADC conversion to complete
08FE    30EDF9        5767     	JNB	AD0INT, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      5768     	; Read ADC result
                      5769     	READ_ADC_RESULT
0901    A8BD          5769+1   MOV R0 , ADC0L 
0903    A9BE          5769+1   MOV R1 , ADC0H 
                      5770     	; Stop ADC
                      5771     	STOP_ADC
                      5772     
0905    0570          5773     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0907    C3            5774     	CLR	C
0908    E570          5775     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
090A    9408          5776     SUBB A , # 8 
090C    4052          5777     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      5778     
090E    757000        5779     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0911    E9            5780     MOV A , R1 
0912    FA            5781     MOV R2 , A 
0913    79A0          5782     MOV R1 , # PGM_ENABLE_TEMP_PROT 
0915    E7            5783     MOV A , @ R1 
0916    6044          5784     	JZ	TEMP_CHECK_EXIT			; No - branch
                      5785     
0918    EA            5786     MOV A , R2 
0919    7007          5787     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      5788     
091B    E571          5789     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
091D    601B          5790     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
091F    02092E        5791     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      5792     
                      5793     TEMP_AVERAGE_INC_DEC: 
0922    C3            5794     	CLR	C
0923    E8            5795     MOV A , R0 
0924    9571          5796     	SUBB	A, CURRENT_AVERAGE_TEMP
0926    6010          5797     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      5798     
0928    E571          5799     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
092A    5006          5800     	JNC	TEMP_AVERAGE_INC				
                      5801     
092C    600C          5802     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      5803     TEMP_AVERAGE_DEC: 
092E    14            5804     	DEC	A						; Decrement average
092F    02093A        5805     	JMP	TEMP_AVERAGE_UPDATED
                      5806     
                      5807     TEMP_AVERAGE_INC: 
0932    04            5808     	INC	A						; Increment average
0933    60F9          5809     	JZ	TEMP_AVERAGE_DEC
0935    02093A        5810     	JMP	TEMP_AVERAGE_UPDATED
                      5811     
                      5812     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0938    E571          5813     	MOV	A, CURRENT_AVERAGE_TEMP
                      5814     TEMP_AVERAGE_UPDATED: 
093A    F571          5815     	MOV	CURRENT_AVERAGE_TEMP, A
093C    C3            5816     	CLR	C
093D    9472          5817     SUBB A , # 114 
093F    401B          5818     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5819     
0941    7561C0        5820     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      5821     
0944    C3            5822     	CLR	C
0945    9404          5823     SUBB A , # 4 
0947    4013          5824     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5825     
0949    756180        5826     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      5827     
094C    C3            5828     	CLR	C
094D    9404          5829     SUBB A , # 4 
094F    400B          5830     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5831     
0951    756140        5832     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      5833     
0954    C3            5834     	CLR	C
0955    9404          5835     SUBB A , # 4 
0957    4003          5836     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5837     
0959    756100        5838     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      5839     
                      5840     TEMP_CHECK_EXIT: 
                      5841     	SET_ADC_IP_VOLT				; Select adc input for next conversion
095C    75BB08        5841+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
095F    22            5842     	RET
                      5843     
                      5844     CHECK_VOLTAGE_START: 
                      5845     IF MODE == 0	; Main 
                               	; Check if low voltage limiting is enabled
                               	MOV	A, TEMP8
                               	CLR	C
                               	SUBB	A, #1					; Is low voltage limit disabled?
                               	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                               
                               	MOV	A, #ADC_LIMIT_L			; Is low voltage limit zero (ESC does not support it)?
                               	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                               
                               	; Check if ADC is saturated
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, #0FFH
                               	MOV	A, TEMP2
                               	SUBB	A, #03H
                               	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                               
                               	; Check voltage against limit
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, LIPO_ADC_LIMIT_L
                               	MOV	A, TEMP2
                               	SUBB	A, LIPO_ADC_LIMIT_H
                               	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                               
                               	; Decrease pwm limit
                               	MOV  A, PWM_LIMIT
                               	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                               
                               	DEC	PWM_LIMIT					; Decrement limit
                               	JMP	CHECK_VOLTAGE_LIM
                               
                               CHECK_VOLTAGE_GOOD:
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	CPL	A			
                               	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                               
                               	INC	PWM_LIMIT					; Increment limit
                               
                               CHECK_VOLTAGE_LIM:
                               	MOV	TEMP1, PWM_LIMIT			; Set limit
                               	CLR	C
                               	MOV	A, CURRENT_PWM
                               	SUBB	A, TEMP1
                               	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                               
                               	MOV	TEMP1, CURRENT_PWM			; Set current pwm (no limiting)
                               
                               CHECK_VOLTAGE_SPOOLUP_LIM:
                               	; Slow spoolup
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_LIMIT_SPOOLUP
                               	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                               
                               	MOV	TEMP1, PWM_LIMIT_SPOOLUP
                               	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
                               	CPL	A
                               	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                                
                               	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                               
                               CHECK_VOLTAGE_EXIT:
                               	MOV  CURRENT_PWM_LIMITED, TEMP1
                               	MOV	CURRENT_PWM_LIM_DITH, TEMP1
                               ENDIF
                      5913     IF MODE == 1	; Tail
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	CPL	A			
                               	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                               
                               	INC	PWM_LIMIT					; Increment limit
                               
                               CHECK_VOLTAGE_LIM:
                               ENDIF
                      5923     IF MODE == 2	; Multi
                      5924     	; Increase pwm limit
0960    E561          5925     	MOV  A, PWM_LIMIT
0962    2410          5926     	ADD	A, #16			
0964    5002          5927     	JNC	($+4)					; If not max - branch
                      5928     
0966    74FF          5929     	MOV	A, #255
                      5930     
0968    F561          5931     	MOV	PWM_LIMIT, A				; Increment limit 
                      5932     	; Set current pwm limited if closed loop mode
096A    7982          5933     MOV R1 , # PGM_GOV_MODE 
096C    B70402        5934     CJNE @ R1 , # 4 , ( $+5 ) 
096F    2187          5935     	AJMP	CHECK_VOLTAGE_PWM_DONE		; No - branch
                      5936     
0971    C3            5937     	CLR	C
0972    A861          5938     MOV R0 , PWM_LIMIT 
0974    E524          5939     	MOV	A, CURRENT_PWM
0976    98            5940     SUBB A , R0 
0977    5002          5941     	JNC	CHECK_VOLTAGE_LOW_RPM		; If current pwm above limit - branch and limit	
                      5942     
0979    A824          5943     MOV R0 , CURRENT_PWM 
                      5944     
                      5945     CHECK_VOLTAGE_LOW_RPM: 
                      5946     	; Limit pwm for low rpms
097B    C3            5947     	CLR	C
097C    E8            5948     MOV A , R0 
097D    9563          5949     	SUBB	A, PWM_LIMIT_BY_RPM
097F    4002          5950     	JC	($+4)					; If current pwm below limit - branch
                      5951     
0981    A863          5952     MOV R0 , PWM_LIMIT_BY_RPM 
                      5953     
0983    8825          5954     MOV CURRENT_PWM_LIMITED , R0 
0985    8826          5955     MOV CURRENT_PWM_LIM_DITH , R0 
                      5956     CHECK_VOLTAGE_PWM_DONE: 
                      5957     ENDIF
                      5958     	; Set adc mux for next conversion
0987    E570          5959     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0989    B40703        5960     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      5961     
                      5962     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
098C    75BB10        5962+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5963     
                      5964     CHECK_VOLTAGE_RET: 
098F    22            5965     	RET
                      5966     
                      5967     
                      5968     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5969     ;
                      5970     ; Set startup PWM routine
                      5971     ;
                      5972     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      5973     ;
                      5974     ; Used for pwm control during startup
                      5975     ;
                      5976     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5977     SET_STARTUP_PWM: 	
                      5978     	; Adjust startup power
0990    7432          5979     MOV A , # 50 
0992    79A7          5980     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0994    87F0          5981     MOV B , @ R1 
0996    A4            5982     	MUL	AB
0997    C5F0          5983     	XCH	A, B
0999    A2F7          5984     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
099B    33            5985     	RLC	A
099C    F8            5986     MOV R0 , A 
099D    C3            5987     	CLR	C
099E    E8            5988     MOV A , R0 
099F    9561          5989     	SUBB	A, PWM_LIMIT	
09A1    4002          5990     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      5991     
09A3    A861          5992     MOV R0 , PWM_LIMIT 
                      5993     
                      5994     STARTUP_PWM_SET_PWM: 
                      5995     	; Set pwm variables
09A5    8822          5996     MOV REQUESTED_PWM , R0 
09A7    8824          5997     MOV CURRENT_PWM , R0 
09A9    8825          5998     MOV CURRENT_PWM_LIMITED , R0 
09AB    8826          5999     MOV CURRENT_PWM_LIM_DITH , R0 
09AD    8864          6000     MOV PWM_SPOOLUP_BEG , R0 
09AF    22            6001     	RET
                      6002     
                      6003     
                      6004     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6005     ;
                      6006     ; Initialize timing routine
                      6007     ;
                      6008     ; No assumptions
                      6009     ;
                      6010     ; Part of initialization before motor start
                      6011     ;
                      6012     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6013     INITIALIZE_TIMING:  
09B0    754000        6014     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
09B3    7541F0        6015     	MOV	COMM_PERIOD4X_H, #0F0H
09B6    22            6016     	RET
                      6017     
                      6018     
                      6019     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6020     ;
                      6021     ; Calculate next commutation timing routine
                      6022     ;
                      6023     ; No assumptions
                      6024     ;
                      6025     ; Called immediately after each commutation
                      6026     ; Also sets up timer 3 to wait advance timing
                      6027     ; Two entry points are used
                      6028     ;
                      6029     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6030     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
                      6031     	; Read commutation time
09B7    C2AF          6032     	CLR	EA
09B9    75C820        6033     	MOV	TMR2CN, #20H		; Timer2 disabled
09BC    A8CC          6034     MOV R0 , TMR2L 
09BE    A9CD          6035     MOV R1 , TMR2H 
09C0    AA3A          6036     MOV R2 , TIMER2_X 
09C2    30CF01        6037     	JNB	TF2H, ($+4)		; Check if interrupt is pending
09C5    0A            6038     INC R2 
09C6    75C824        6039     	MOV	TMR2CN, #24H		; Timer2 enabled
09C9    D2AF          6040     	SETB	EA
                      6041     IF MCU_48MHZ == 1
09CB    C3            6042     	CLR	C
09CC    EA            6043     MOV A , R2 
09CD    13            6044     	RRC	A
09CE    FA            6045     MOV R2 , A 
09CF    E9            6046     MOV A , R1 
09D0    13            6047     	RRC	A
09D1    F9            6048     MOV R1 , A 
09D2    E8            6049     MOV A , R0 
09D3    13            6050     	RRC	A
09D4    F8            6051     MOV R0 , A 
                      6052     ENDIF
                      6053     	; Calculate this commutation time
09D5    AB3B          6054     MOV R3 , PREV_COMM_L 
09D7    AC3C          6055     MOV R4 , PREV_COMM_H 
09D9    883B          6056     MOV PREV_COMM_L , R0 
09DB    893C          6057     MOV PREV_COMM_H , R1 
09DD    C3            6058     	CLR	C
09DE    E8            6059     MOV A , R0 
09DF    9B            6060     SUBB A , R3 
09E0    F8            6061     MOV R0 , A 
09E1    E9            6062     MOV A , R1 
09E2    9C            6063     SUBB A , R4 
09E3    20690A        6064     JB FLAGS1 . 1 , CALC_NEXT_COMM_STARTUP 
                      6065     
                      6066     IF MCU_48MHZ == 1
09E6    547F          6067     	ANL	A, #7FH
                      6068     ENDIF
09E8    F9            6069     MOV R1 , A 
09E9    306602        6070     JNB FLAGS0 . 6 , ( $+5 ) 
09EC    41D4          6071     	AJMP	CALC_NEXT_COMM_TIMING_FAST
                      6072     
09EE    412E          6073     	AJMP	CALC_NEXT_COMM_NORMAL
                      6074     
                      6075     CALC_NEXT_COMM_STARTUP: 
09F0    AD3D          6076     MOV R5 , PREV_COMM_X 
09F2    8A3D          6077     MOV PREV_COMM_X , R2 
09F4    F9            6078     MOV R1 , A 
09F5    EA            6079     MOV A , R2 
09F6    9D            6080     SUBB A , R5 
                      6081     IF MCU_48MHZ == 1
09F7    547F          6082     	ANL	A, #7FH
                      6083     ENDIF
09F9    FA            6084     MOV R2 , A 
09FA    6004          6085     	JZ	($+6)
                      6086     
09FC    78FF          6087     MOV R0 , # 0FFH 
09FE    79FF          6088     MOV R1 , # 0FFH 
                      6089     
0A00    AE3E          6090     MOV R6 , PREV_PREV_COMM_L 
0A02    AF3F          6091     MOV R7 , PREV_PREV_COMM_H 
0A04    8B3E          6092     MOV PREV_PREV_COMM_L , R3 
0A06    8C3F          6093     MOV PREV_PREV_COMM_H , R4 
0A08    A83B          6094     MOV R0 , PREV_COMM_L 
0A0A    A93C          6095     MOV R1 , PREV_COMM_H 
0A0C    C3            6096     	CLR	C
0A0D    E8            6097     MOV A , R0 
0A0E    9E            6098     SUBB A , R6 
0A0F    F8            6099     MOV R0 , A 
0A10    E9            6100     MOV A , R1 
0A11    9F            6101     SUBB A , R7 
0A12    F9            6102     MOV R1 , A 
0A13    C3            6103     	CLR	C
0A14    E541          6104     	MOV	A, COMM_PERIOD4X_H		; Average with previous and save
0A16    13            6105     	RRC	A
0A17    FB            6106     MOV R3 , A 
0A18    E540          6107     	MOV	A, COMM_PERIOD4X_L
0A1A    13            6108     	RRC	A
0A1B    FA            6109     MOV R2 , A 
0A1C    E8            6110     MOV A , R0 
0A1D    2A            6111     ADD A , R2 
0A1E    F540          6112     	MOV	COMM_PERIOD4X_L, A
0A20    E9            6113     MOV A , R1 
0A21    3B            6114     ADDC A , R3 
0A22    F541          6115     	MOV	COMM_PERIOD4X_H, A
0A24    5006          6116     	JNC	($+8)
                      6117     
0A26    7540FF        6118     	MOV	COMM_PERIOD4X_L, #0FFH
0A29    7541FF        6119     	MOV	COMM_PERIOD4X_H, #0FFH
                      6120     
0A2C    417B          6121     	AJMP	CALC_NEW_WAIT_TIMES_SETUP
                      6122     
                      6123     CALC_NEXT_COMM_NORMAL: 
                      6124     	; Calculate new commutation time 
0A2E    AA40          6125     MOV R2 , COMM_PERIOD4X_L 
0A30    AB41          6126     MOV R3 , COMM_PERIOD4X_H 
0A32    AC40          6127     MOV R4 , COMM_PERIOD4X_L 
0A34    AD41          6128     MOV R5 , COMM_PERIOD4X_H 
0A36    7E04          6129     MOV R6 , # 4 
0A38    7F02          6130     MOV R7 , # 2 
0A3A    C3            6131     	CLR	C
0A3B    EB            6132     MOV A , R3 
0A3C    9404          6133     	SUBB	A, #04H
0A3E    400D          6134     	JC	CALC_NEXT_COMM_AVG_PERIOD_DIV
                      6135     
0A40    1E            6136     DEC R6 
0A41    1F            6137     DEC R7 
                      6138     
0A42    C3            6139     	CLR	C
0A43    EB            6140     MOV A , R3 
0A44    9408          6141     	SUBB	A, #08H
0A46    4005          6142     	JC	CALC_NEXT_COMM_AVG_PERIOD_DIV
                      6143     
0A48    206A02        6144     JB FLAGS1 . 2 , CALC_NEXT_COMM_AVG_PERIOD_DIV 
                      6145     
0A4B    1E            6146     DEC R6 
0A4C    1F            6147     DEC R7 
                      6148     
                      6149     CALC_NEXT_COMM_AVG_PERIOD_DIV: 
0A4D    C3            6150     	CLR	C
0A4E    ED            6151     MOV A , R5 
0A4F    13            6152     	RRC	A					; Divide by 2
0A50    FD            6153     MOV R5 , A 
0A51    EC            6154     MOV A , R4 
0A52    13            6155     	RRC	A
0A53    FC            6156     MOV R4 , A 
0A54    DEF7          6157     DJNZ R6 , CALC_NEXT_COMM_AVG_PERIOD_DIV 
                      6158     
0A56    C3            6159     	CLR	C
0A57    EA            6160     MOV A , R2 
0A58    9C            6161     SUBB A , R4 
0A59    FA            6162     MOV R2 , A 
0A5A    EB            6163     MOV A , R3 
0A5B    9D            6164     SUBB A , R5 
0A5C    FB            6165     MOV R3 , A 
0A5D    EF            6166     MOV A , R7 
0A5E    6009          6167     	JZ	CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE
                      6168     
                      6169     CALC_NEXT_COMM_NEW_PERIOD_DIV: 
0A60    C3            6170     	CLR	C
0A61    E9            6171     MOV A , R1 
0A62    13            6172     	RRC	A					; Divide by 2
0A63    F9            6173     MOV R1 , A 
0A64    E8            6174     MOV A , R0 
0A65    13            6175     	RRC	A
0A66    F8            6176     MOV R0 , A 
0A67    DFF7          6177     DJNZ R7 , CALC_NEXT_COMM_NEW_PERIOD_DIV 
                      6178     
                      6179     CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE: 
0A69    EA            6180     MOV A , R2 
0A6A    28            6181     ADD A , R0 
0A6B    FA            6182     MOV R2 , A 
0A6C    EB            6183     MOV A , R3 
0A6D    39            6184     ADDC A , R1 
0A6E    FB            6185     MOV R3 , A 
0A6F    8A40          6186     MOV COMM_PERIOD4X_L , R2 
0A71    8B41          6187     MOV COMM_PERIOD4X_H , R3 
0A73    5006          6188     	JNC	CALC_NEW_WAIT_TIMES_SETUP; If period larger than 0xffff - go to slow case
                      6189     
0A75    7BFF          6190     MOV R3 , # 0FFH 
0A77    8B40          6191     MOV COMM_PERIOD4X_L , R3 
0A79    8B41          6192     MOV COMM_PERIOD4X_H , R3 
                      6193     
                      6194     CALC_NEW_WAIT_TIMES_SETUP: 	
                      6195     	; Set high rpm bit (if above 156k erpm)
0A7B    C3            6196     	CLR	C
0A7C    EB            6197     MOV A , R3 
0A7D    9402          6198     	SUBB	A, #2
0A7F    5002          6199     	JNC	($+4)
                      6200     
0A81    D266          6201     SETB FLAGS0 . 6 
                      6202     	
                      6203     	; Load programmed commutation timing
0A83    306904        6204     JNB FLAGS1 . 1 , CALC_NEW_WAIT_PER_STARTUP_DONE 
                      6205     
0A86    7F03          6206     MOV R7 , # 3 
0A88    41A6          6207     	AJMP	CALC_NEW_WAIT_PER_DEMAG_DONE
                      6208     
                      6209     CALC_NEW_WAIT_PER_STARTUP_DONE: 
0A8A    7892          6210     MOV R0 , # PGM_COMM_TIMING 
0A8C    E6            6211     MOV A , @ R0 
0A8D    FF            6212     MOV R7 , A 
0A8E    C3            6213     	CLR	C
0A8F    E537          6214     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0A91    9482          6215     	SUBB	A, #130
0A93    4011          6216     	JC	CALC_NEW_WAIT_PER_DEMAG_DONE
                      6217     
0A95    0F            6218     INC R7 
                      6219     
0A96    C3            6220     	CLR	C
0A97    E537          6221     	MOV	A, DEMAG_DETECTED_METRIC
0A99    94A0          6222     	SUBB	A, #160
0A9B    4001          6223     	JC	($+3)
                      6224     
0A9D    0F            6225     INC R7 
                      6226     
0A9E    C3            6227     	CLR	C
0A9F    EF            6228     MOV A , R7 
0AA0    9406          6229     	SUBB	A, #6
0AA2    4002          6230     	JC	($+4)
                      6231     
0AA4    7F05          6232     MOV R7 , # 5 
                      6233     
                      6234     CALC_NEW_WAIT_PER_DEMAG_DONE: 
0AA6    7E02          6235     MOV R6 , # 2 
                      6236     	; Load current commutation timing
0AA8    E541          6237     	MOV	A, COMM_PERIOD4X_H		; Divide 4 times
0AAA    C4            6238     	SWAP	A
0AAB    540F          6239     	ANL	A, #00FH
0AAD    F9            6240     MOV R1 , A 
0AAE    E541          6241     	MOV	A, COMM_PERIOD4X_H
0AB0    C4            6242     	SWAP	A
0AB1    54F0          6243     	ANL	A, #0F0H
0AB3    F8            6244     MOV R0 , A 
0AB4    E540          6245     	MOV	A, COMM_PERIOD4X_L
0AB6    C4            6246     	SWAP	A
0AB7    540F          6247     	ANL	A, #00FH
0AB9    28            6248     ADD A , R0 
0ABA    F8            6249     MOV R0 , A 
                      6250     
0ABB    C3            6251     	CLR	C
0ABC    E8            6252     MOV A , R0 
0ABD    9E            6253     SUBB A , R6 
0ABE    FA            6254     MOV R2 , A 
0ABF    E9            6255     MOV A , R1 
0AC0    9400          6256     	SUBB	A, #0
0AC2    FB            6257     MOV R3 , A 
0AC3    4009          6258     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      6259     
0AC5    C3            6260     	CLR	C
0AC6    EA            6261     MOV A , R2 
0AC7    9402          6262     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0AC9    EB            6263     MOV A , R3 
0ACA    9400          6264     	SUBB	A, #0
0ACC    5004          6265     	JNC	CALC_NEW_WAIT_TIMES_EXIT	; Check that result is still above minumum
                      6266     
                      6267     LOAD_MIN_TIME: 
0ACE    7A02          6268     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0AD0    E4            6269     	CLR	A
0AD1    FB            6270     MOV R3 , A 
                      6271     
                      6272     CALC_NEW_WAIT_TIMES_EXIT: 	
0AD2    6120          6273     	AJMP	WAIT_ADVANCE_TIMING
                      6274     
                      6275     
                      6276     ; Fast calculation (Comm_Period4x_H less than 2)
                      6277     CALC_NEXT_COMM_TIMING_FAST: 			
                      6278     	; Calculate new commutation time
0AD4    AA40          6279     MOV R2 , COMM_PERIOD4X_L 
0AD6    AB41          6280     MOV R3 , COMM_PERIOD4X_H 
0AD8    EB            6281     MOV A , R3 
0AD9    C4            6282     	SWAP	A
0ADA    FE            6283     MOV R6 , A 
0ADB    EA            6284     MOV A , R2 
0ADC    C4            6285     	SWAP A
0ADD    540F          6286     	ANL	A, #0FH
0ADF    4E            6287     ORL A , R6 
0AE0    FC            6288     MOV R4 , A 
0AE1    C3            6289     	CLR	C
0AE2    EA            6290     MOV A , R2 
0AE3    9C            6291     SUBB A , R4 
0AE4    FA            6292     MOV R2 , A 
0AE5    EB            6293     MOV A , R3 
0AE6    9400          6294     	SUBB	A, #0
0AE8    FB            6295     MOV R3 , A 
0AE9    C3            6296     	CLR	C
0AEA    E8            6297     MOV A , R0 
0AEB    13            6298     	RRC	A					; Divide by 2 2 times
0AEC    C3            6299     	CLR	C
0AED    13            6300     	RRC	A
0AEE    F8            6301     MOV R0 , A 
0AEF    EA            6302     MOV A , R2 
0AF0    28            6303     ADD A , R0 
0AF1    FA            6304     MOV R2 , A 
0AF2    EB            6305     MOV A , R3 
0AF3    3400          6306     	ADDC	A, #0
0AF5    FB            6307     MOV R3 , A 
0AF6    8A40          6308     MOV COMM_PERIOD4X_L , R2 
0AF8    8B41          6309     MOV COMM_PERIOD4X_H , R3 
0AFA    C3            6310     	CLR	C
0AFB    EB            6311     MOV A , R3 
0AFC    9402          6312     	SUBB	A, #2
0AFE    4002          6313     	JC	($+4)
                      6314     
0B00    C266          6315     CLR FLAGS0 . 6 
                      6316     	
0B02    7802          6317     MOV R0 , # 2 
0B04    EB            6318     MOV A , R3 
0B05    C4            6319     	SWAP	A
0B06    FE            6320     MOV R6 , A 
0B07    7B00          6321     MOV R3 , # 0 
0B09    EA            6322     MOV A , R2 
0B0A    C4            6323     	SWAP A
0B0B    540F          6324     	ANL	A, #0FH
0B0D    4E            6325     ORL A , R6 
0B0E    FA            6326     MOV R2 , A 
0B0F    C3            6327     	CLR	C
0B10    EA            6328     MOV A , R2 
0B11    98            6329     SUBB A , R0 
0B12    FA            6330     MOV R2 , A 
0B13    4005          6331     	JC	LOAD_MIN_TIME_FAST		; Check that result is still positive
                      6332     
0B15    C3            6333     	CLR	C
0B16    9402          6334     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0B18    5002          6335     	JNC	CALC_NEW_WAIT_TIMES_FAST_DONE	; Check that result is still above minumum
                      6336     
                      6337     LOAD_MIN_TIME_FAST: 
0B1A    7A02          6338     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
                      6339     
                      6340     CALC_NEW_WAIT_TIMES_FAST_DONE: 	
0B1C    7892          6341     MOV R0 , # PGM_COMM_TIMING 
0B1E    E6            6342     MOV A , @ R0 
0B1F    FF            6343     MOV R7 , A 
                      6344     
                      6345     
                      6346     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6347     ;
                      6348     ; Wait advance timing routine
                      6349     ;
                      6350     ; No assumptions
                      6351     ; NOTE: Be VERY careful if using temp registers. They are passed over this routine
                      6352     ;
                      6353     ; Waits for the advance timing to elapse and sets up the next zero cross wait
                      6354     ;
                      6355     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6356     WAIT_ADVANCE_TIMING: 	
0B20    306002        6357     JNB FLAGS0 . 0 , ( $+5 ) 
0B23    6120          6358     	AJMP	WAIT_ADVANCE_TIMING
                      6359     
                      6360     	; Setup next wait time
0B25    855192        6361     	MOV	TMR3RLL, WT_ZC_TOUT_START_L
0B28    855293        6362     	MOV	TMR3RLH, WT_ZC_TOUT_START_H
0B2B    D260          6363     SETB FLAGS0 . 0 
0B2D    43E680        6364     	ORL	EIE1, #80H	; Enable timer3 interrupts
                      6365     
                      6366     
                      6367     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6368     ;
                      6369     ; Calculate new wait times routine
                      6370     ;
                      6371     ; No assumptions
                      6372     ;
                      6373     ; Calculates new wait times
                      6374     ;
                      6375     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6376     CALC_NEW_WAIT_TIMES: 	
0B30    C3            6377     	CLR	C
0B31    E4            6378     	CLR	A
0B32    9A            6379     SUBB A , R2 
0B33    F8            6380     MOV R0 , A 
0B34    E4            6381     	CLR	A
0B35    9B            6382     SUBB A , R3 
0B36    F9            6383     MOV R1 , A 
                      6384     IF MCU_48MHZ == 1
0B37    C3            6385     	CLR	C
0B38    E8            6386     MOV A , R0 
0B39    33            6387     	RLC	A
0B3A    F8            6388     MOV R0 , A 
0B3B    E9            6389     MOV A , R1 
0B3C    33            6390     	RLC	A
0B3D    F9            6391     MOV R1 , A 
                      6392     ENDIF
0B3E    306602        6393     JNB FLAGS0 . 6 , ( $+5 ) 
0B41    61B3          6394     	AJMP	CALC_NEW_WAIT_TIMES_FAST
                      6395     
0B43    E8            6396     MOV A , R0 
0B44    FA            6397     MOV R2 , A 
0B45    E9            6398     MOV A , R1 
0B46    FB            6399     MOV R3 , A 
0B47    D3            6400     	SETB	C					; Negative numbers - set carry
0B48    E9            6401     MOV A , R1 
0B49    13            6402     	RRC	A					; Divide by 2
0B4A    FD            6403     MOV R5 , A 
0B4B    E8            6404     MOV A , R0 
0B4C    13            6405     	RRC	A
0B4D    FC            6406     MOV R4 , A 
0B4E    8851          6407     MOV WT_ZC_TOUT_START_L , R0 
0B50    8952          6408     MOV WT_ZC_TOUT_START_H , R1 
0B52    C3            6409     	CLR	C
0B53    EF            6410     MOV A , R7 
0B54    9403          6411     	SUBB	A, #3				; Is timing normal?
0B56    6038          6412     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      6413     
0B58    EF            6414     MOV A , R7 
0B59    20E00D        6415     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      6416     
0B5C    E8            6417     MOV A , R0 
0B5D    2C            6418     ADD A , R4 
0B5E    F8            6419     MOV R0 , A 
0B5F    E9            6420     MOV A , R1 
0B60    3D            6421     ADDC A , R5 
0B61    F9            6422     MOV R1 , A 
0B62    EC            6423     MOV A , R4 
0B63    FA            6424     MOV R2 , A 
0B64    ED            6425     MOV A , R5 
0B65    FB            6426     MOV R3 , A 
0B66    020B7C        6427     	JMP	STORE_TIMES_UP_OR_DOWN
                      6428     
                      6429     ADJUST_TIMING_TWO_STEPS: 
0B69    E8            6430     MOV A , R0 
0B6A    28            6431     ADD A , R0 
0B6B    F8            6432     MOV R0 , A 
0B6C    E9            6433     MOV A , R1 
0B6D    39            6434     ADDC A , R1 
0B6E    F9            6435     MOV R1 , A 
0B6F    C3            6436     	CLR	C
0B70    E8            6437     MOV A , R0 
0B71    2402          6438     	ADD	A, #(COMM_TIME_MIN SHL 1)
0B73    F8            6439     MOV R0 , A 
0B74    E9            6440     MOV A , R1 
0B75    3400          6441     	ADDC	A, #0
0B77    F9            6442     MOV R1 , A 
0B78    7AFE          6443     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
0B7A    7BFF          6444     MOV R3 , # 0FFH 
                      6445     
                      6446     STORE_TIMES_UP_OR_DOWN: 
0B7C    C3            6447     	CLR	C
0B7D    EF            6448     MOV A , R7 
0B7E    9403          6449     	SUBB	A, #3					; Is timing higher than normal?
0B80    400E          6450     	JC	STORE_TIMES_DECREASE		; No - branch
                      6451     
                      6452     STORE_TIMES_INCREASE: 
0B82    8A53          6453     MOV WT_COMM_START_L , R2 
0B84    8B54          6454     MOV WT_COMM_START_H , R3 
0B86    884D          6455     MOV WT_ADV_START_L , R0 
0B88    894E          6456     MOV WT_ADV_START_H , R1 
0B8A    8C4F          6457     MOV WT_ZC_SCAN_START_L , R4 
0B8C    8D50          6458     MOV WT_ZC_SCAN_START_H , R5 
0B8E    61E7          6459     	AJMP	WAIT_BEFORE_ZC_SCAN
                      6460     
                      6461     STORE_TIMES_DECREASE: 
0B90    8853          6462     MOV WT_COMM_START_L , R0 
0B92    8954          6463     MOV WT_COMM_START_H , R1 
0B94    8A4D          6464     MOV WT_ADV_START_L , R2 
0B96    8B4E          6465     MOV WT_ADV_START_H , R3 
0B98    8C4F          6466     MOV WT_ZC_SCAN_START_L , R4 
0B9A    8D50          6467     MOV WT_ZC_SCAN_START_H , R5 
0B9C    306912        6468     JNB FLAGS1 . 1 , STORE_TIMES_EXIT 
                      6469     
0B9F    7553F0        6470     	MOV	WT_COMM_START_L, #0F0H		; Set very short delays for all but advance time during startup, in order to widen zero cross capture range
0BA2    7554FF        6471     	MOV	WT_COMM_START_H, #0FFH
0BA5    754FF0        6472     	MOV	WT_ZC_SCAN_START_L, #0F0H
0BA8    7550FF        6473     	MOV	WT_ZC_SCAN_START_H, #0FFH
0BAB    7551F0        6474     	MOV	WT_ZC_TOUT_START_L, #0F0H
0BAE    7552FF        6475     	MOV	WT_ZC_TOUT_START_H, #0FFH
                      6476     
                      6477     STORE_TIMES_EXIT: 
0BB1    61E7          6478     	AJMP	WAIT_BEFORE_ZC_SCAN
                      6479     
                      6480     
                      6481     CALC_NEW_WAIT_TIMES_FAST: 	
0BB3    E8            6482     MOV A , R0 
0BB4    FA            6483     MOV R2 , A 
0BB5    D3            6484     	SETB	C					; Negative numbers - set carry
0BB6    E8            6485     MOV A , R0 
0BB7    13            6486     	RRC	A
0BB8    FC            6487     MOV R4 , A 
0BB9    8851          6488     MOV WT_ZC_TOUT_START_L , R0 
0BBB    C3            6489     	CLR	C
0BBC    EF            6490     MOV A , R7 
0BBD    9403          6491     	SUBB	A, #3				; Is timing normal?
0BBF    6020          6492     	JZ	STORE_TIMES_DECREASE_FAST; Yes - branch
                      6493     
0BC1    EF            6494     MOV A , R7 
0BC2    20E007        6495     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS_FAST	; If an odd number - branch
                      6496     
0BC5    E8            6497     MOV A , R0 
0BC6    2C            6498     ADD A , R4 
0BC7    F8            6499     MOV R0 , A 
0BC8    EC            6500     MOV A , R4 
0BC9    FA            6501     MOV R2 , A 
0BCA    61D3          6502     	AJMP	STORE_TIMES_UP_OR_DOWN_FAST
                      6503     
                      6504     ADJUST_TIMING_TWO_STEPS_FAST: 
0BCC    E8            6505     MOV A , R0 
0BCD    28            6506     ADD A , R0 
0BCE    2402          6507     	ADD	A, #(COMM_TIME_MIN SHL 1)
0BD0    F8            6508     MOV R0 , A 
0BD1    7AFE          6509     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
                      6510     
                      6511     STORE_TIMES_UP_OR_DOWN_FAST: 
0BD3    C3            6512     	CLR	C
0BD4    EF            6513     MOV A , R7 
0BD5    9403          6514     	SUBB	A, #3				; Is timing higher than normal?
0BD7    4008          6515     	JC	STORE_TIMES_DECREASE_FAST; No - branch
                      6516     
                      6517     STORE_TIMES_INCREASE_FAST: 
0BD9    8A53          6518     MOV WT_COMM_START_L , R2 
0BDB    884D          6519     MOV WT_ADV_START_L , R0 
0BDD    8C4F          6520     MOV WT_ZC_SCAN_START_L , R4 
0BDF    61E7          6521     	AJMP	WAIT_BEFORE_ZC_SCAN
                      6522     
                      6523     STORE_TIMES_DECREASE_FAST: 
0BE1    8853          6524     MOV WT_COMM_START_L , R0 
0BE3    8A4D          6525     MOV WT_ADV_START_L , R2 
0BE5    8C4F          6526     MOV WT_ZC_SCAN_START_L , R4 
                      6527     
                      6528     
                      6529     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6530     ;
                      6531     ; Wait before zero cross scan routine
                      6532     ;
                      6533     ; No assumptions
                      6534     ;
                      6535     ; Waits for the zero cross scan wait time to elapse
                      6536     ; Also sets up timer 3 for the zero cross scan timeout time
                      6537     ;
                      6538     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6539     WAIT_BEFORE_ZC_SCAN: 	
                      6540     	; Calculate random number
0BE7    E568          6541     	MOV	A, RANDOM
0BE9    C3            6542     	CLR	C
0BEA    33            6543     	RLC	A
0BEB    5002          6544     	JNC	WAIT_BEFORE_ZC_SCAN_RAND
                      6545     
0BED    646B          6546     	XRL	A, #06BH		; Sequence length of 35, when initialized to 1
                      6547     
                      6548     WAIT_BEFORE_ZC_SCAN_RAND:           
0BEF    F568          6549     	MOV	RANDOM, A
                      6550     
                      6551     WAIT_BEFORE_ZC_SCAN_WAIT:           
0BF1    306002        6552     JNB FLAGS0 . 0 , ( $+5 ) 
0BF4    61F1          6553     	AJMP	WAIT_BEFORE_ZC_SCAN_WAIT
                      6554     
0BF6    753402        6555     	MOV	STARTUP_ZC_TIMEOUT_CNTD, #2
                      6556     SETUP_ZC_SCAN_TIMEOUT: 
0BF9    D260          6557     SETB FLAGS0 . 0 
0BFB    43E680        6558     	ORL	EIE1, #80H			; Enable timer3 interrupts
0BFE    E52D          6559     	MOV	A, FLAGS1
0C00    5406          6560     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0C02    602D          6561     	JZ	WAIT_BEFORE_ZC_SCAN_EXIT		
                      6562     
0C04    A840          6563     MOV R0 , COMM_PERIOD4X_L 
0C06    A941          6564     MOV R1 , COMM_PERIOD4X_H 
0C08    C3            6565     	CLR	C
0C09    E9            6566     MOV A , R1 
0C0A    13            6567     	RRC	A
0C0B    F9            6568     MOV R1 , A 
0C0C    E8            6569     MOV A , R0 
0C0D    13            6570     	RRC	A
0C0E    F8            6571     MOV R0 , A 
                      6572     IF MCU_48MHZ == 0
                               	CLR	C
                               	MOV	A, TEMP2
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	RRC	A
                               	MOV	TEMP1, A
                               ENDIF
0C0F    306904        6581     JNB FLAGS1 . 1 , SETUP_ZC_SCAN_TIMEOUT_STARTUP_DONE 
                      6582     	
0C12    E9            6583     MOV A , R1 
0C13    2440          6584     	ADD	A, #40H				; Increase timeout somewhat to avoid false wind up
0C15    F9            6585     MOV R1 , A 
                      6586     
                      6587     SETUP_ZC_SCAN_TIMEOUT_STARTUP_DONE: 
0C16    C2AF          6588     	CLR	EA
0C18    53E67F        6589     	ANL	EIE1, #7FH			; Disable timer3 interrupts
0C1B    759100        6590     	MOV	TMR3CN, #00H			; Timer3 disabled and interrupt flag cleared
0C1E    C3            6591     	CLR	C
0C1F    E4            6592     	CLR	A
0C20    98            6593     SUBB A , R0 
0C21    F594          6594     	MOV	TMR3L, A
0C23    E4            6595     	CLR	A
0C24    99            6596     SUBB A , R1 
0C25    F595          6597     	MOV	TMR3H, A
0C27    759104        6598     	MOV	TMR3CN, #04H			; Timer3 enabled and interrupt flag cleared
0C2A    D260          6599     SETB FLAGS0 . 0 
0C2C    43E680        6600     	ORL	EIE1, #80H			; Enable timer3 interrupts
0C2F    D2AF          6601     	SETB	EA
                      6602     
                      6603     WAIT_BEFORE_ZC_SCAN_EXIT:           
0C31    22            6604     	RET
                      6605     
                      6606     
                      6607     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6608     ;
                      6609     ; Wait for comparator to go low/high routines
                      6610     ;
                      6611     ; No assumptions
                      6612     ;
                      6613     ; Waits for the zero cross scan wait time to elapse
                      6614     ; Then scans for comparator going low/high
                      6615     ;
                      6616     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6617     WAIT_FOR_COMP_OUT_LOW: 
0C32    D264          6618     SETB FLAGS0 . 4 
0C34    754300        6619     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0C37    752000        6620     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0C3A    306C03        6621     JNB FLAGS1 . 4 , ( $+6 ) 
0C3D    752040        6622     	MOV	BIT_ACCESS, #40H		
0C40    020C51        6623     	JMP	WAIT_FOR_COMP_OUT_START
                      6624     
                      6625     WAIT_FOR_COMP_OUT_HIGH: 
0C43    D264          6626     SETB FLAGS0 . 4 
0C45    754300        6627     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0C48    752040        6628     	MOV	BIT_ACCESS, #40H			; Desired comparator output
0C4B    306C03        6629     JNB FLAGS1 . 4 , ( $+6 ) 
0C4E    752000        6630     	MOV	BIT_ACCESS, #00H		
                      6631     
                      6632     WAIT_FOR_COMP_OUT_START: 
                      6633     	; Set number of comparator readings
0C51    7801          6634     MOV R0 , # 1 
0C53    7901          6635     MOV R1 , # 1 
0C55    206620        6636     JB FLAGS0 . 6 , COMP_SCALE_SAMPLES 
                      6637     
0C58    E52D          6638     	MOV	A, FLAGS1					; Clear demag detected flag if start phases
0C5A    5406          6639     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0C5C    6002          6640     	JZ	($+4)
                      6641     		
0C5E    C264          6642     CLR FLAGS0 . 4 
                      6643     
0C60    7914          6644     MOV R1 , # 20 
0C62    E541          6645     	MOV 	A, COMM_PERIOD4X_H			; Set number of readings higher for lower speeds	
0C64    C3            6646     	CLR	C
0C65    13            6647     	RRC	A
0C66    7001          6648     	JNZ	($+3)
0C68    04            6649     	INC	A
0C69    F8            6650     MOV R0 , A 
0C6A    C3            6651     	CLR	C						
0C6B    9414          6652     	SUBB	A, #20			
0C6D    4002          6653     	JC	($+4)
                      6654     
0C6F    7814          6655     MOV R0 , # 20 
                      6656     	
0C71    306904        6657     JNB FLAGS1 . 1 , COMP_SCALE_SAMPLES 
                      6658     
0C74    781B          6659     MOV R0 , # 27 
0C76    791B          6660     MOV R1 , # 27 
                      6661     
                      6662     COMP_SCALE_SAMPLES: 
                      6663     IF MCU_48MHZ == 1
0C78    C3            6664     	CLR	C
0C79    E8            6665     MOV A , R0 
0C7A    33            6666     	RLC	A
0C7B    F8            6667     MOV R0 , A 
0C7C    C3            6668     	CLR	C
0C7D    E9            6669     MOV A , R1 
0C7E    33            6670     	RLC	A
0C7F    F9            6671     MOV R1 , A 
                      6672     ENDIF
                      6673     
                      6674     COMP_CHECK_TIMEOUT: 
0C80    206010        6675     JB FLAGS0 . 0 , COMP_CHECK_TIMEOUT_NOT_TIMED_OUT 
                      6676     
0C83    E543          6677     	MOV	A, COMPARATOR_READ_CNT				; Check that comparator has been read
0C85    600C          6678     	JZ	COMP_CHECK_TIMEOUT_NOT_TIMED_OUT		; If not read - branch
                      6679     
0C87    306903        6680     JNB FLAGS1 . 1 , COMP_CHECK_TIMEOUT_TIMEOUT_EXTENDED 
                      6681     
0C8A    D53404        6682     	DJNZ	STARTUP_ZC_TIMEOUT_CNTD, COMP_CHECK_TIMEOUT_EXTEND_TIMEOUT
                      6683     
                      6684     COMP_CHECK_TIMEOUT_TIMEOUT_EXTENDED: 
0C8D    D26D          6685     SETB FLAGS1 . 5 
0C8F    A107          6686     	AJMP	SETUP_COMM_WAIT
                      6687     
                      6688     COMP_CHECK_TIMEOUT_EXTEND_TIMEOUT: 
0C91    71F9          6689     	CALL	SETUP_ZC_SCAN_TIMEOUT
                      6690     COMP_CHECK_TIMEOUT_NOT_TIMED_OUT: 
0C93    0543          6691     	INC	COMPARATOR_READ_CNT			; Increment comparator read count
                      6692     	READ_COMP_OUT					; Read comparator output
0C95    E59B          6692+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0C97    5440          6693     	ANL	A, #40H
0C99    B52002        6694     	CJNE	A, BIT_ACCESS, COMP_READ_WRONG
0C9C    81F1          6695     	AJMP	COMP_READ_OK
                      6696     	
                      6697     COMP_READ_WRONG: 
0C9E    306909        6698     JNB FLAGS1 . 1 , COMP_READ_WRONG_NOT_STARTUP 
                      6699     
0CA1    08            6700     INC R0 
0CA2    C3            6701     	CLR	C
0CA3    E8            6702     MOV A , R0 
0CA4    99            6703     SUBB A , R1 
0CA5    4001          6704     	JC	($+3)
0CA7    18            6705     DEC R0 
                      6706     
0CA8    8180          6707     	AJMP	COMP_CHECK_TIMEOUT			; Continue to look for good ones
                      6708     
                      6709     COMP_READ_WRONG_NOT_STARTUP: 
0CAA    20640A        6710     JB FLAGS0 . 4 , COMP_READ_WRONG_EXTEND_TIMEOUT 
                      6711     
0CAD    08            6712     INC R0 
0CAE    C3            6713     	CLR	C
0CAF    E8            6714     MOV A , R0 
0CB0    99            6715     SUBB A , R1 
0CB1    4002          6716     	JC	($+4)
0CB3    8151          6717     	AJMP	WAIT_FOR_COMP_OUT_START		; If above initial requirement - go back and restart
                      6718     
0CB5    8180          6719     	AJMP	COMP_CHECK_TIMEOUT			; Otherwise - take another reading
                      6720     
                      6721     COMP_READ_WRONG_EXTEND_TIMEOUT: 
0CB7    C264          6722     CLR FLAGS0 . 4 
0CB9    C2AF          6723     	CLR	EA
0CBB    53E67F        6724     	ANL	EIE1, #7FH				; Disable timer3 interrupts
0CBE    759100        6725     	MOV	TMR3CN, #00H				; Timer3 disabled and interrupt flag cleared
0CC1    306612        6726     JNB FLAGS0 . 6 , COMP_READ_WRONG_LOW_RPM 
                      6727     
0CC4    759400        6728     	MOV	TMR3L, #00H				; Set timeout to ~1ms
                      6729     IF MCU_48MHZ == 1
0CC7    7595F0        6730     	MOV	TMR3H, #0F0H
                      6731     ELSE
                               	MOV	TMR3H, #0F8H
                               ENDIF
                      6734     COMP_READ_WRONG_TIMEOUT_SET: 
0CCA    759104        6735     	MOV	TMR3CN, #04H				; Timer3 enabled and interrupt flag cleared
0CCD    D260          6736     SETB FLAGS0 . 0 
0CCF    43E680        6737     	ORL	EIE1, #80H				; Enable timer3 interrupts
0CD2    D2AF          6738     	SETB	EA
0CD4    8151          6739     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      6740     
                      6741     COMP_READ_WRONG_LOW_RPM: 
0CD6    E541          6742     	MOV	A, COMM_PERIOD4X_H			; Set timeout to ~4x comm period 4x value
0CD8    7EFF          6743     MOV R6 , # 0FFH 
                      6744     IF MCU_48MHZ == 1
0CDA    C3            6745     	CLR	C
0CDB    33            6746     	RLC	A
0CDC    4009          6747     	JC	COMP_READ_WRONG_LOAD_TIMEOUT
                      6748     
                      6749     ENDIF
0CDE    C3            6750     	CLR	C
0CDF    33            6751     	RLC	A
0CE0    4005          6752     	JC	COMP_READ_WRONG_LOAD_TIMEOUT
                      6753     
0CE2    C3            6754     	CLR	C
0CE3    33            6755     	RLC	A
0CE4    4001          6756     	JC	COMP_READ_WRONG_LOAD_TIMEOUT
                      6757     
0CE6    FE            6758     MOV R6 , A 
                      6759     
                      6760     COMP_READ_WRONG_LOAD_TIMEOUT: 
0CE7    C3            6761     	CLR	C
0CE8    E4            6762     	CLR	A
0CE9    9E            6763     SUBB A , R6 
0CEA    759400        6764     	MOV	TMR3L, #0
0CED    F595          6765     	MOV	TMR3H, A
0CEF    81CA          6766     	AJMP	COMP_READ_WRONG_TIMEOUT_SET
                      6767     
                      6768     COMP_READ_OK: 
0CF1    C3            6769     	CLR	C
0CF2    E533          6770     	MOV	A, STARTUP_CNT				; Force a timeout for the first commutation		
0CF4    9401          6771     	SUBB	A, #1
0CF6    5002          6772     	JNC	($+4)
0CF8    8151          6773     	AJMP	WAIT_FOR_COMP_OUT_START
                      6774     
0CFA    306402        6775     JNB FLAGS0 . 4 , ( $+5 ) 
0CFD    8151          6776     	AJMP	WAIT_FOR_COMP_OUT_START
                      6777     
0CFF    D802          6778     DJNZ R0 , COMP_READ_OK_JMP 
0D01    A105          6779     	AJMP	($+4)
                      6780     
                      6781     COMP_READ_OK_JMP: 
0D03    8180          6782     	AJMP	COMP_CHECK_TIMEOUT	
                      6783     
0D05    C26D          6784     CLR FLAGS1 . 5 
                      6785     
                      6786     
                      6787     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6788     ;
                      6789     ; Setup commutation timing routine
                      6790     ;
                      6791     ; No assumptions
                      6792     ;
                      6793     ; Sets up and starts wait from commutation to zero cross
                      6794     ;
                      6795     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6796     SETUP_COMM_WAIT:  
0D07    C2AF          6797     	CLR	EA
0D09    53E67F        6798     	ANL	EIE1, #7FH		; Disable timer3 interrupts
0D0C    759100        6799     	MOV	TMR3CN, #00H		; Timer3 disabled and interrupt flag cleared
0D0F    855394        6800     	MOV	TMR3L, WT_COMM_START_L
0D12    855495        6801     	MOV	TMR3H, WT_COMM_START_H
0D15    759104        6802     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
                      6803     	; Setup next wait time
0D18    854D92        6804     	MOV	TMR3RLL, WT_ADV_START_L
0D1B    854E93        6805     	MOV	TMR3RLH, WT_ADV_START_H
0D1E    D260          6806     SETB FLAGS0 . 0 
0D20    43E680        6807     	ORL	EIE1, #80H		; Enable timer3 interrupts
0D23    D2AF          6808     	SETB	EA				; Enable interrupts again
                      6809     
                      6810     
                      6811     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6812     ;
                      6813     ; Evaluate comparator integrity
                      6814     ;
                      6815     ; No assumptions
                      6816     ;
                      6817     ; Checks comparator signal behaviour versus expected behaviour
                      6818     ;
                      6819     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6820     EVALUATE_COMPARATOR_INTEGRITY: 
0D25    E52D          6821     	MOV	A, FLAGS1
0D27    5406          6822     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0D29    6008          6823     	JZ	EVAL_COMP_CHECK_TIMEOUT
                      6824     
0D2B    206A02        6825     JB FLAGS1 . 2 , ( $+5 ) 
0D2E    0533          6826     	INC	STARTUP_CNT					; Increment counter
0D30    020D43        6827     	JMP	EVAL_COMP_EXIT
                      6828     
                      6829     EVAL_COMP_CHECK_TIMEOUT: 
0D33    306D0D        6830     JNB FLAGS1 . 5 , EVAL_COMP_EXIT 
0D36    206C0A        6831     JB FLAGS1 . 4 , EVAL_COMP_EXIT 
0D39    206407        6832     JB FLAGS0 . 4 , EVAL_COMP_EXIT 
0D3C    1581          6833     	DEC	SP								; Routine exit without "ret" command
0D3E    1581          6834     	DEC	SP
0D40    0215EE        6835     	LJMP	RUN_TO_WAIT_FOR_POWER_ON_FAIL			; Yes - exit run mode
                      6836     
                      6837     EVAL_COMP_EXIT: 
0D43    22            6838     	RET
                      6839     
                      6840     
                      6841     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6842     ;
                      6843     ; Wait for commutation routine
                      6844     ;
                      6845     ; No assumptions
                      6846     ;
                      6847     ; Waits from zero cross to commutation 
                      6848     ;
                      6849     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6850     WAIT_FOR_COMM:  
                      6851     	; Update demag metric
0D44    7800          6852     MOV R0 , # 0 
0D46    306402        6853     JNB FLAGS0 . 4 , ( $+5 ) 
                      6854     
0D49    7801          6855     MOV R0 , # 1 
                      6856     
0D4B    E537          6857     	MOV	A, DEMAG_DETECTED_METRIC	; Sliding average of 8, 256 when demag and 0 when not. Limited to minimum 120
0D4D    75F007        6858     	MOV	B, #7
0D50    A4            6859     	MUL	AB					; Multiply by 7
0D51    F9            6860     MOV R1 , A 
0D52    E5F0          6861     	MOV	A, B					; Add new value for current demag status
0D54    28            6862     ADD A , R0 
0D55    F5F0          6863     	MOV	B, A
0D57    E9            6864     MOV A , R1 
0D58    A2F0          6865     	MOV	C, B.0				; Divide by 8
0D5A    13            6866     	RRC	A					
0D5B    A2F1          6867     	MOV	C, B.1
0D5D    13            6868     	RRC	A
0D5E    A2F2          6869     	MOV	C, B.2
0D60    13            6870     	RRC	A
0D61    F537          6871     	MOV	DEMAG_DETECTED_METRIC, A
0D63    C3            6872     	CLR	C
0D64    9478          6873     	SUBB	A, #120				; Limit to minimum 120
0D66    5003          6874     	JNC	($+5)
                      6875     
0D68    753778        6876     	MOV	DEMAG_DETECTED_METRIC, #120
                      6877     
0D6B    C3            6878     	CLR	C
0D6C    E537          6879     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0D6E    9538          6880     	SUBB	A, DEMAG_PWR_OFF_THRESH
0D70    4008          6881     	JC	WAIT_FOR_COMM_WAIT		; Cut power if many consecutive demags. This will help retain sync during hard accelerations
                      6882     
0D72    D265          6883     SETB FLAGS0 . 5 
                      6884     IF NFETON_DELAY NE 0
                      6885     	ALL_NFETS_OFF
0D74    C295          6885+1   CLR P1 . 5 
0D76    C293          6885+1   CLR P1 . 3 
0D78    C297          6885+1   CLR P1 . 7 
                      6886     ELSE
                               	EN_OFF					; For EN/PWM style drivers
                               ENDIF
                      6889     
                      6890     WAIT_FOR_COMM_WAIT: 
0D7A    306002        6891     JNB FLAGS0 . 0 , ( $+5 ) 
0D7D    A17A          6892     	AJMP	WAIT_FOR_COMM_WAIT					
                      6893     
                      6894     	; Setup next wait time
0D7F    854F92        6895     	MOV	TMR3RLL, WT_ZC_SCAN_START_L
0D82    855093        6896     	MOV	TMR3RLH, WT_ZC_SCAN_START_H
0D85    D260          6897     SETB FLAGS0 . 0 
0D87    43E680        6898     	ORL	EIE1, #80H			; Enable timer3 interrupts
0D8A    22            6899     	RET
                      6900     
                      6901     
                      6902     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6903     ;
                      6904     ; Commutation routines
                      6905     ;
                      6906     ; No assumptions
                      6907     ;
                      6908     ; Performs commutation switching 
                      6909     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      6910     ;
                      6911     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6912     ; Comm phase 1 to comm phase 2
                      6913     COMM1COMM2: 	
                      6914     	SET_RPM_OUT
0D8B    207D16        6915     JB FLAGS3 . 5 , COMM12_REV 
                      6916     
0D8E    C2AF          6917     	CLR 	EA					; Disable all interrupts
0D90    754202        6918     	MOV	COMM_PHASE, #2
                      6919     	BPFET_OFF 				; Turn off pfet
0D93    C296          6919+1   CLR P1 . 6 
                      6920     	APFET_ON					; Turn on pfet
0D95    D294          6920+1   SETB P1 . 4 
0D97    306202        6921     JNB FLAGS0 . 2 , COMM12_NFET_DONE 
                      6922     	CNFET_ON					; Pwm on - turn on nfet
0D9A    D293          6922+1   SETB P1 . 3 
                      6923     COMM12_NFET_DONE: 
0D9C    D2AF          6924     	SETB	EA
                      6925     	SET_COMP_PHASE_B 			; Set comparator phase
0D9E    759F11        6925+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0DA1    020F7A        6926     	JMP	COMM_EXIT
                      6927     
                      6928     COMM12_REV: 	
0DA4    C2AF          6929     	CLR 	EA					; Disable all interrupts
0DA6    754202        6930     	MOV	COMM_PHASE, #2
                      6931     	BPFET_OFF 				; Turn off pfet
0DA9    C296          6931+1   CLR P1 . 6 
                      6932     	CPFET_ON					; Turn on pfet (reverse)
0DAB    D292          6932+1   SETB P1 . 2 
0DAD    306202        6933     JNB FLAGS0 . 2 , COMM12_NFET_DONE_REV 
                      6934     	ANFET_ON					; Pwm on - turn on nfet
0DB0    D295          6934+1   SETB P1 . 5 
                      6935     COMM12_NFET_DONE_REV: 
0DB2    D2AF          6936     	SETB	EA
                      6937     	SET_COMP_PHASE_B 			; Set comparator phase
0DB4    759F11        6937+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0DB7    020F7A        6938     	JMP	COMM_EXIT
                      6939     
                      6940     
                      6941     ; Comm phase 2 to comm phase 3
                      6942     COMM2COMM3: 	
                      6943     	CLEAR_RPM_OUT
0DBA    307243        6944     JNB FLAGS2 . 2 , COMM23_NONDAMP 
                      6945     
                      6946     	; Comm2Comm3 Damped
0DBD    207D20        6947     JB FLAGS3 . 5 , COMM23_DAMP_REV 
                      6948     
0DC0    C2AF          6949     	CLR 	EA					; Disable all interrupts
0DC2    754203        6950     	MOV	COMM_PHASE, #3
0DC5    900165        6951     	MOV	DPTR, #PWM_BFET_DAMPED	
0DC8    757B40        6952     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6953     	CNFET_OFF					; Turn off fets
0DCB    C293          6953+1   CLR P1 . 3 
                      6954     	CPFET_OFF						
0DCD    C292          6954+1   CLR P1 . 2 
0DCF    306204        6955     JNB FLAGS0 . 2 , COMM23_NFET_OFF 
                      6956     	BNFET_ON					; Pwm on - turn on nfet
0DD2    D297          6956+1   SETB P1 . 7 
0DD4    A1D8          6957     	AJMP	COMM23_FETS_DONE
                      6958     COMM23_NFET_OFF: 
                      6959     	BPFET_ON					; Pwm off - switch damping fets	
0DD6    D296          6959+1   SETB P1 . 6 
                      6960     COMM23_FETS_DONE: 
0DD8    D2AF          6961     	SETB	EA
                      6962     	SET_COMP_PHASE_C 			; Set comparator phase
0DDA    759F13        6962+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0DDD    020F7A        6963     	LJMP	COMM_EXIT
                      6964     
                      6965     	; Comm2Comm3 Damped reverse
                      6966     COMM23_DAMP_REV: 
0DE0    C2AF          6967     	CLR 	EA					; Disable all interrupts
0DE2    754203        6968     	MOV	COMM_PHASE, #3
0DE5    900165        6969     	MOV	DPTR, #PWM_BFET_DAMPED	
0DE8    757B40        6970     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6971     	ANFET_OFF					; Turn off fets (reverse)
0DEB    C295          6971+1   CLR P1 . 5 
                      6972     	APFET_OFF						
0DED    C294          6972+1   CLR P1 . 4 
0DEF    306204        6973     JNB FLAGS0 . 2 , COMM23_NFET_OFF_REV 
                      6974     	BNFET_ON					; Pwm on - turn on nfet
0DF2    D297          6974+1   SETB P1 . 7 
0DF4    A1F8          6975     	AJMP	COMM23_FETS_DONE_REV
                      6976     COMM23_NFET_OFF_REV: 
                      6977     	BPFET_ON					; Pwm off - switch damping fets	
0DF6    D296          6977+1   SETB P1 . 6 
                      6978     COMM23_FETS_DONE_REV: 
0DF8    D2AF          6979     	SETB	EA
                      6980     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0DFA    759F10        6980+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0DFD    020F7A        6981     	LJMP	COMM_EXIT
                      6982     
                      6983     	; Comm2Comm3 Non-damped
                      6984     COMM23_NONDAMP: 
0E00    207D17        6985     JB FLAGS3 . 5 , COMM23_NONDAMP_REV 
                      6986     
0E03    C2AF          6987     	CLR 	EA					; Disable all interrupts
0E05    754203        6988     	MOV	COMM_PHASE, #3
0E08    900140        6989     	MOV	DPTR, #PWM_BFET	
                      6990     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL BPFET)
                               ENDIF
                      6993     	CNFET_OFF					; Turn off nfet
0E0B    C293          6993+1   CLR P1 . 3 
0E0D    306202        6994     JNB FLAGS0 . 2 , COMM23_NFET_DONE 
                      6995     	BNFET_ON					; Yes - turn on nfet
0E10    D297          6995+1   SETB P1 . 7 
                      6996     COMM23_NFET_DONE: 
0E12    D2AF          6997     	SETB	EA
                      6998     	SET_COMP_PHASE_C 			; Set comparator phase
0E14    759F13        6998+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0E17    020F7A        6999     	LJMP	COMM_EXIT
                      7000     
                      7001     	; Comm2Comm3 Non-damped reverse
                      7002     COMM23_NONDAMP_REV: 
0E1A    C2AF          7003     	CLR 	EA					; Disable all interrupts
0E1C    754203        7004     	MOV	COMM_PHASE, #3
0E1F    900140        7005     	MOV	DPTR, #PWM_BFET	
                      7006     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL BPFET)
                               ENDIF
                      7009     	ANFET_OFF					; Turn off nfet (reverse)
0E22    C295          7009+1   CLR P1 . 5 
0E24    306202        7010     JNB FLAGS0 . 2 , COMM23_NFET_DONE_REV 
                      7011     	BNFET_ON					; Yes - turn on nfet
0E27    D297          7011+1   SETB P1 . 7 
                      7012     COMM23_NFET_DONE_REV: 
0E29    D2AF          7013     	SETB	EA
                      7014     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0E2B    759F10        7014+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0E2E    020F7A        7015     	LJMP	COMM_EXIT
                      7016     
                      7017     
                      7018     ; Comm phase 3 to comm phase 4
                      7019     COMM3COMM4: 	
                      7020     	SET_RPM_OUT
0E31    207D16        7021     JB FLAGS3 . 5 , COMM34_REV 
                      7022     
0E34    C2AF          7023     	CLR 	EA					; Disable all interrupts
0E36    754204        7024     	MOV	COMM_PHASE, #4
                      7025     	APFET_OFF 				; Turn off pfet
0E39    C294          7025+1   CLR P1 . 4 
                      7026     	CPFET_ON					; Turn on pfet
0E3B    D292          7026+1   SETB P1 . 2 
0E3D    306202        7027     JNB FLAGS0 . 2 , COMM34_NFET_DONE 
                      7028     	BNFET_ON					; Pwm on - turn on nfet
0E40    D297          7028+1   SETB P1 . 7 
                      7029     COMM34_NFET_DONE: 
0E42    D2AF          7030     	SETB	EA
                      7031     	SET_COMP_PHASE_A 			; Set comparator phase
0E44    759F10        7031+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0E47    020F7A        7032     	JMP	COMM_EXIT
                      7033     
                      7034     COMM34_REV: 	
0E4A    C2AF          7035     	CLR 	EA					; Disable all interrupts
0E4C    754204        7036     	MOV	COMM_PHASE, #4
                      7037     	CPFET_OFF 				; Turn off pfet (reverse)
0E4F    C292          7037+1   CLR P1 . 2 
                      7038     	APFET_ON					; Turn on pfet (reverse)
0E51    D294          7038+1   SETB P1 . 4 
0E53    306202        7039     JNB FLAGS0 . 2 , COMM34_NFET_DONE_REV 
                      7040     	BNFET_ON					; Pwm on - turn on nfet
0E56    D297          7040+1   SETB P1 . 7 
                      7041     COMM34_NFET_DONE_REV: 
0E58    D2AF          7042     	SETB	EA
                      7043     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0E5A    759F13        7043+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0E5D    020F7A        7044     	JMP	COMM_EXIT
                      7045     
                      7046     
                      7047     ; Comm phase 4 to comm phase 5
                      7048     COMM4COMM5: 	
                      7049     	CLEAR_RPM_OUT
0E60    307243        7050     JNB FLAGS2 . 2 , COMM45_NONDAMP 
                      7051     
                      7052     	; Comm4Comm5 Damped
0E63    207D20        7053     JB FLAGS3 . 5 , COMM45_DAMP_REV 
                      7054     
0E66    C2AF          7055     	CLR 	EA					; Disable all interrupts
0E68    754205        7056     	MOV	COMM_PHASE, #5
0E6B    900154        7057     	MOV	DPTR, #PWM_AFET_DAMPED	
0E6E    757B10        7058     	MOV	DAMPINGFET, #(1 SHL APFET)
                      7059     	BNFET_OFF					; Turn off fets
0E71    C297          7059+1   CLR P1 . 7 
                      7060     	BPFET_OFF						
0E73    C296          7060+1   CLR P1 . 6 
0E75    306204        7061     JNB FLAGS0 . 2 , COMM45_NFET_OFF 
                      7062     	ANFET_ON					; Pwm on - turn on nfet
0E78    D295          7062+1   SETB P1 . 5 
0E7A    C17E          7063     	AJMP	COMM45_FETS_DONE
                      7064     COMM45_NFET_OFF: 
                      7065     	APFET_ON					; Pwm off - switch damping fets	
0E7C    D294          7065+1   SETB P1 . 4 
                      7066     COMM45_FETS_DONE: 
0E7E    D2AF          7067     	SETB	EA
                      7068     	SET_COMP_PHASE_B 			; Set comparator phase
0E80    759F11        7068+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0E83    020F7A        7069     	LJMP	COMM_EXIT
                      7070     
                      7071     	; Comm4Comm5 Damped reverse
                      7072     COMM45_DAMP_REV: 
0E86    C2AF          7073     	CLR 	EA					; Disable all interrupts
0E88    754205        7074     	MOV	COMM_PHASE, #5
0E8B    900176        7075     	MOV	DPTR, #PWM_CFET_DAMPED	; (reverse)
0E8E    757B04        7076     	MOV	DAMPINGFET, #(1 SHL CPFET)	; (reverse)
                      7077     	BNFET_OFF					; Turn off fets
0E91    C297          7077+1   CLR P1 . 7 
                      7078     	BPFET_OFF						
0E93    C296          7078+1   CLR P1 . 6 
0E95    306204        7079     JNB FLAGS0 . 2 , COMM45_NFET_OFF_REV 
                      7080     	CNFET_ON					; Pwm on - turn on nfet (reverse)
0E98    D293          7080+1   SETB P1 . 3 
0E9A    C19E          7081     	AJMP	COMM45_FETS_DONE_REV
                      7082     COMM45_NFET_OFF_REV: 
                      7083     	CPFET_ON					; Pwm off - switch damping fets (reverse)	
0E9C    D292          7083+1   SETB P1 . 2 
                      7084     COMM45_FETS_DONE_REV: 
0E9E    D2AF          7085     	SETB	EA
                      7086     	SET_COMP_PHASE_B 			; Set comparator phase
0EA0    759F11        7086+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0EA3    020F7A        7087     	LJMP	COMM_EXIT
                      7088     
                      7089     	; Comm4Comm5 Non-damped
                      7090     COMM45_NONDAMP: 
0EA6    207D17        7091     JB FLAGS3 . 5 , COMM45_NONDAMP_REV 
                      7092     
0EA9    C2AF          7093     	CLR 	EA					; Disable all interrupts
0EAB    754205        7094     	MOV	COMM_PHASE, #5
0EAE    900136        7095     	MOV	DPTR, #PWM_AFET	
                      7096     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL APFET)
                               ENDIF
                      7099     	BNFET_OFF					; Turn off nfet
0EB1    C297          7099+1   CLR P1 . 7 
0EB3    306202        7100     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      7101     	ANFET_ON					; Yes - turn on nfet
0EB6    D295          7101+1   SETB P1 . 5 
                      7102     COMM45_NFET_DONE: 
0EB8    D2AF          7103     	SETB	EA
                      7104     	SET_COMP_PHASE_B 			; Set comparator phase
0EBA    759F11        7104+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0EBD    020F7A        7105     	LJMP	COMM_EXIT
                      7106     
                      7107     	; Comm4Comm5 Non-damped reverse
                      7108     COMM45_NONDAMP_REV: 
0EC0    C2AF          7109     	CLR 	EA					; Disable all interrupts
0EC2    754205        7110     	MOV	COMM_PHASE, #5
0EC5    90014A        7111     	MOV	DPTR, #PWM_CFET		;  (reverse)
                      7112     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL CPFET)
                               ENDIF
                      7115     	BNFET_OFF					; Turn off nfet
0EC8    C297          7115+1   CLR P1 . 7 
0ECA    3062EB        7116     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      7117     	CNFET_ON					; Yes - turn on nfet (reverse)
0ECD    D293          7117+1   SETB P1 . 3 
0ECF    D2AF          7118     	SETB	EA
                      7119     	SET_COMP_PHASE_B 			; Set comparator phase
0ED1    759F11        7119+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0ED4    020F7A        7120     	LJMP	COMM_EXIT
                      7121     
                      7122     
                      7123     ; Comm phase 5 to comm phase 6
                      7124     COMM5COMM6: 	
                      7125     	SET_RPM_OUT
0ED7    207D16        7126     JB FLAGS3 . 5 , COMM56_REV 
                      7127     
0EDA    C2AF          7128     	CLR 	EA					; Disable all interrupts
0EDC    754206        7129     	MOV	COMM_PHASE, #6
                      7130     	CPFET_OFF 				; Turn off pfet
0EDF    C292          7130+1   CLR P1 . 2 
                      7131     	BPFET_ON					; Turn on pfet
0EE1    D296          7131+1   SETB P1 . 6 
0EE3    306202        7132     JNB FLAGS0 . 2 , COMM56_NFET_DONE 
                      7133     	ANFET_ON					; Pwm on - turn on nfet
0EE6    D295          7133+1   SETB P1 . 5 
                      7134     COMM56_NFET_DONE: 
0EE8    D2AF          7135     	SETB	EA
                      7136     	SET_COMP_PHASE_C 			; Set comparator phase
0EEA    759F13        7136+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0EED    020F7A        7137     	JMP	COMM_EXIT
                      7138     
                      7139     COMM56_REV: 
0EF0    C2AF          7140     	CLR 	EA					; Disable all interrupts
0EF2    754206        7141     	MOV	COMM_PHASE, #6
                      7142     	APFET_OFF 				; Turn off pfet (reverse)
0EF5    C294          7142+1   CLR P1 . 4 
                      7143     	BPFET_ON					; Turn on pfet
0EF7    D296          7143+1   SETB P1 . 6 
0EF9    306202        7144     JNB FLAGS0 . 2 , COMM56_NFET_DONE_REV 
                      7145     	CNFET_ON					; Pwm on - turn on nfet
0EFC    D293          7145+1   SETB P1 . 3 
                      7146     COMM56_NFET_DONE_REV: 
0EFE    D2AF          7147     	SETB	EA
                      7148     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0F00    759F10        7148+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F03    020F7A        7149     	JMP	COMM_EXIT
                      7150     
                      7151     
                      7152     ; Comm phase 6 to comm phase 1
                      7153     COMM6COMM1: 	
                      7154     	CLEAR_RPM_OUT
0F06    307243        7155     JNB FLAGS2 . 2 , COMM61_NONDAMP 
                      7156     
                      7157     	; Comm6Comm1 Damped
0F09    207D20        7158     JB FLAGS3 . 5 , COMM61_DAMP_REV 
                      7159     
0F0C    C2AF          7160     	CLR 	EA					; Disable all interrupts
0F0E    754201        7161     	MOV	COMM_PHASE, #1
0F11    900176        7162     	MOV	DPTR, #PWM_CFET_DAMPED	
0F14    757B04        7163     	MOV	DAMPINGFET, #(1 SHL CPFET)
                      7164     	ANFET_OFF					; Turn off fets
0F17    C295          7164+1   CLR P1 . 5 
                      7165     	APFET_OFF						
0F19    C294          7165+1   CLR P1 . 4 
0F1B    306204        7166     JNB FLAGS0 . 2 , COMM61_NFET_OFF 
                      7167     	CNFET_ON					; Pwm on - turn on nfet
0F1E    D293          7167+1   SETB P1 . 3 
0F20    E124          7168     	AJMP	COMM61_FETS_DONE
                      7169     COMM61_NFET_OFF: 
                      7170     	CPFET_ON					; Pwm off - switch damping fets	
0F22    D292          7170+1   SETB P1 . 2 
                      7171     COMM61_FETS_DONE: 
0F24    D2AF          7172     	SETB	EA
                      7173     	SET_COMP_PHASE_A 			; Set comparator phase
0F26    759F10        7173+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F29    020F7A        7174     	LJMP	COMM_EXIT
                      7175     
                      7176     	; Comm6Comm1 Damped reverse
                      7177     COMM61_DAMP_REV: 
0F2C    C2AF          7178     	CLR 	EA					; Disable all interrupts
0F2E    754201        7179     	MOV	COMM_PHASE, #1
0F31    900154        7180     	MOV	DPTR, #PWM_AFET_DAMPED	; (reverse)	
0F34    757B10        7181     	MOV	DAMPINGFET, #(1 SHL APFET)	; (reverse)
                      7182     	CNFET_OFF					; Turn off fets (reverse)
0F37    C293          7182+1   CLR P1 . 3 
                      7183     	CPFET_OFF						
0F39    C292          7183+1   CLR P1 . 2 
0F3B    306204        7184     JNB FLAGS0 . 2 , COMM61_NFET_OFF_REV 
                      7185     	ANFET_ON					; Pwm on - turn on nfet
0F3E    D295          7185+1   SETB P1 . 5 
0F40    E144          7186     	AJMP	COMM61_FETS_DONE_REV
                      7187     COMM61_NFET_OFF_REV: 
                      7188     	APFET_ON					; Pwm off - switch damping fets (reverse)	
0F42    D294          7188+1   SETB P1 . 4 
                      7189     COMM61_FETS_DONE_REV: 
0F44    D2AF          7190     	SETB	EA
                      7191     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0F46    759F13        7191+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F49    020F7A        7192     	JMP	COMM_EXIT
                      7193     
                      7194     	; Comm6Comm1 Non-damped
                      7195     COMM61_NONDAMP: 
0F4C    207D17        7196     JB FLAGS3 . 5 , COMM61_NONDAMP_REV 
                      7197     
0F4F    C2AF          7198     	CLR 	EA					; Disable all interrupts
0F51    754201        7199     	MOV	COMM_PHASE, #1
0F54    90014A        7200     	MOV	DPTR, #PWM_CFET	
                      7201     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL CPFET)
                               ENDIF
                      7204     	ANFET_OFF					; Turn off nfet
0F57    C295          7204+1   CLR P1 . 5 
0F59    306202        7205     JNB FLAGS0 . 2 , COMM61_NFET_DONE 
                      7206     	CNFET_ON					; Yes - turn on nfet
0F5C    D293          7206+1   SETB P1 . 3 
                      7207     COMM61_NFET_DONE: 
0F5E    D2AF          7208     	SETB	EA
                      7209     	SET_COMP_PHASE_A 			; Set comparator phase
0F60    759F10        7209+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F63    020F7A        7210     	JMP	COMM_EXIT
                      7211     
                      7212     	; Comm6Comm1 Non-damped reverse
                      7213     COMM61_NONDAMP_REV: 
0F66    C2AF          7214     	CLR 	EA					; Disable all interrupts
0F68    754201        7215     	MOV	COMM_PHASE, #1
0F6B    900136        7216     	MOV	DPTR, #PWM_AFET		; (reverse)
                      7217     IF NFETON_DELAY == 0
                               	MOV	DAMPINGFET, #(1 SHL APFET)
                               ENDIF
                      7220     	CNFET_OFF					; Turn off nfet (reverse)
0F6E    C293          7220+1   CLR P1 . 3 
0F70    306202        7221     JNB FLAGS0 . 2 , COMM61_NFET_DONE_REV 
                      7222     	ANFET_ON					; Yes - turn on nfet (reverse)
0F73    D295          7222+1   SETB P1 . 5 
                      7223     COMM61_NFET_DONE_REV: 
0F75    D2AF          7224     	SETB	EA
                      7225     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0F77    759F13        7225+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
                      7226     
                      7227     COMM_EXIT: 
0F7A    C265          7228     CLR FLAGS0 . 5 
0F7C    22            7229     	RET
                      7230     
                      7231     
                      7232     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7233     ;
                      7234     ; Switch power off routine
                      7235     ;
                      7236     ; No assumptions
                      7237     ;
                      7238     ; Switches all fets off 
                      7239     ;
                      7240     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7241     SWITCH_POWER_OFF: 
0F7D    900134        7242     	MOV	DPTR, #PWM_NOFET	; Set DPTR register to pwm_nofet		
0F80    757B00        7243     	MOV	DAMPINGFET, #0
                      7244     	ALL_NFETS_OFF			; Turn off all nfets
0F83    C295          7244+1   CLR P1 . 5 
0F85    C293          7244+1   CLR P1 . 3 
0F87    C297          7244+1   CLR P1 . 7 
                      7245     	ALL_PFETS_OFF			; Turn off all pfets
0F89    C294          7245+1   CLR P1 . 4 
0F8B    C292          7245+1   CLR P1 . 2 
0F8D    C296          7245+1   CLR P1 . 6 
0F8F    C262          7246     CLR FLAGS0 . 2 
0F91    22            7247     	RET			
                      7248     
                      7249     
                      7250     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7251     ;
                      7252     ; Set default parameters
                      7253     ;
                      7254     ; No assumptions
                      7255     ;
                      7256     ; Sets default programming parameters
                      7257     ;
                      7258     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7259     SET_DEFAULT_PARAMETERS: 
                      7260     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_SPOOLUP_TIME
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Pwm dither
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BRAKE_ON_STOP
                               ENDIF
                      7333     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_DITHER
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BRAKE_ON_STOP
                               ENDIF
                      7406     IF MODE == 2	; Multi
0F92    7880          7407     MOV R0 , # PGM_GOV_P_GAIN 
0F94    7609          7408     MOV @ R0 , # 9 
0F96    08            7409     INC R0 
0F97    7609          7410     MOV @ R0 , # 9 
0F99    08            7411     INC R0 
0F9A    7604          7412     MOV @ R0 , # 4 
0F9C    08            7413     INC R0 
0F9D    76FF          7414     MOV @ R0 , # 0FFH 
0F9F    08            7415     INC R0 
0FA0    7603          7416     MOV @ R0 , # 3 
0FA2    08            7417     INC R0 
0FA3    76FF          7418     MOV @ R0 , # 0FFH 
0FA5    08            7419     INC R0 
0FA6    760A          7420     MOV @ R0 , # 10 
0FA8    08            7421     INC R0 
0FA9    7603          7422     MOV @ R0 , # 3 
0FAB    08            7423     INC R0 
0FAC    7601          7424     MOV @ R0 , # 1 
0FAE    08            7425     INC R0 
0FAF    7601          7426     MOV @ R0 , # 1 
                      7427     
0FB1    788C          7428     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
0FB3    7601          7429     MOV @ R0 , # 1 
0FB5    08            7430     INC R0 
0FB6    76FF          7431     MOV @ R0 , # 0FFH 
0FB8    08            7432     INC R0 
0FB9    76FF          7433     MOV @ R0 , # 0FFH 
0FBB    08            7434     INC R0 
0FBC    76FF          7435     MOV @ R0 , # 0FFH 
0FBE    08            7436     INC R0 
0FBF    76FF          7437     MOV @ R0 , # 0FFH 
0FC1    08            7438     INC R0 
0FC2    76FF          7439     MOV @ R0 , # 0FFH 
0FC4    08            7440     INC R0 
0FC5    7603          7441     MOV @ R0 , # 3 
0FC7    08            7442     INC R0 
0FC8    76FF          7443     MOV @ R0 , # 0FFH 
0FCA    08            7444     INC R0 
0FCB    76FF          7445     MOV @ R0 , # 0FFH 
0FCD    08            7446     INC R0 
0FCE    76FF          7447     MOV @ R0 , # 0FFH 
0FD0    08            7448     INC R0 
0FD1    7625          7449     MOV @ R0 , # 37 
0FD3    08            7450     INC R0 
0FD4    76D0          7451     MOV @ R0 , # 208 
0FD6    08            7452     INC R0 
0FD7    7628          7453     MOV @ R0 , # 40 
0FD9    08            7454     INC R0 
0FDA    7650          7455     MOV @ R0 , # 80 
0FDC    08            7456     INC R0 
0FDD    7604          7457     MOV @ R0 , # 4 
0FDF    08            7458     INC R0 
0FE0    76FF          7459     MOV @ R0 , # 0FFH 
0FE2    08            7460     INC R0 
0FE3    7602          7461     MOV @ R0 , # 2 
0FE5    08            7462     INC R0 
0FE6    7600          7463     MOV @ R0 , # 0 
0FE8    08            7464     INC R0 
0FE9    767A          7465     MOV @ R0 , # 122 
0FEB    08            7466     INC R0 
0FEC    76FF          7467     MOV @ R0 , # 0FFH 
0FEE    08            7468     INC R0 
0FEF    7601          7469     MOV @ R0 , # 1 
0FF1    08            7470     INC R0 
0FF2    7601          7471     MOV @ R0 , # 1 
0FF4    08            7472     INC R0 
0FF5    7600          7473     MOV @ R0 , # 0 
0FF7    08            7474     INC R0 
0FF8    7603          7475     MOV @ R0 , # 3 
0FFA    08            7476     INC R0 
0FFB    7600          7477     MOV @ R0 , # 0 
                      7478     ENDIF
0FFD    22            7479     	RET
                      7480     
                      7481     
                      7482     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7483     ;
                      7484     ; Decode parameters
                      7485     ;
                      7486     ; No assumptions
                      7487     ;
                      7488     ; Decodes programming parameters
                      7489     ;
                      7490     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7491     DECODE_PARAMETERS: 
                      7492     	; Load programmed pwm frequency
0FFE    7887          7493     MOV R0 , # PGM_PWM_FREQ 
1000    E6            7494     MOV A , @ R0 
1001    FF            7495     MOV R7 , A 
1002    C272          7496     CLR FLAGS2 . 2 
                      7497     IF DAMPED_MODE_ENABLE == 1
1004    BF0302        7498     CJNE R7 , # 3 , ( $+5 ) 
1007    D272          7499     SETB FLAGS2 . 2 
                      7500     ENDIF
                      7501     	; Load programmed direction
1009    7888          7502     MOV R0 , # PGM_DIRECTION 
                      7503     IF MODE >= 1	; Tail or multi
100B    E6            7504     MOV A , @ R0 
100C    C3            7505     	CLR	C
100D    9403          7506     	SUBB	A, #3
100F    6008          7507     	JZ	DECODE_PARAMS_DIR_SET
                      7508     ENDIF
                      7509     
1011    C27D          7510     CLR FLAGS3 . 5 
1013    E6            7511     MOV A , @ R0 
1014    30E102        7512     	JNB	ACC.1, ($+5)
1017    D27D          7513     SETB FLAGS3 . 5 
                      7514     DECODE_PARAMS_DIR_SET: 
1019    C27E          7515     CLR FLAGS3 . 6 
101B    7889          7516     MOV R0 , # PGM_INPUT_POL 
101D    E6            7517     MOV A , @ R0 
101E    30E102        7518     	JNB	ACC.1, ($+5)
1021    D27E          7519     SETB FLAGS3 . 6 
1023    C3            7520     	CLR	C
1024    EF            7521     MOV A , R7 
1025    9402          7522     	SUBB	A, #2
1027    6008          7523     	JZ	DECODE_PWM_FREQ_LOW
                      7524     
1029    758E01        7525     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
102C    D273          7526     SETB FLAGS2 . 3 
102E    021036        7527     	JMP	DECODE_PWM_FREQ_END
                      7528     
                      7529     DECODE_PWM_FREQ_LOW: 
1031    758E00        7530     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
1034    C273          7531     CLR FLAGS2 . 3 
                      7532     
                      7533     DECODE_PWM_FREQ_END: 
1036    22            7534     	RET
                      7535     
                      7536     
                      7537     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7538     ;
                      7539     ; Decode settings
                      7540     ;
                      7541     ; No assumptions
                      7542     ;
                      7543     ; Decodes various settings
                      7544     ;
                      7545     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7546     DECODE_SETTINGS: 
                      7547     	; Decode governor gains
1037    7880          7548     MOV R0 , # PGM_GOV_P_GAIN 
1039    E6            7549     MOV A , @ R0 
103A    14            7550     	DEC	A	
103B    900080        7551     	MOV	DPTR, #GOV_GAIN_TABLE
103E    93            7552     	MOVC A, @A+DPTR	
103F    78A5          7553     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
1041    F6            7554     MOV @ R0 , A 
1042    7881          7555     MOV R0 , # PGM_GOV_I_GAIN 
1044    E6            7556     MOV A , @ R0 
1045    14            7557     	DEC	A	
1046    900080        7558     	MOV	DPTR, #GOV_GAIN_TABLE
1049    93            7559     	MOVC A, @A+DPTR	
104A    78A6          7560     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
104C    F6            7561     MOV @ R0 , A 
                      7562     	; Decode startup power
104D    7886          7563     MOV R0 , # PGM_STARTUP_PWR 
104F    E6            7564     MOV A , @ R0 
1050    14            7565     	DEC	A	
1051    90008D        7566     	MOV	DPTR, #STARTUP_POWER_TABLE
1054    93            7567     	MOVC A, @A+DPTR	
1055    78A7          7568     MOV R0 , # PGM_STARTUP_PWR_DECODED 
1057    F6            7569     MOV @ R0 , A 
                      7570     IF MODE == 0	; Main
                               	; Decode spoolup time
                               	MOV	TEMP1, #PGM_MAIN_SPOOLUP_TIME		
                               	MOV	A, @TEMP1
                               	MOV	TEMP1, A		; Store
                               	JNZ	DECODE_MAIN_SPOOLUP_NONZERO	; If not zero - branch
                               	
                               	MOV	MAIN_SPOOLUP_TIME_3X, #0	
                               	AJMP	DECODE_MAIN_SPOOLUP_DONE
                               
                               DECODE_MAIN_SPOOLUP_NONZERO:
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, #17		; Limit to 17 max
                               	JC	($+4)
                               
                               	MOV	TEMP1, #17
                               
                               	MOV	A, TEMP1
                               	ADD	A, TEMP1
                               	ADD	A, TEMP1		; Now 3x
                               	MOV	MAIN_SPOOLUP_TIME_3X, A
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, TEMP1		; Now 10x
                               	MOV	MAIN_SPOOLUP_TIME_10X, A
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, TEMP1		
                               	ADD	A, TEMP1		; Now 15x
                               	MOV	MAIN_SPOOLUP_TIME_15X, A
                               DECODE_MAIN_SPOOLUP_DONE:
                               ENDIF
                      7602     	; Decode low rpm power slope
1058    7886          7603     MOV R0 , # PGM_STARTUP_PWR 
105A    E6            7604     MOV A , @ R0 
105B    F539          7605     	MOV	LOW_RPM_PWR_SLOPE, A
105D    C3            7606     	CLR	C	
105E    9402          7607     	SUBB	A, #2
1060    5003          7608     	JNC	($+5)
1062    753902        7609     	MOV	LOW_RPM_PWR_SLOPE, #2
                      7610     	; Decode demag compensation
1065    789C          7611     MOV R0 , # PGM_DEMAG_COMP 
1067    E6            7612     MOV A , @ R0 
1068    7538FF        7613     	MOV	DEMAG_PWR_OFF_THRESH, #255	; Set default
                      7614     
106B    B40203        7615     	CJNE	A, #2, DECODE_DEMAG_HIGH
                      7616     
106E    7538A0        7617     	MOV	DEMAG_PWR_OFF_THRESH, #160	; Settings for demag comp low
                      7618     
                      7619     DECODE_DEMAG_HIGH: 
1071    B40303        7620     	CJNE	A, #3, DECODE_DEMAG_DONE
                      7621     
1074    753882        7622     	MOV	DEMAG_PWR_OFF_THRESH, #130	; Settings for demag comp high
                      7623     
                      7624     DECODE_DEMAG_DONE: 
                      7625     	; Decode pwm dither
1077    78A3          7626     MOV R0 , # PGM_PWM_DITHER 
1079    E6            7627     MOV A , @ R0 
107A    14            7628     	DEC	A	
107B    90009A        7629     	MOV	DPTR, #PWM_DITHER_TABLE
107E    93            7630     	MOVC A, @A+DPTR	
107F    F566          7631     	MOV	PWM_DITHER_DECODED, A
1081    120F7D        7632     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1084    22            7633     	RET
                      7634     
                      7635     
                      7636     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7637     ;
                      7638     ; Set BEC voltage
                      7639     ;
                      7640     ; No assumptions
                      7641     ;
                      7642     ; Sets the BEC output voltage low or high
                      7643     ;
                      7644     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7645     SET_BEC_VOLTAGE: 
                      7646     	; Set bec voltage
                      7647     IF HIGH_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
                      7657     IF HIGH_BEC_VOLTAGE == 2
                               	SET_BEC_0				; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	CJNE	A, #1, SET_BEC_VOLTAGE_2	
                               
                               	SET_BEC_1				; Set to level 1
                               
                               SET_BEC_VOLTAGE_2:
                               	CJNE	A, #2, SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_2				; Set to level 2
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
1085    22            7672     	RET
                      7673     
                      7674     
                      7675     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7676     ;
                      7677     ; Find throttle gain
                      7678     ;
                      7679     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      7680     ;
                      7681     ; Finds throttle gain from throttle calibration values
                      7682     ;
                      7683     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7684     FIND_THROTTLE_GAIN: 
                      7685     	; Load programmed minimum and maximum throttle
1086    7896          7686     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1088    E6            7687     MOV A , @ R0 
1089    FA            7688     MOV R2 , A 
108A    7897          7689     MOV R0 , # PGM_PPM_MAX_THROTTLE 
108C    E6            7690     MOV A , @ R0 
108D    FB            7691     MOV R3 , A 
108E    7888          7692     MOV R0 , # PGM_DIRECTION 
1090    E6            7693     MOV A , @ R0 
1091    B40305        7694     	CJNE	A, #3, FIND_THROTTLE_GAIN_CHECK_FULL
                      7695     
1094    C3            7696     	CLR	C
1095    EB            7697     MOV A , R3 
1096    940E          7698     	SUBB	A, #14				; Compensate for higher deadband in bidirectional
1098    FB            7699     MOV R3 , A 
                      7700     
                      7701     FIND_THROTTLE_GAIN_CHECK_FULL: 
                      7702     	; Check if full range is chosen
1099    307F04        7703     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      7704     
109C    7A00          7705     MOV R2 , # 0 
109E    7BFF          7706     MOV R3 , # 255 
                      7707     
                      7708     FIND_THROTTLE_GAIN_CALCULATE: 
                      7709     	; Calculate difference
10A0    C3            7710     	CLR	C
10A1    EB            7711     MOV A , R3 
10A2    9A            7712     SUBB A , R2 
10A3    FC            7713     MOV R4 , A 
                      7714     	; Check that difference is minimum 130
10A4    C3            7715     	CLR	C
10A5    9482          7716     	SUBB	A, #130
10A7    5002          7717     	JNC	($+4)
                      7718     
10A9    7C82          7719     MOV R4 , # 130 
                      7720     
                      7721     	; Find gain
10AB    757200        7722     	MOV	PPM_THROTTLE_GAIN, #0
                      7723     TEST_THROTTLE_GAIN: 
10AE    0572          7724     	INC	PPM_THROTTLE_GAIN
10B0    EC            7725     MOV A , R4 
10B1    8572F0        7726     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
10B4    A4            7727     	MUL	AB
10B5    C3            7728     	CLR	C
10B6    E5F0          7729     	MOV	A, B
10B8    947D          7730     	SUBB	A, #125
10BA    40F2          7731     	JC	TEST_THROTTLE_GAIN
10BC    22            7732     	RET
                      7733     
                      7734     
                      7735     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7736     ;
                      7737     ; Average throttle 
                      7738     ;
                      7739     ; Outputs result in Temp7
                      7740     ;
                      7741     ; Averages throttle calibration readings
                      7742     ;
                      7743     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7744     AVERAGE_THROTTLE: 
10BD    D27F          7745     SETB FLAGS3 . 7 
10BF    1186          7746     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
10C1    1205F3        7747     	CALL WAIT30MS		
10C4    1205F3        7748     	CALL WAIT30MS		
10C7    7A00          7749     MOV R2 , # 0 
10C9    7B00          7750     MOV R3 , # 0 
10CB    7C10          7751     MOV R4 , # 16 
                      7752     AVERAGE_THROTTLE_MEAS: 
10CD    1205E9        7753     	CALL	WAIT3MS			; Wait for new RC pulse value
10D0    E55C          7754     	MOV	A, NEW_RCP		; Get new RC pulse value
10D2    2A            7755     ADD A , R2 
10D3    FA            7756     MOV R2 , A 
10D4    7400          7757     	MOV	A, #0
10D6    3B            7758     ADDC A , R3 
10D7    FB            7759     MOV R3 , A 
10D8    DCF3          7760     DJNZ R4 , AVERAGE_THROTTLE_MEAS 
                      7761     
10DA    7C04          7762     MOV R4 , # 4 
                      7763     AVERAGE_THROTTLE_DIV: 
10DC    C3            7764     	CLR	C
10DD    EB            7765     MOV A , R3 
10DE    13            7766     	RRC	A      
10DF    FB            7767     MOV R3 , A 
10E0    EA            7768     MOV A , R2 
10E1    13            7769     	RRC	A      
10E2    FA            7770     MOV R2 , A 
10E3    DCF7          7771     DJNZ R4 , AVERAGE_THROTTLE_DIV 
                      7772     
10E5    FE            7773     MOV R6 , A 
10E6    C27F          7774     CLR FLAGS3 . 7 
10E8    1186          7775     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
10EA    22            7776     	RET
                      7777     
                      7778     
                      7779     
                      7780     
                      7781     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7782     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7783     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7784     ;
                      7785     ; Main program start
                      7786     ;
                      7787     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7788     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7789     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7790     PGM_START: 
                      7791     	; Initialize flash keys to invalid values
10EB    757C00        7792     	MOV	FLASH_KEY_1, #0
10EE    757D00        7793     	MOV	FLASH_KEY_2, #0
                      7794     	; Check flash lock byte
10F1    E5EF          7795     	MOV	A, RSTSRC			
10F3    20E603        7796     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      7797     
10F6    752000        7798     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      7799     
10F9    0520          7800     	INC	BIT_ACCESS
10FB    903FFF        7801     MOV DPTR , # 16383 
10FE    E520          7802     	MOV	A, BIT_ACCESS
1100    14            7803     	DEC	A
1101    6006          7804     	JZ	LOCK_BYTE_TEST
                      7805     
1103    901FFF        7806     MOV DPTR , # 8191 
1106    14            7807     	DEC	A
1107    6000          7808     	JZ	LOCK_BYTE_TEST
                      7809     
                      7810     LOCK_BYTE_TEST: 
1109    93            7811     	MOVC A, @A+DPTR		; Read lock byte
110A    04            7812     	INC	A				
110B    6003          7813     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      7814     
                      7815     IF ONE_S_CAPABLE == 0		
110D    75EF16        7816     	MOV	RSTSRC, #16H			; Generate hardware reset and set missing clock and VDD monitor
                      7817     ELSE
                               	MOV	RSTSRC, #14H			; Generate hardware reset and disable VDD monitor
                               ENDIF
                      7820     
                      7821     LOCK_BYTE_OK: 
                      7822     	; Disable the WDT.
                      7823     IF SIGNATURE_001 == 0F3H		
1110    53D9BF        7824     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
1113    75D908        7825     	MOV	PCA0MD, #0X08     ; Multishot
                      7826     ENDIF
                      7827     IF SIGNATURE_001 == 0F8H		
                               	MOV	WDTCN, #0DEH		; Disable watchdog
                               	MOV	WDTCN, #0ADH		
                               ENDIF
                      7831     	; Initialize stack
1116    7581C0        7832     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      7833     	; Initialize VDD monitor
1119    43FF80        7834     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
111C    1205E4        7835     	CALL	WAIT1MS			; Wait at least 100us
                      7836     IF ONE_S_CAPABLE == 0		
111F    75EF06        7837     	MOV 	RSTSRC, #06H   	; Set missing clock and VDD monitor as a reset source if not 1S capable
                      7838     ELSE
                               	MOV 	RSTSRC, #04H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it
                               ENDIF
                      7841     	; Set clock frequency
                      7842     IF SIGNATURE_001 == 0F3H		
1122    43B203        7843     	ORL	OSCICN, #03H		; Set clock divider to 1 (not supported on 'f850)
                      7844     ENDIF
                      7845     IF SIGNATURE_001 == 0F8H		
                               	MOV	CLKSEL, #00H		; Set clock divider to 1 (not supported on 'f3xx)
                               ENDIF
1125    E5B3          7848     	MOV	A, OSCICL				
1127    2402          7849     	ADD	A, #02H			; 24.5MHz to 24MHz (~0.5-1% per step)
1129    20E70D        7850     	JB	ACC.7, RESET_CAL_DONE	; Is carry (7bit) set? - branch
                      7851     
112C    F521          7852     	MOV	BIT_ACCESS_INT, A
                      7853     IF SIGNATURE_002 <> 010H		
112E    E5E3          7854     	MOV	A, OSCLCN
                      7855     ELSE
                               	MOV	A, OSCXCN
                               ENDIF
1130    20E006        7858     	JB	ACC.0, RESET_CAL_DONE	; Set if cal aleady done
                      7859     
1133    8521B3        7860     	MOV	OSCICL, BIT_ACCESS_INT
                      7861     IF SIGNATURE_002 <> 010H		
1136    43E301        7862     	ORL	OSCLCN, #01H			; Tag that cal is done
                      7863     ELSE
                               	ORL	OSCXCN, #01H			; Tag that cal is done
                               ENDIF
                      7866     
                      7867     RESET_CAL_DONE: 
                      7868     	; Switch power off
1139    120F7D        7869     	CALL	SWITCH_POWER_OFF
                      7870     	; Ports initialization
113C    7580FF        7871     MOV P0 , # 255 
113F    75A400        7872     MOV P0MDOUT , # 0 
1142    75F1B2        7873     MOV P0MDIN , # -78 
1145    75D4DF        7874     MOV P0SKIP , # -33 
1148    759001        7875     MOV P1 , # 1 
114B    75A5FC        7876     MOV P1MDOUT , # 252 
114E    75F2FE        7877     MOV P1MDIN , # -2 
1151    75D501        7878     MOV P1SKIP , # 1 
                      7879     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
1154    75A601        7882     MOV P2MDOUT , # 1 
                      7883     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      7890     	; Initialize the XBAR and related functionality
                      7891     	INITIALIZE_XBAR
1157    75E241        7891+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      7892     	; Switch power off again, after initializing ports
115A    120F7D        7893     	CALL	SWITCH_POWER_OFF
                      7894     	; Clear RAM
115D    E4            7895     	CLR	A				; Clear accumulator
115E    F8            7896     MOV R0 , A 
                      7897     CLEAR_RAM: 	
115F    F6            7898     MOV @ R0 , A 
1160    D8FD          7899     DJNZ R0 , CLEAR_RAM 
                      7900     	; Initialize LFSR
1162    756801        7901     	MOV	RANDOM, #1
                      7902     	; Set default programmed parameters
1165    120F92        7903     	CALL	SET_DEFAULT_PARAMETERS
                      7904     	; Read all programmed parameters
1168    121648        7905     	CALL READ_ALL_EEPROM_PARAMETERS
                      7906     	; Set beep strength
116B    7898          7907     MOV R0 , # PGM_BEEP_STRENGTH 
116D    8673          7908     MOV BEEP_STRENGTH , @ R0 
                      7909     	; Set initial arm variable
116F    753001        7910     	MOV	INITIAL_ARM, #1
                      7911     	; Initializing beep
1172    C2AF          7912     	CLR	EA				; Disable interrupts explicitly
1174    1205F3        7913     	CALL WAIT30MS
1177    12061B        7914     	CALL BEEP_F3
                      7915     IF MODE <= 1	; Main or tail
                               	; Wait for receiver to initialize
                               	CALL	WAIT1S
                               	CALL	WAIT200MS
                               	CALL	WAIT200MS
                               	CALL	WAIT100MS
                               ENDIF
                      7922     
                      7923     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7924     ;
                      7925     ; No signal entry point
                      7926     ;
                      7927     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7928     INIT_NO_SIGNAL: 
                      7929     	; Disable interrupts explicitly
117A    C2AF          7930     	CLR	EA				
                      7931     	; Initialize flash keys to invalid values
117C    757C00        7932     	MOV	FLASH_KEY_1, #0
117F    757D00        7933     	MOV	FLASH_KEY_2, #0
                      7934     	; Check if input signal is high for more than 15ms
1182    78FA          7935     MOV R0 , # 250 
                      7936     INPUT_HIGH_CHECK_1: 
1184    79FA          7937     MOV R1 , # 250 
                      7938     INPUT_HIGH_CHECK_2: 
1186    308507        7939     JNB 128 . 5 , BOOTLOADER_DONE 
1189    D9FB          7940     DJNZ R1 , INPUT_HIGH_CHECK_2 
118B    D8F7          7941     DJNZ R0 , INPUT_HIGH_CHECK_1 
                      7942     
118D    021C00        7943     	LJMP	1C00H			; Jump to bootloader
                      7944     
                      7945     BOOTLOADER_DONE: 
                      7946     	; Decode parameters
1190    120FFE        7947     	CALL	DECODE_PARAMETERS
                      7948     	; Decode settings
1193    1137          7949     	CALL	DECODE_SETTINGS
                      7950     	; Set BEC voltage
1195    1185          7951     	CALL	SET_BEC_VOLTAGE
                      7952     	; Find throttle gain from stored min and max settings
1197    1186          7953     	CALL	FIND_THROTTLE_GAIN
                      7954     	; Set beep strength
1199    7898          7955     MOV R0 , # PGM_BEEP_STRENGTH 
119B    8673          7956     MOV BEEP_STRENGTH , @ R0 
                      7957     	; Switch power off
119D    120F7D        7958     	CALL	SWITCH_POWER_OFF
                      7959     	; Set clock frequency
                      7960     IF MCU_48MHZ == 1
                      7961     	SET_MCU_CLK_24MHZ
11A0    75A900        7961+1   MOV CLKSEL , # 0  ; SET CLOCK TO 24MHZ
11A3    75B680        7961+1   MOV FLSCL , # 80H  ; SET FLASH TIMING FOR 24MHZ
11A6    757A00        7961+1   MOV CLOCK_SET_AT_48MHZ , # 0 
                      7962     ENDIF
                      7963     	; Timer control
11A9    758810        7964     	MOV	TCON, #10H		; Timer0 enabled
                      7965     	; Timer mode
11AC    758902        7966     	MOV	TMOD, #02H		; Timer0 as 8bit
                      7967     	; Timer2: clk/12 for 128us and 32ms interrupts
11AF    75C824        7968     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      7969     	; Timer3: clk/12 for commutation timing
11B2    759104        7970     	MOV	TMR3CN, #04H		; Timer3 enabled
                      7971     	; PCA
11B5    75D840        7972     	MOV	PCA0CN, #40H		; PCA enabled
                      7973     	; Enable interrupts
11B8    75A822        7974     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
11BB    75B802        7975     	MOV	IP, #02H			; High priority to timer0 interrupts
11BE    75E690        7976     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      7977     	; Initialize comparator
11C1    759B80        7978     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
11C4    759D00        7979     	MOV	CPT0MD, #00H		; Comparator response time 100ns
                      7980     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #00H		; Comparator response time 100ns
                               ENDIF
                      7984     	; Initialize ADC
                      7985     	INITIALIZE_ADC			; Initialize ADC operation
11C7    75D10E        7985+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
                      7985+1   IF 1 ==0 
                               MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
                               ELSE 
11CA    75BCC0        7985+1   MOV ADC0CF , # 0C0H  ; ADC CLOCK 2MHZ
                      7985+1   ENDIF 
11CD    75BB08        7985+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
11D0    75BA11        7985+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
11D3    75E880        7985+1   MOV ADC0CN , # 80H  ; ADC ENABLED
11D6    1205E4        7986     	CALL	WAIT1MS
11D9    D2AF          7987     	SETB	EA				; Enable all interrupts
                      7988     	; Measure number of lipo cells
11DB    1208F2        7989     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      7990     	; Reset stall count
11DE    753600        7991     	MOV	STALL_CNT, #0
                      7992     	; Initialize RC pulse
                      7993     	RCP_INT_FIRST 					; Enable interrupt and set to first edge
11E1    53DACF        7993+1   ANL PCA0CPM0 , # 0CFH 
11E4    207E03        7993+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
11E7    43DA20        7993+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
11EA    307E03        7993+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
11ED    43DA10        7993+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      7994     	RCP_INT_ENABLE		 			; Enable interrupt
11F0    43DA01        7994+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      7995     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
11F3    C2D8          7995+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
11F5    C271          7996     CLR FLAGS2 . 1 
11F7    1205FD        7997     	CALL WAIT200MS
                      7998     
                      7999     	; Measure PWM frequency
                      8000     MEASURE_PWM_FREQ_INIT: 	
11FA    D261          8001     SETB FLAGS0 . 1 
11FC    7B03          8002     MOV R3 , # 3 
                      8003     MEASURE_PWM_FREQ_START: 	
11FE    7A0C          8004     MOV R2 , # 12 
                      8005     MEASURE_PWM_FREQ_LOOP: 	
                      8006     	; Check if period diff was accepted
1200    E55B          8007     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
1202    7007          8008     	JNZ	MEASURE_PWM_FREQ_WAIT
                      8009     
1204    7A0C          8010     MOV R2 , # 12 
1206    DB03          8011     DJNZ R3 , ( $+5 ) 
1208    02117A        8012     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      8013     
                      8014     MEASURE_PWM_FREQ_WAIT: 
120B    1205F3        8015     	CALL	WAIT30MS						; Wait 30ms for new pulse
120E    207003        8016     JB FLAGS2 . 0 , ( $+6 ) 
1211    02117A        8017     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      8018     
1214    C270          8019     CLR FLAGS2 . 0 
1216    E55C          8020     	MOV	A, NEW_RCP					; Load value
1218    C3            8021     	CLR	C
1219    9402          8022     SUBB A , # 2 
121B    40E1          8023     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      8024     
121D    E52F          8025     	MOV	A, FLAGS3						; Check pwm frequency flags
121F    541F          8026     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1221    855E5D        8027     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
1224    F55E          8028     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
1226    B55DD5        8029     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      8030     
1229    DAD5          8031     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      8032     
                      8033     	; Clear measure pwm frequency flag
122B    C261          8034     CLR FLAGS0 . 1 
                      8035     	; Set up RC pulse interrupts after pwm frequency measurement
                      8036     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
122D    53DACF        8036+1   ANL PCA0CPM0 , # 0CFH 
1230    207E03        8036+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
1233    43DA20        8036+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
1236    307E03        8036+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
1239    43DA10        8036+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      8037     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
123C    C2D8          8037+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
123E    C271          8038     CLR FLAGS2 . 1 
1240    78A2          8039     MOV R0 , # PGM_ENABLE_PWM_INPUT 
1242    E6            8040     MOV A , @ R0 
1243    7008          8041     	JNZ	TEST_FOR_ONESHOT				; If it is - proceed
                      8042     
1245    D274          8043     SETB FLAGS2 . 4 
1247    E52F          8044     	MOV	A, FLAGS3						; Clear pwm frequency flags
1249    54E0          8045     	ANL	A, #NOT((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
124B    F52F          8046     	MOV	FLAGS3, A
                      8047     
                      8048     TEST_FOR_ONESHOT: 	
                      8049     	; Test whether signal is OneShot125
124D    C275          8050     CLR FLAGS2 . 5 
124F    752900        8051     	MOV	RCP_OUTSIDE_RANGE_CNT, #0		; Reset out of range counter
1252    1205F8        8052     	CALL WAIT100MS						; Wait for new RC pulse
1255    307409        8053     JNB FLAGS2 . 4 , VALIDATE_RCP_START 
                      8054     
1258    C3            8055     	CLR	C
1259    E529          8056     	MOV	A, RCP_OUTSIDE_RANGE_CNT			; Check how many pulses were outside normal PPM range (800-2160us)
125B    940A          8057     	SUBB	A, #10						
125D    4002          8058     	JC	VALIDATE_RCP_START
                      8059     
125F    D275          8060     SETB FLAGS2 . 5 
                      8061     
                      8062     	; Validate RC pulse
                      8063     VALIDATE_RCP_START: 	
1261    1205E9        8064     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1264    7802          8065     MOV R0 , # 2 
1266    307402        8066     JNB FLAGS2 . 4 , ( $+5 ) 
                      8067     
1269    7800          8068     MOV R0 , # 0 
                      8069     
126B    C3            8070     	CLR	C
126C    E55C          8071     	MOV	A, NEW_RCP					; Load value
126E    98            8072     SUBB A , R0 
126F    40F0          8073     	JC	VALIDATE_RCP_START				; No - start over
                      8074     
                      8075     	; Beep arm sequence start signal
1271    C2AF          8076     	CLR 	EA							; Disable all interrupts
1273    12060D        8077     	CALL BEEP_F1						; Signal that RC pulse is ready
1276    12060D        8078     	CALL BEEP_F1
1279    D2AF          8079     	SETB	EA							; Enable all interrupts
127B    1205FD        8080     	CALL WAIT200MS	
                      8081     
                      8082     	; Arming sequence start
127E    754C00        8083     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      8084     ARMING_START: 
                      8085     IF MODE >= 1	; Tail or multi
1281    7888          8086     MOV R0 , # PGM_DIRECTION 
1283    E6            8087     MOV A , @ R0 
1284    B40302        8088     	CJNE	A, #3, ($+5)
                      8089     
1287    6174          8090     	AJMP	PROGRAM_BY_TX_CHECKED	; Disable tx programming if bidirectional operation
                      8091     ENDIF
                      8092     
1289    1205E9        8093     	CALL WAIT3MS
128C    788C          8094     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
128E    E6            8095     MOV A , @ R0 
128F    C3            8096     	CLR	C
1290    9401          8097     	SUBB	A, #1				; Is TX programming enabled?
1292    5003          8098     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      8099     
1294    021374        8100     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      8101     
                      8102     ARMING_INITIAL_ARM_CHECK: 
1297    E530          8103     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
1299    C3            8104     	CLR	C
129A    9401          8105     	SUBB	A, #1				; Is it the initial arm sequence?
129C    5003          8106     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      8107     
129E    021374        8108     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      8109     
                      8110     ARMING_PPM_CHECK: 
                      8111     	; Initialize flash keys to valid values
12A1    757CA5        8112     	MOV	FLASH_KEY_1, #0A5H
12A4    757DF1        8113     	MOV	FLASH_KEY_2, #0F1H
12A7    207435        8114     JB FLAGS2 . 4 , THROTTLE_HIGH_CAL_START 
                      8115     
                      8116     	; PWM tx program entry
12AA    C3            8117     	CLR	C
12AB    E55C          8118     	MOV	A, NEW_RCP			; Load new RC pulse value
12AD    94FF          8119     SUBB A , # 255 
12AF    5003          8120     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      8121     
12B1    021374        8122     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      8123     
                      8124     PROGRAM_BY_TX_ENTRY_PWM: 	
12B4    C2AF          8125     	CLR	EA					; Disable all interrupts
12B6    120622        8126     	CALL BEEP_F4
12B9    D2AF          8127     	SETB	EA					; Enable all interrupts
12BB    1205F8        8128     	CALL WAIT100MS
12BE    C3            8129     	CLR	C
12BF    E55C          8130     	MOV	A, NEW_RCP			; Load new RC pulse value
12C1    9401          8131     SUBB A , # 1 
12C3    50EF          8132     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      8133     
                      8134     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
12C5    C2AF          8135     	CLR	EA					; Disable all interrupts
12C7    12060D        8136     	CALL BEEP_F1
12CA    1205EE        8137     	CALL WAIT10MS
12CD    12060D        8138     	CALL BEEP_F1
12D0    D2AF          8139     	SETB	EA					; Enable all interrupts
12D2    1205F8        8140     	CALL WAIT100MS
12D5    C3            8141     	CLR	C
12D6    E55C          8142     	MOV	A, NEW_RCP			; Load new RC pulse value
12D8    94FF          8143     SUBB A , # 255 
12DA    40E9          8144     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      8145     
12DC    0217F4        8146     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      8147     
                      8148     	; PPM throttle calibration and tx program entry
                      8149     THROTTLE_HIGH_CAL_START: 
                      8150     IF MODE <= 1	; Main or tail
                               	MOV	TEMP8, #5				; Set 3 seconds wait time
                               ELSE
12DF    7F02          8153     MOV R7 , # 2 
                      8154     ENDIF
                      8155     THROTTLE_HIGH_CAL: 			
12E1    D27F          8156     SETB FLAGS3 . 7 
12E3    1186          8157     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
12E5    1205F8        8158     	CALL WAIT100MS				; Wait for new throttle value
12E8    C2AF          8159     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
12EA    C27F          8160     CLR FLAGS3 . 7 
12EC    1186          8161     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
12EE    AE5C          8162     MOV R6 , NEW_RCP 
12F0    C3            8163     	CLR	C
12F1    E55C          8164     	MOV	A, NEW_RCP			; Load new RC pulse value
12F3    947F          8165     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
12F5    D2AF          8166     	SETB	EA					; Enable interrupts
12F7    5002          8167     	JNC	($+4)		
12F9    6184          8168     	AJMP	ARM_TARGET_UPDATED		; No - branch
                      8169     
12FB    1205E4        8170     	CALL WAIT1MS		
12FE    C2AF          8171     	CLR	EA					; Disable all interrupts
1300    120622        8172     	CALL BEEP_F4
1303    D2AF          8173     	SETB	EA					; Enable all interrupts
1305    DFDA          8174     DJNZ R7 , THROTTLE_HIGH_CAL 
                      8175     
1307    11BD          8176     	CALL	AVERAGE_THROTTLE
1309    C3            8177     	CLR	C
130A    EE            8178     MOV A , R6 
                      8179     IF MODE <= 1	; Main or tail
                               	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
                               ENDIF
130B    7897          8182     MOV R0 , # PGM_PPM_MAX_THROTTLE 
130D    F6            8183     MOV @ R0 , A 
130E    1205FD        8184     	CALL WAIT200MS				
1311    121777        8185     	CALL	SUCCESS_BEEP
                      8186     
                      8187     THROTTLE_LOW_CAL_START: 
1314    7F0A          8188     MOV R7 , # 10 
                      8189     THROTTLE_LOW_CAL: 			
1316    D27F          8190     SETB FLAGS3 . 7 
1318    1186          8191     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
131A    1205F8        8192     	CALL WAIT100MS
131D    C2AF          8193     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
131F    C27F          8194     CLR FLAGS3 . 7 
1321    1186          8195     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1323    AE5C          8196     MOV R6 , NEW_RCP 
1325    C3            8197     	CLR	C
1326    E55C          8198     	MOV	A, NEW_RCP			; Load new RC pulse value
1328    947F          8199     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
132A    D2AF          8200     	SETB	EA					; Enable interrupts
132C    50E6          8201     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      8202     
132E    1205E4        8203     	CALL WAIT1MS		
1331    C2AF          8204     	CLR	EA					; Disable all interrupts
1333    12060D        8205     	CALL BEEP_F1
1336    1205EE        8206     	CALL WAIT10MS
1339    12060D        8207     	CALL BEEP_F1
133C    D2AF          8208     	SETB	EA					; Enable all interrupts
133E    DFD6          8209     DJNZ R7 , THROTTLE_LOW_CAL 
                      8210     
1340    11BD          8211     	CALL	AVERAGE_THROTTLE
1342    EE            8212     MOV A , R6 
1343    2403          8213     	ADD	A, #3				; Add about 1%
1345    7896          8214     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1347    F6            8215     MOV @ R0 , A 
1348    F8            8216     MOV R0 , A 
1349    7997          8217     MOV R1 , # PGM_PPM_MAX_THROTTLE 
134B    E7            8218     MOV A , @ R1 
134C    C3            8219     	CLR	C
134D    9482          8220     	SUBB	A, #130				; Subtract 130 (520us) from max throttle
134F    4003          8221     	JC	PROGRAM_BY_TX_ENTRY_LIMIT
                      8222     
1351    98            8223     SUBB A , R0 
1352    5006          8224     	JNC	PROGRAM_BY_TX_ENTRY_STORE
                      8225     
                      8226     PROGRAM_BY_TX_ENTRY_LIMIT: 
1354    E8            8227     MOV A , R0 
1355    2482          8228     	ADD	A, #130				; Make max 520us higher than min
1357    7897          8229     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1359    F6            8230     MOV @ R0 , A 
                      8231     
                      8232     PROGRAM_BY_TX_ENTRY_STORE: 
135A    1205FD        8233     	CALL WAIT200MS				
135D    12168A        8234     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
1360    1217A6        8235     	CALL	SUCCESS_BEEP_INVERTED
                      8236     
                      8237     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
1363    1205F8        8238     	CALL WAIT100MS
1366    1186          8239     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1368    C3            8240     	CLR	C
1369    E55C          8241     	MOV	A, NEW_RCP			; Load new RC pulse value
136B    94FF          8242     SUBB A , # 255 
136D    5002          8243     	JNC	($+4)
136F    41A1          8244     	AJMP	ARMING_PPM_CHECK		; No - go back
                      8245     
1371    0217F4        8246     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      8247     
                      8248     PROGRAM_BY_TX_CHECKED: 
                      8249     	; Initialize flash keys to invalid values
1374    757C00        8250     	MOV	FLASH_KEY_1, #0
1377    757D00        8251     	MOV	FLASH_KEY_2, #0
137A    C3            8252     	CLR	C
137B    E55C          8253     	MOV	A, NEW_RCP			; Load new RC pulse value
137D    954C          8254     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
137F    4003          8255     	JC	ARM_TARGET_UPDATED		; No - do not update
                      8256     
1381    855C4C        8257     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      8258     
                      8259     ARM_TARGET_UPDATED: 
1384    1205F8        8260     	CALL WAIT100MS				; Wait for new throttle value
1387    7801          8261     MOV R0 , # 1 
1389    7988          8262     MOV R1 , # PGM_DIRECTION 
138B    E7            8263     MOV A , @ R1 
138C    B40302        8264     	CJNE	A, #3, ($+5)			; No - branch
                      8265     
138F    7805          8266     MOV R0 , # ( RCP_STOP+4 ) 
                      8267     
1391    C3            8268     	CLR	C
1392    E55C          8269     	MOV	A, NEW_RCP			; Load new RC pulse value
1394    98            8270     SUBB A , R0 
1395    4002          8271     	JC	ARM_END_BEEP			; Yes - proceed
                      8272     
1397    4181          8273     	JMP	ARMING_START			; No - start over
                      8274     
                      8275     ARM_END_BEEP: 
                      8276     	; Beep arm sequence end signal
1399    C2AF          8277     	CLR 	EA					; Disable all interrupts
139B    120622        8278     	CALL BEEP_F4				; Signal that rcpulse is ready
139E    D2AF          8279     	SETB	EA					; Enable all interrupts
13A0    1205FD        8280     	CALL WAIT200MS
                      8281     
                      8282     	; Clear initial arm variable
13A3    753000        8283     	MOV	INITIAL_ARM, #0
                      8284     
                      8285     	; Armed and waiting for power on
                      8286     WAIT_FOR_POWER_ON: 
13A6    E4            8287     	CLR	A
13A7    F531          8288     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
13A9    F532          8289     	MOV	POWER_ON_WAIT_CNT_H, A	
                      8290     WAIT_FOR_POWER_ON_LOOP: 
13AB    0531          8291     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
13AD    E531          8292     	MOV	A, POWER_ON_WAIT_CNT_L
13AF    F4            8293     	CPL	A
13B0    703F          8294     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 3 sec)
                      8295     
13B2    0532          8296     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
13B4    789A          8297     MOV R0 , # PGM_BEACON_DELAY 
13B6    E6            8298     MOV A , @ R0 
13B7    7819          8299     MOV R0 , # 25 
13B9    14            8300     	DEC	A
13BA    6012          8301     	JZ	BEEP_DELAY_SET
                      8302     
13BC    7832          8303     MOV R0 , # 50 
13BE    14            8304     	DEC	A
13BF    600D          8305     	JZ	BEEP_DELAY_SET
                      8306     
13C1    787D          8307     MOV R0 , # 125 
13C3    14            8308     	DEC	A
13C4    6008          8309     	JZ	BEEP_DELAY_SET
                      8310     
13C6    78FA          8311     MOV R0 , # 250 
13C8    14            8312     	DEC	A
13C9    6003          8313     	JZ	BEEP_DELAY_SET
                      8314     
13CB    753200        8315     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      8316     
                      8317     BEEP_DELAY_SET: 
13CE    C3            8318     	CLR	C
13CF    E532          8319     	MOV	A, POWER_ON_WAIT_CNT_H
13D1    98            8320     SUBB A , R0 
13D2    401D          8321     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      8322     
13D4    120F7D        8323     	CALL	SWITCH_POWER_OFF		; Switch power off in case braking is set
13D7    1205E4        8324     	CALL	WAIT1MS
13DA    1532          8325     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
13DC    753100        8326     	MOV	POWER_ON_WAIT_CNT_L, #0	; Set low wait counter
13DF    7899          8327     MOV R0 , # PGM_BEACON_STRENGTH 
13E1    8673          8328     MOV BEEP_STRENGTH , @ R0 
13E3    C2AF          8329     	CLR 	EA					; Disable all interrupts
13E5    120622        8330     	CALL BEEP_F4				; Signal that there is no signal
13E8    D2AF          8331     	SETB	EA					; Enable all interrupts
13EA    7898          8332     MOV R0 , # PGM_BEEP_STRENGTH 
13EC    8673          8333     MOV BEEP_STRENGTH , @ R0 
13EE    1205F8        8334     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      8335     
                      8336     WAIT_FOR_POWER_ON_NO_BEEP: 
13F1    1205EE        8337     	CALL WAIT10MS
13F4    E52A          8338     	MOV	A, RCP_TIMEOUT_CNTD				; Load RC pulse timeout counter value
13F6    7005          8339     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      8340     
13F8    307402        8341     JNB FLAGS2 . 4 , WAIT_FOR_POWER_ON_PPM_NOT_MISSING 
                      8342     
13FB    217A          8343     	JMP	INIT_NO_SIGNAL					; If ppm and pulses missing - go back to detect input signal
                      8344     
                      8345     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
13FD    7801          8346     MOV R0 , # 1 
13FF    207402        8347     JB FLAGS2 . 4 , ( $+5 ) 
                      8348     
1402    7806          8349     MOV R0 , # ( RCP_STOP+5 ) 
                      8350     
1404    C3            8351     	CLR	C
1405    E55C          8352     	MOV	A, NEW_RCP			; Load new RC pulse value
1407    98            8353     SUBB A , R0 
1408    40A1          8354     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      8355     
                      8356     IF MODE >= 1	; Tail or multi
140A    7888          8357     MOV R0 , # PGM_DIRECTION 
140C    E6            8358     MOV A , @ R0 
140D    C3            8359     	CLR	C
140E    9403          8360     	SUBB	A, #3
1410    6003          8361     	JZ 	WAIT_FOR_POWER_ON_CHECK_TIMEOUT	; Do not wait if bidirectional operation
                      8362     ENDIF
                      8363     
1412    1205F8        8364     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      8365     
                      8366     WAIT_FOR_POWER_ON_CHECK_TIMEOUT: 
1415    E52A          8367     	MOV	A, RCP_TIMEOUT_CNTD		; Load RC pulse timeout counter value
1417    7003          8368     	JNZ	($+5)				; If it is not zero - proceed
                      8369     
1419    02117A        8370     	LJMP	INIT_NO_SIGNAL			; If it is zero (pulses missing) - go back to detect input signal
                      8371     
                      8372     
                      8373     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8374     ;
                      8375     ; Start entry point
                      8376     ;
                      8377     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8378     INIT_START: 
141C    C2AF          8379     	CLR	EA
141E    120F7D        8380     	CALL SWITCH_POWER_OFF
1421    E4            8381     	CLR	A
1422    F522          8382     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
1424    F523          8383     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
1426    F524          8384     	MOV	CURRENT_PWM, A			; Set current pwm to zero
1428    F525          8385     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
142A    F526          8386     	MOV	CURRENT_PWM_LIM_DITH, A
142C    F567          8387     	MOV	PWM_DITHER_EXCESS_POWER, A
142E    D2AF          8388     	SETB	EA
1430    7885          8389     MOV R0 , # PGM_MOTOR_IDLE 
1432    E6            8390     MOV A , @ R0 
1433    C3            8391     	CLR	C
1434    33            8392     	RLC	A
1435    F565          8393     	MOV	PWM_MOTOR_IDLE, A
1437    E4            8394     	CLR	A
1438    F544          8395     	MOV	GOV_TARGET_L, A		; Set target to zero
143A    F545          8396     	MOV	GOV_TARGET_H, A
143C    F546          8397     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
143E    F547          8398     	MOV	GOV_INTEGRAL_H, A
1440    F548          8399     	MOV	GOV_INTEGRAL_X, A
1442    F570          8400     	MOV	ADC_CONVERSION_CNT, A
1444    F52C          8401     	MOV	FLAGS0, A				; Clear flags0
1446    F52D          8402     	MOV	FLAGS1, A				; Clear flags1
1448    F537          8403     	MOV	DEMAG_DETECTED_METRIC, A	; Clear demag metric
                      8404     	;**** **** **** **** ****
                      8405     	; Motor start beginning
                      8406     	;**** **** **** **** **** 
144A    757008        8407     MOV ADC_CONVERSION_CNT , # 8 
                      8408     	SET_ADC_IP_TEMP
144D    75BB10        8408+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
1450    1205E4        8409     	CALL WAIT1MS
1453    1208F6        8410     	CALL START_ADC_CONVERSION
                      8411     READ_INITIAL_TEMP: 
1456    30EDFD        8412     	JNB	AD0INT, READ_INITIAL_TEMP
                      8413     	READ_ADC_RESULT						; Read initial temperature
1459    A8BD          8413+1   MOV R0 , ADC0L 
145B    A9BE          8413+1   MOV R1 , ADC0H 
145D    E9            8414     MOV A , R1 
145E    7001          8415     	JNZ	($+3)							; Is reading below 256?
                      8416     
1460    F8            8417     MOV R0 , A 
                      8418     
1461    8871          8419     MOV CURRENT_AVERAGE_TEMP , R0 
1463    1208FA        8420     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1466    757008        8421     MOV ADC_CONVERSION_CNT , # 8 
                      8422     	SET_ADC_IP_TEMP
1469    75BB10        8422+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      8423     	; Set up start operating conditions
146C    120FFE        8424     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
                      8425     	; Set max allowed power
146F    C2AF          8426     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
1471    7561FF        8427     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
1474    120990        8428     	CALL SET_STARTUP_PWM
1477    852261        8429     	MOV	PWM_LIMIT, REQUESTED_PWM
147A    852262        8430     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
147D    852263        8431     	MOV	PWM_LIMIT_BY_RPM, REQUESTED_PWM
1480    D2AF          8432     	SETB	EA
1482    752201        8433     	MOV	REQUESTED_PWM, #1			; Set low pwm again after calling set_startup_pwm
1485    752401        8434     	MOV	CURRENT_PWM, #1
1488    752501        8435     	MOV	CURRENT_PWM_LIMITED, #1	
148B    752601        8436     	MOV	CURRENT_PWM_LIM_DITH, #1
148E    856069        8437     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1491    756A01        8438     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      8439     	; Begin startup sequence
                      8440     IF MCU_48MHZ == 1
                      8441     	SET_MCU_CLK_48MHZ
1494    75B690        8441+1   MOV FLSCL , # 90H  ; SET FLASH TIMING FOR 48MHZ
1497    75A903        8441+1   MOV CLKSEL , # 3  ; SET CLOCK TO 48MHZ
149A    757A01        8441+1   MOV CLOCK_SET_AT_48MHZ , # 1 
                      8442     ENDIF
149D    7888          8443     MOV R0 , # PGM_DIRECTION 
149F    E6            8444     MOV A , @ R0 
14A0    B40307        8445     	CJNE	A, #3, INIT_START_BIDIR_DONE
                      8446     
14A3    C27D          8447     CLR FLAGS3 . 5 
14A5    307602        8448     JNB FLAGS2 . 6 , ( $+5 ) 
14A8    D27D          8449     SETB FLAGS3 . 5 
                      8450     
                      8451     INIT_START_BIDIR_DONE: 
14AA    D268          8452     SETB FLAGS1 . 0 
14AC    D269          8453     SETB FLAGS1 . 1 
14AE    753300        8454     	MOV	STARTUP_CNT, #0			; Reset counter
14B1    120ED7        8455     	CALL COMM5COMM6				; Initialize commutation
14B4    120F06        8456     	CALL COMM6COMM1				
14B7    1209B0        8457     	CALL INITIALIZE_TIMING			; Initialize timing
14BA    1209B7        8458     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
14BD    1209B0        8459     	CALL INITIALIZE_TIMING			; Initialize timing
14C0    1209B7        8460     	CALL	CALC_NEXT_COMM_TIMING		
14C3    1209B0        8461     	CALL	INITIALIZE_TIMING			; Initialize timing
                      8462     
                      8463     
                      8464     
                      8465     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8466     ;
                      8467     ; Run entry point
                      8468     ;
                      8469     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8470     
                      8471     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      8472     ; Out_cA changes from low to high
                      8473     RUN1: 
14C6    120C43        8474     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
                      8475     ;	 	setup_comm_wait		; Setup wait time from zero cross to commutation
                      8476     ;	 	evaluate_comparator_integrity	; Check whether comparator reading has been normal
14C9    120703        8477     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
14CC    120D44        8478     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
14CF    120D8B        8479     	CALL COMM1COMM2			; Commutate
14D2    1209B7        8480     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
                      8481     ;	 	wait_advance_timing		; Wait advance timing and start zero cross wait
                      8482     ;	 	calc_new_wait_times
                      8483     ;	 	wait_before_zc_scan		; Wait zero cross wait and start zero cross timeout
                      8484     
                      8485     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      8486     ; Out_cB changes from high to low
                      8487     RUN2: 
14D5    120C32        8488     	CALL WAIT_FOR_COMP_OUT_LOW
                      8489     ;	 	setup_comm_wait	
                      8490     ;		evaluate_comparator_integrity	
14D8    306E03        8491     JNB FLAGS1 . 6 , ( $+6 ) 
14DB    12075F        8492     	LCALL CALC_GOVERNOR_PROP_ERROR
14DE    206603        8493     JB FLAGS0 . 6 , ( $+6 ) 
14E1    1208AC        8494     	LCALL SET_PWM_LIMIT_LOW_RPM
14E4    306603        8495     JNB FLAGS0 . 6 , ( $+6 ) 
14E7    1208DC        8496     	LCALL SET_PWM_LIMIT_HIGH_RPM
14EA    120D44        8497     	CALL WAIT_FOR_COMM
14ED    120DBA        8498     	CALL COMM2COMM3
14F0    1209B7        8499     	CALL CALC_NEXT_COMM_TIMING
                      8500     ;	 	wait_advance_timing
                      8501     ;	 	calc_new_wait_times
                      8502     ;	 	wait_before_zc_scan	
                      8503     
                      8504     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      8505     ; Out_cC changes from low to high
                      8506     RUN3: 
14F3    120C43        8507     	CALL WAIT_FOR_COMP_OUT_HIGH
                      8508     ;	 	setup_comm_wait	
                      8509     ;	 	evaluate_comparator_integrity	
14F6    306E03        8510     JNB FLAGS1 . 6 , ( $+6 ) 
14F9    120794        8511     	LCALL CALC_GOVERNOR_INT_ERROR
14FC    120D44        8512     	CALL WAIT_FOR_COMM
14FF    120E31        8513     	CALL COMM3COMM4
1502    1209B7        8514     	CALL CALC_NEXT_COMM_TIMING
                      8515     ;	 	wait_advance_timing
                      8516     ;	 	calc_new_wait_times
                      8517     ;	 	wait_before_zc_scan	
                      8518     
                      8519     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      8520     ; Out_cA changes from high to low
                      8521     RUN4: 
1505    120C32        8522     	CALL WAIT_FOR_COMP_OUT_LOW
                      8523     ;	 	setup_comm_wait	
                      8524     ;	 	evaluate_comparator_integrity	
1508    306E03        8525     JNB FLAGS1 . 6 , ( $+6 ) 
150B    1207F2        8526     	LCALL CALC_GOVERNOR_PROP_CORRECTION
150E    120D44        8527     	CALL WAIT_FOR_COMM
1511    120E60        8528     	CALL COMM4COMM5
1514    1209B7        8529     	CALL CALC_NEXT_COMM_TIMING
                      8530     ;	 	wait_advance_timing
                      8531     ;	 	calc_new_wait_times
                      8532     ;	 	wait_before_zc_scan	
                      8533     
                      8534     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      8535     ; Out_cB changes from low to high
                      8536     RUN5: 
1517    120C43        8537     	CALL WAIT_FOR_COMP_OUT_HIGH
                      8538     ;	 	setup_comm_wait	
                      8539     ;	 	evaluate_comparator_integrity	
151A    306E03        8540     JNB FLAGS1 . 6 , ( $+6 ) 
151D    120850        8541     	LCALL CALC_GOVERNOR_INT_CORRECTION
1520    120D44        8542     	CALL WAIT_FOR_COMM
1523    120ED7        8543     	CALL COMM5COMM6
1526    1209B7        8544     	CALL CALC_NEXT_COMM_TIMING
                      8545     ;	 	wait_advance_timing
                      8546     ;	 	calc_new_wait_times
                      8547     ;	 	wait_before_zc_scan	
                      8548     
                      8549     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      8550     ; Out_cC changes from high to low
                      8551     RUN6: 
1529    1208F6        8552     	CALL START_ADC_CONVERSION
152C    120C32        8553     	CALL WAIT_FOR_COMP_OUT_LOW
                      8554     ;	 	setup_comm_wait	
                      8555     ;	 	evaluate_comparator_integrity	
152F    120D44        8556     	CALL WAIT_FOR_COMM
1532    120F06        8557     	CALL COMM6COMM1
1535    1208FA        8558     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1538    1209B7        8559     	CALL CALC_NEXT_COMM_TIMING
                      8560     ;	 	wait_advance_timing
                      8561     ;	 	calc_new_wait_times
                      8562     ;	 	wait_before_zc_scan	
                      8563     
                      8564     	; Check if it is direct startup
153B    306932        8565     JNB FLAGS1 . 1 , NORMAL_RUN_CHECKS 
                      8566     
                      8567     	; Set spoolup power variables
153E    856461        8568     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
1541    856462        8569     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
1544    856069        8570     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1547    756A01        8571     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      8572     	; Check startup counter
154A    7918          8573     MOV R1 , # 24 
154C    7A0C          8574     MOV R2 , # 12 
154E    C3            8575     	CLR	C
154F    E533          8576     	MOV	A, STARTUP_CNT				; Load counter
1551    99            8577     SUBB A , R1 
1552    400F          8578     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      8579     
1554    C269          8580     CLR FLAGS1 . 1 
1556    D26A          8581     SETB FLAGS1 . 2 
1558    8A35          8582     MOV INITIAL_RUN_ROT_CNTD , R2 
                      8583     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               ENDIF
                      8586     IF MODE == 2	; Multi
155A    856461        8587     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG
155D    856463        8588     	MOV	PWM_LIMIT_BY_RPM, PWM_SPOOLUP_BEG
                      8589     ENDIF
1560    021570        8590     	JMP	NORMAL_RUN_CHECKS
                      8591     
                      8592     DIRECT_START_CHECK_RCP: 
1563    C3            8593     	CLR	C
1564    E55C          8594     	MOV	A, NEW_RCP				; Load new pulse value
1566    9401          8595     SUBB A , # 1 
1568    4003          8596     	JC	($+5)
                      8597     
156A    0214C6        8598     	LJMP	RUN1						; Continue to run 
                      8599     
156D    0215F6        8600     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8601     
                      8602     
                      8603     NORMAL_RUN_CHECKS: 
                      8604     	; Check if it is initial run phase
1570    306A1D        8605     JNB FLAGS1 . 2 , INITIAL_RUN_PHASE_DONE 
1573    206C1A        8606     JB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      8607     
                      8608     	; Decrement startup rotaton count
1576    E535          8609     	MOV	A, INITIAL_RUN_ROT_CNTD
1578    14            8610     	DEC	A
                      8611     	; Check number of nondamped rotations
1579    7006          8612     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      8613     
157B    C26A          8614     CLR FLAGS1 . 2 
157D    D26B          8615     SETB FLAGS1 . 3 
157F    81C6          8616     	JMP RUN1						; Continue with normal run
                      8617     
                      8618     NORMAL_RUN_CHECK_STARTUP_ROT: 
1581    F535          8619     	MOV	INITIAL_RUN_ROT_CNTD, A		; Not zero - store counter
                      8620     
1583    C3            8621     	CLR	C
1584    E55C          8622     	MOV	A, NEW_RCP				; Load new pulse value
1586    9401          8623     SUBB A , # 1 
1588    4003          8624     	JC	($+5)
                      8625     
158A    0214C6        8626     	LJMP	RUN1						; Continue to run 
                      8627     
158D    0215F6        8628     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8629     
                      8630     INITIAL_RUN_PHASE_DONE: 
                      8631     	; Reset stall count
1590    753600        8632     	MOV	STALL_CNT, #0
                      8633     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      8646     	; Exit run loop after a given time
1593    78FA          8647     MOV R0 , # 250 
1595    79A4          8648     MOV R1 , # PGM_BRAKE_ON_STOP 
1597    E7            8649     MOV A , @ R1 
1598    6002          8650     	JZ	($+4)
                      8651     
159A    7803          8652     MOV R0 , # 3 
                      8653     
159C    C3            8654     	CLR	C
159D    E55F          8655     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
159F    98            8656     SUBB A , R0 
15A0    5054          8657     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      8658     
15A2    307404        8659     JNB FLAGS2 . 4 , RUN6_CHECK_DIR 
                      8660     
15A5    E52A          8661     	MOV	A, RCP_TIMEOUT_CNTD			; Load RC pulse timeout counter value
15A7    604D          8662     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      8663     
                      8664     RUN6_CHECK_DIR: 
                      8665     IF MODE >= 1	; Tail or multi
15A9    7888          8666     MOV R0 , # PGM_DIRECTION 
15AB    E6            8667     MOV A , @ R0 
15AC    B40317        8668     	CJNE	A, #3, RUN6_CHECK_SPEED
                      8669     
15AF    207D05        8670     JB FLAGS3 . 5 , RUN6_CHECK_DIR_REV 
15B2    207607        8671     JB FLAGS2 . 6 , RUN6_CHECK_DIR_CHANGE 
15B5    A1C6          8672     	AJMP	RUN6_CHECK_SPEED
                      8673     
                      8674     RUN6_CHECK_DIR_REV: 
15B7    307602        8675     JNB FLAGS2 . 6 , RUN6_CHECK_DIR_CHANGE 
15BA    A1C6          8676     	AJMP	RUN6_CHECK_SPEED
                      8677     
                      8678     RUN6_CHECK_DIR_CHANGE: 
15BC    206C07        8679     JB FLAGS1 . 4 , RUN6_CHECK_SPEED 
                      8680     
15BF    D26C          8681     SETB FLAGS1 . 4 
15C1    856461        8682     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set max power while braking
15C4    A105          8683     	JMP	RUN4						; Go back to run 4, thereby changing force direction
                      8684     
                      8685     RUN6_CHECK_SPEED: 
                      8686     ENDIF
15C6    78F0          8687     MOV R0 , # 0F0H 
15C8    306C05        8688     JNB FLAGS1 . 4 , RUN6_BRAKE_DONE 
                      8689     
15CB    856461        8690     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG 	; Set max power while braking
15CE    7820          8691     MOV R0 , # 20H 
                      8692     
                      8693     RUN6_BRAKE_DONE: 
15D0    C3            8694     	CLR	C
15D1    E541          8695     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
15D3    98            8696     SUBB A , R0 
15D4    5002          8697     	JNC	($+4)					; Yes - stop or turn direction 
15D6    81C6          8698     	AJMP	RUN1						; No - go back to run 1
                      8699     
                      8700     IF MODE >= 1	; Tail or multi
15D8    306C1B        8701     JNB FLAGS1 . 4 , RUN_TO_WAIT_FOR_POWER_ON 
                      8702     
15DB    C26C          8703     CLR FLAGS1 . 4 
15DD    C27D          8704     CLR FLAGS3 . 5 
15DF    307602        8705     JNB FLAGS2 . 6 , ( $+5 ) 
15E2    D27D          8706     SETB FLAGS3 . 5 
15E4    D26A          8707     SETB FLAGS1 . 2 
15E6    753512        8708     	MOV	INITIAL_RUN_ROT_CNTD, #18
15E9    856461        8709     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set initial max power
15EC    81C6          8710     	AJMP	RUN1						; Go back to run 1 
                      8711     ENDIF
                      8712     
                      8713     RUN_TO_WAIT_FOR_POWER_ON_FAIL: 	
15EE    0536          8714     	INC	STALL_CNT					; Increment stall count
15F0    E55C          8715     	MOV	A, NEW_RCP				; Check if RCP is zero, then it is a normal stop			
15F2    6002          8716     	JZ	RUN_TO_WAIT_FOR_POWER_ON
15F4    A1F9          8717     	AJMP	RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE
                      8718     
                      8719     RUN_TO_WAIT_FOR_POWER_ON: 	
15F6    753600        8720     	MOV	STALL_CNT, #0
                      8721     
                      8722     RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE: 
15F9    C2AF          8723     	CLR	EA
15FB    120F7D        8724     	CALL SWITCH_POWER_OFF
15FE    7887          8725     MOV R0 , # PGM_PWM_FREQ 
1600    E6            8726     MOV A , @ R0 
1601    FE            8727     MOV R6 , A 
1602    7602          8728     MOV @ R0 , # 2 
1604    120FFE        8729     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
1607    7887          8730     MOV R0 , # PGM_PWM_FREQ 
1609    EE            8731     MOV A , R6 
160A    F6            8732     MOV @ R0 , A 
160B    E4            8733     	CLR	A
160C    F522          8734     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
160E    F523          8735     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
1610    F524          8736     	MOV	CURRENT_PWM, A				; Set current pwm to zero
1612    F525          8737     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
1614    F526          8738     	MOV	CURRENT_PWM_LIM_DITH, A	
1616    F565          8739     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
1618    752C00        8740     	MOV	FLAGS0, #0				; Clear flags0
161B    752D00        8741     	MOV	FLAGS1, #0				; Clear flags1
                      8742     IF MCU_48MHZ == 1
                      8743     	SET_MCU_CLK_24MHZ
161E    75A900        8743+1   MOV CLKSEL , # 0  ; SET CLOCK TO 24MHZ
1621    75B680        8743+1   MOV FLSCL , # 80H  ; SET FLASH TIMING FOR 24MHZ
1624    757A00        8743+1   MOV CLOCK_SET_AT_48MHZ , # 0 
                      8744     ENDIF
1627    D2AF          8745     	SETB	EA
1629    1205F8        8746     	CALL	WAIT100MS					; Wait for pwm to be stopped
162C    120F7D        8747     	CALL SWITCH_POWER_OFF
162F    78A4          8748     MOV R0 , # PGM_BRAKE_ON_STOP 
1631    E6            8749     MOV A , @ R0 
1632    6006          8750     	JZ	RUN_TO_WAIT_FOR_POWER_ON_BRAKE_DONE
                      8751     
                      8752     	BRAKE_FETS_ON
                      8752+1   ANFET_ON 
1634    D295          8752+2   SETB P1 . 5 
                      8752+1   BNFET_ON 
1636    D297          8752+2   SETB P1 . 7 
                      8752+1   CNFET_ON 
1638    D293          8752+2   SETB P1 . 3 
                      8753     
                      8754     RUN_TO_WAIT_FOR_POWER_ON_BRAKE_DONE: 
                      8755     IF MODE == 0	; Main
                               	JNB	FLAGS2.RCP_PPM, RUN_TO_NEXT_STATE_MAIN	; If flag is not set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNTD			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	INIT_NO_SIGNAL				; If it is zero (pulses missing) - go back to detect input signal
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      8775     IF MODE >= 1	; Tail or multi
163A    307409        8776     JNB FLAGS2 . 4 , JMP_WAIT_FOR_POWER_ON 
                      8777     
163D    C3            8778     	CLR	C
163E    E536          8779     	MOV	A, STALL_CNT
1640    9404          8780     	SUBB	A, #4
1642    4002          8781     	JC	JMP_WAIT_FOR_POWER_ON
1644    217A          8782     	JMP	INIT_NO_SIGNAL
                      8783     
                      8784     JMP_WAIT_FOR_POWER_ON: 
1646    61A6          8785     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      8786     ENDIF
                      8787     
                      8788     
                      8789     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8790     
                      8791     $INCLUDE (BLHELITXPGM.INC)			; Include source code for programming the ESC with the TX
                      9458     $INCLUDE (BLHELIBOOTLOAD.INC)			; Include source code for bootloader
                      9865     
                      9866     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      9867     
                      9868     
------                9869     CSEG AT 19FDH
                      9870     RESET: 
19FD    0210EB        9871     LJMP	PGM_START
                      9872     
                      9873     
                      9874     
                      9875     
                      9876     END
MACRO ASSEMBLER BLHELI                                      09/14/16 15:00:17 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

SET4 . . . . . . .  C ADDR   1CCEH   A 
ID3. . . . . . . .  C ADDR   1C55H   A 
BYTE_CNTH. . . . .  D ADDR   0028H   A 
CRCH . . . . . . .  D ADDR   0023H   A 
CMDL . . . . . . .    REG    R4             
XH . . . . . . . .    REG    R1             
NORMAL_RUN_CHECK_~  C ADDR   1581H   A 
DECODE_DEMAG_HIGH.  C ADDR   1071H   A 
COMM61_DAMP_REV. .  C ADDR   0F2CH   A 
COMM12_NFET_DONE .  C ADDR   0D9CH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0C31H   A 
CHECK_TEMP_VOLTAG~  C ADDR   08FAH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0877H   A 
GOVERNOR_CORR_NEG~  C ADDR   083FH   A 
PCA_INT_PPM_BELOW~  C ADDR   04CEH   A 
T2_INT_CURRENT_PW~  C ADDR   02C8H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
TIMER0_OVERFLOW_V~  D ADDR   0079H   A 
PPM_THROTTLE_GAIN.  D ADDR   0072H   A 
LIPO_ADC_LIMIT_H .  D ADDR   006FH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005EH   A 
RCP_EDGE_H . . . .  D ADDR   0058H   A 
FLAGS3 . . . . . .  D ADDR   002FH   A 
RCP_PREV_EDGE_L. .  D ADDR   0027H   A 
ADC_IP . . . . . .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
ALIGN_MR25_15A_MU~  N NUMB   010Bh            
DYS_XM20A_TAIL . .  N NUMB   00F8h            
POLARIS_THUNDER_4~  N NUMB   008Fh            
POLARIS_THUNDER_3~  N NUMB   008Dh            
POLARIS_THUNDER_1~  N NUMB   0087h            
SET5 . . . . . . .  C ADDR   1CD4H   A 
ID4. . . . . . . .  C ADDR   1C60H   A 
BOOT_START . . . .  N NUMB   1C00h            
FUNCTION_BEEP. . .  C ADDR   17DBH   A 
INIT_START . . . .  C ADDR   141CH   A 
PROGRAM_BY_TX_ENT~  C ADDR   12B4H   A 
FIND_THROTTLE_GAI~  C ADDR   10A0H   A 
COMM45_NONDAMP . .  C ADDR   0EA6H   A 
COMM4COMM5 . . . .  C ADDR   0E60H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0A7BH   A 
SET_PWM_LIMIT_HIG~  C ADDR   08ECH   A 
PCA_INT_RESTORE_E~  C ADDR   0453H   A 
T2H_INT_RCP_STOP .  C ADDR   030DH   A 
T0_INT_PWM_OFF_DA~  C ADDR   011FH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006DH   A 
RANDOM . . . . . .  D ADDR   0068H   A 
PWM_MOTOR_IDLE . .  D ADDR   0065H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005DH   A 
COMM_PERIOD4X_H. .  D ADDR   0041H   A 
PWM_START. . . . .  N NUMB   0032h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
DYS_XM20A_MULTI. .  N NUMB   00F9h            
ZTW_SPIDER_PRO_20~  N NUMB   00EBh            
EMAX_NANO_20A_TAIL  N NUMB   00B3h            
PLATINUM_50AV3_TA~  N NUMB   00A1h            
PLATINUM_PRO_30A_~  N NUMB   009Ah            
POLARIS_THUNDER_4~  N NUMB   0090h            
H_KING_35A_TAIL. .  N NUMB   0080h            
SET6 . . . . . . .  C ADDR   1CDCH   A 
ID5. . . . . . . .  C ADDR   1C6DH   A 
ERRORPROG. . . . .  N NUMB   00C5h            
ERRORCRC . . . . .  N NUMB   00C2h            
BOOT_DELAY . . . .  N NUMB   5F5E10h            
PARAVAL_BEEP . . .  C ADDR   17E9H   A 
STORE_MULTI_FUNC_~  C ADDR   1762H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   163AH   A 
COMM45_DAMP_REV. .  C ADDR   0E86H   A 
COMM23_NFET_DONE .  C ADDR   0E12H   A 
GOVERNOR_CHECK_PWM  C ADDR   07CDH   A 
GOVERNOR_ACTIVATE.  C ADDR   0728H   A 
PWM_AFET_DAMPED_D~  C ADDR   0161H   A 
EEP_PGM_BRAKE_ON_~  C ADDR   1A27H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
DEMAG_DETECTED_ME~  D ADDR   0037H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
SIGNATURE_001. . .  N NUMB   00F3h            
RTX_PORT . . . . .  N NUMB   0080h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
FLYCOLOR_RAPTOR_3~  N NUMB   00D6h            
EMAX_NANO_20A_MUL~  N NUMB   00B4h            
PLATINUM_50AV3_MU~  N NUMB   00A2h            
POLARIS_THUNDER_6~  N NUMB   0092h            
H_KING_35A_MULTI .  N NUMB   0081h            
TURNIGY_AE_25A_MA~  N NUMB   0043h            
TURNIGY_AE_20A_TA~  N NUMB   0041h            
TURNIGY_PLUSH_10A~  N NUMB   001Fh            
XP_35A_SW_TAIL . .  N NUMB   0014h            
GETC . . . . . . .  C ADDR   1D92H   A 
BIT_CNT. . . . . .  D ADDR   0026H   A 
BOOT_PAGES . . . .  N NUMB   0001h            
STORE_MULTI_FUNC_~  C ADDR   1767H   A 
WRITE_EEPROM_SIGN~  C ADDR   1700H   A 
WAIT_FOR_POWER_ON.  C ADDR   13A6H   A 
ERASE_AND_STORE_A~  C ADDR   168AH   A 
THROTTLE_LOW_CAL_~  C ADDR   1314H   A 
ARMING_INITIAL_AR~  C ADDR   1297H   A 
PROGRAM_BY_TX_CHE~  C ADDR   1374H   A 
FIND_THROTTLE_GAI~  C ADDR   1099H   A 
SET_DEFAULT_PARAM~  C ADDR   0F92H   A 
COMM56_REV . . . .  C ADDR   0EF0H   A 
COMM5COMM6 . . . .  C ADDR   0ED7H   A 
COMM23_NFET_OFF_R~  C ADDR   0DF6H   A 
COMP_READ_WRONG_E~  C ADDR   0CB7H   A 
COMP_READ_OK . . .  C ADDR   0CF1H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0B1CH   A 
CALC_NEXT_COMM_TI~  C ADDR   09B7H   A 
CALC_GOVERNOR_TAR~  C ADDR   075EH   A 
BEEP_ANFET_OFF . .  C ADDR   065CH   A 
PCA_INT_STORE_DATA  C ADDR   0478H   A 
T2_INT_RCP_GAIN_P~  C ADDR   0246H   A 
T2_INT_RCP_UPDATE~  C ADDR   0208H   A 
PWM_BFET_DAMPED_D~  C ADDR   0172H   A 
RESET. . . . . . .  C ADDR   19FDH   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   00A5H   A 
PGM_ENABLE_TEMP_P~  I ADDR   00A0H   A 
_PGM_THROTTLE_RATE  I ADDR   009BH   A 
_PGM_STARTUP_RPM .  I ADDR   008FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   0062H   A 
RCP_PREPREV_EDGE_H  D ADDR   0056H   A 
WT_ZC_SCAN_START_L  D ADDR   004FH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0003h            
STARTUP_PHASE. . .  N NUMB   0001h            
RCP_SKIP_CNTD. . .  D ADDR   002BH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
SIGNATURE_002. . .  N NUMB   0090h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
ZTW_SPIDER_PRO_20~  N NUMB   00F2h            
FLYCOLOR_FAIRY_6A~  N NUMB   00CBh            
POLARIS_THUNDER_6~  N NUMB   0093h            
SKYWALKER_20A_MAIN  N NUMB   0058h            
TURNIGY_AE_30A_TA~  N NUMB   0047h            
TURNIGY_AE_20A_MU~  N NUMB   0042h            
XP_35A_SW_MULTI. .  N NUMB   0015h            
XP_7A_MAIN . . . .  N NUMB   0004h            
PRO3 . . . . . . .  C ADDR   1D0AH   A 
BOOT_SIGN. . . . .  C ADDR   1DE9H   A 
BYTE_CNTL. . . . .  D ADDR   0027H   A 
BAUDH. . . . . . .  D ADDR   0025H   A 
CRCL . . . . . . .  D ADDR   0022H   A 
XL . . . . . . . .    REG    R0             
FUNCTION_NEXT. . .  C ADDR   1858H   A 
THROTTLE_HIGH_CAL.  C ADDR   12E1H   A 
COMM61_NFET_DONE .  C ADDR   0F5EH   A 
COMM34_NFET_DONE .  C ADDR   0E42H   A 
STORE_TIMES_INCRE~  C ADDR   0BD9H   A 
CALC_NEXT_COMM_NO~  C ADDR   0A2EH   A 
STARTUP_PWM_SET_P~  C ADDR   09A5H   A 
PWM_CFET_DAMPED_D~  C ADDR   0183H   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
LIPO_ADC_LIMIT_L .  D ADDR   006EH   A 
RCP_EDGE_L . . . .  D ADDR   0057H   A 
STALL_CNT. . . . .  D ADDR   0036H   A 
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
RTX_PIN. . . . . .  N NUMB   0005h            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
ZTW_SPIDER_PRO_30~  N NUMB   00F5h            
ZTW_SPIDER_PRO_20~  N NUMB   00F3h            
ZTW_SPIDER_PRO_20~  N NUMB   00EFh            
FVT_LITTLEBEE_20A~  N NUMB   00E0h            
FLYCOLOR_FAIRY_6A~  N NUMB   00CCh            
POLARIS_THUNDER_8~  N NUMB   0095h            
TURNIGY_KFORCE_12~  N NUMB   0053h            
TURNIGY_AE_45A_MA~  N NUMB   0049h            
TURNIGY_AE_30A_MU~  N NUMB   0048h            
TURNIGY_PLUSH_30A~  N NUMB   002Bh            
TURNIGY_PLUSH_12A~  N NUMB   0022h            
XP_3A_TAIL . . . .  N NUMB   0002h            
PRO4 . . . . . . .  C ADDR   1D16H   A 
MAIN . . . . . . .  C ADDR   1C7FH   A 
PARAVAL_NEXT . . .  C ADDR   1842H   A 
WRITE_EEPROM_BYTE.  C ADDR   16D0H   A 
TEST_FOR_ONESHOT .  C ADDR   124DH   A 
MEASURE_PWM_FREQ_~  C ADDR   11FAH   A 
COMM61_NFET_OFF_R~  C ADDR   0F42H   A 
COMM_EXIT. . . . .  C ADDR   0F7AH   A 
CALC_GOVERNOR_INT~  C ADDR   0850H   A 
BEEP_CNFET_OFF . .  C ADDR   0661H   A 
BEEP_ANFET_ON. . .  C ADDR   064CH   A 
PCA_INT_PPM_CHECK~  C ADDR   04EFH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0583H   A 
PCA_INT_FALL_CHEC~  C ADDR   04C0H   A 
PCA_INT_LIMITED. .  C ADDR   05A6H   A 
T2H_INT_START. . .  C ADDR   02F3H   A 
T2_INT_PWM_UPDATE.  C ADDR   024DH   A 
T0_INT_PWM_OFF_DA~  C ADDR   010AH   A 
EEP_DUMMY. . . . .  C ADDR   1A28H   A 
EEP_PGM_ENABLE_PW~  C ADDR   1A25H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A13H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
CLOCK_SET_AT_48MHZ  D ADDR   007AH   A 
COMM_PERIOD4X_L. .  D ADDR   0040H   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
RTX_MDIN . . . . .  N NUMB   00F1h            
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0002h            
ZTW_SPIDER_PRO_30~  N NUMB   00F6h            
ZTW_SPIDER_PRO_20~  N NUMB   00F0h            
FVT_LITTLEBEE_20A~  N NUMB   00E1h            
POLARIS_THUNDER_8~  N NUMB   0096h            
SKYWALKER_40A_MAIN  N NUMB   005Bh            
TURNIGY_KFORCE_12~  N NUMB   0054h            
TURNIGY_PLUSH_40A~  N NUMB   002Eh            
SUPERMICRO_3P5A_M~  N NUMB   0019h            
XP_3A_MULTI. . . .  N NUMB   0003h            
WAIT1. . . . . . .  C ADDR   1DE2H   A 
PRO5 . . . . . . .  C ADDR   1D1CH   A 
FUNC_PARAVAL_WAIT.  C ADDR   1808H   A 
WRITE_TAG. . . . .  C ADDR   1729H   A 
READ_EEPROM_STORE~  C ADDR   1661H   A 
RUN6_CHECK_DIR . .  C ADDR   15A9H   A 
RUN1 . . . . . . .  C ADDR   14C6H   A 
WAIT_FOR_POWER_ON~  C ADDR   1415H   A 
MEASURE_PWM_FREQ_~  C ADDR   120BH   A 
CLEAR_RAM. . . . .  C ADDR   115FH   A 
SET_BEC_VOLTAGE. .  C ADDR   1085H   A 
DECODE_DEMAG_DONE.  C ADDR   1077H   A 
COMM45_NFET_DONE .  C ADDR   0EB8H   A 
WAIT_FOR_COMM. . .  C ADDR   0D44H   A 
ADJUST_TIMING_TWO~  C ADDR   0BCCH   A 
CALC_GOVERNOR_PRO~  C ADDR   0793H   A 
DIV_U16_BY_U16_DI~  C ADDR   067CH   A 
WAIT100MS. . . . .  C ADDR   05F8H   A 
WAIT1MS. . . . . .  C ADDR   05E4H   A 
T0_INT_PWM_OFF_TI~  C ADDR   00F0H   A 
T0_INT_PWM_OFF_SE~  C ADDR   00EEH   A 
STARTUP_POWER_TAB~  C ADDR   008DH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
FLASH_KEY_1. . . .  D ADDR   007CH   A 
SKIP_T2_INT. . . .  D ADDR   0077H   A 
TX_PGM_BEEP_NO . .  D ADDR   0076H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   006AH   A 
WT_ZC_TOUT_START_H  D ADDR   0052H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
RTX_MDOUT. . . . .  N NUMB   00A4h            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
HTIRC_HUMMINGBIRD~  N NUMB   011Bh            
SERVOKING_MONSTER~  N NUMB   010Ch            
ZTW_SPIDER_PRO_20~  N NUMB   00ECh            
PLATINUM_PRO_30A_~  N NUMB   009Bh            
TURNIGY_KFORCE_12~  N NUMB   0055h            
RD1. . . . . . . .  C ADDR   1D3DH   A 
PRO6 . . . . . . .  C ADDR   1D33H   A 
ABD. . . . . . . .  C ADDR   1C2EH   A 
FUNCTION_PARAVAL_~  C ADDR   17D5H   A 
STORE_NEW_VALUE_I~  C ADDR   1731H   A 
RUN2 . . . . . . .  C ADDR   14D5H   A 
ARMING_PPM_CHECK .  C ADDR   12A1H   A 
COMM45_NFET_OFF_R~  C ADDR   0E9CH   A 
COMM23_FETS_DONE .  C ADDR   0DD8H   A 
COMP_READ_WRONG_T~  C ADDR   0CCAH   A 
STORE_TIMES_EXIT .  C ADDR   0BB1H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0BE7H   A 
CHECK_VOLTAGE_PWM~  C ADDR   0987H   A 
GOVERNOR_CORR_INT~  C ADDR   0896H   A 
GOVERNOR_STORE_PR~  C ADDR   078FH   A 
DIV_U16_BY_U16_DI~  C ADDR   0686H   A 
BEEP_CNFET_ON. . .  C ADDR   0651H   A 
WAIT200MS. . . . .  C ADDR   05FDH   A 
T2_INT_RCP_GAIN_C~  C ADDR   023DH   A 
T2_INT_CURRENT_PW~  C ADDR   0277H   A 
T2_INT_PULSES_ABS~  C ADDR   01B3H   A 
T0_INT_PWM_ON_RET.  C ADDR   00D8H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_MAIN_SPOOLUP_~  I ADDR   009FH   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
FLASH_KEY_2. . . .  D ADDR   007DH   A 
RCP_PREPREV_EDGE_L  D ADDR   0055H   A 
GOV_ACTIVE . . . .  N NUMB   0006h            
MOTOR_STARTED. . .  N NUMB   0003h            
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
OVERSKY_MR_20A_PR~  N NUMB   00FDh            
ZTW_SPIDER_PRO_20~  N NUMB   00EDh            
FLYCOLOR_RAPTOR_3~  N NUMB   00D7h            
FLYCOLOR_RAPTOR_2~  N NUMB   00D3h            
PLATINUM_PRO_30A_~  N NUMB   009Ch            
TURNIGY_AE_25A_TA~  N NUMB   0044h            
TURNIGY_PLUSH_60A~  N NUMB   0031h            
TURNIGY_PLUSH_10A~  N NUMB   0020h            
MAI1 . . . . . . .  C ADDR   1C81H   A 
IN1. . . . . . . .  C ADDR   1C77H   A 
BAUDL. . . . . . .  D ADDR   0024H   A 
RUN3 . . . . . . .  C ADDR   14F3H   A 
COMM56_NFET_DONE .  C ADDR   0EE8H   A 
COMP_CHECK_TIMEOU~  C ADDR   0C8DH   A 
GOVERNOR_LIMIT_IN~  C ADDR   087EH   A 
GOVERNOR_CHECK_IN~  C ADDR   07B5H   A 
DIV_U16_BY_U16_DI~  C ADDR   069DH   A 
WAIT3MS. . . . . .  C ADDR   05E9H   A 
T2_INT_PULSES_ABS~  C ADDR   01E8H   A 
T0_INT_PWM_ON_TIM~  C ADDR   00D6H   A 
T0_INT_PWM_ON_SET~  C ADDR   00D4H   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0047H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
RCP_PPM_ONESHOT125  N NUMB   0005h            
DIR_CHANGE_BRAKE .  N NUMB   0004h            
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
FLYCOLOR_RAPTOR_3~  N NUMB   00D8h            
POLARIS_THUNDER_1~  N NUMB   0097h            
SKYWALKER_20A_TAIL  N NUMB   0059h            
TURNIGY_AE_25A_MU~  N NUMB   0045h            
TURNIGY_PLUSH_25A~  N NUMB   0028h            
TURNIGY_PLUSH_10A~  N NUMB   0021h            
XP_7A_TAIL . . . .  N NUMB   0005h            
PUTP . . . . . . .  C ADDR   1D53H   A 
SETBUF . . . . . .  C ADDR   1CC8H   A 
MAI2 . . . . . . .  C ADDR   1CA3H   A 
ERRORCOMMAND . . .  N NUMB   00C1h            
BEEP_NO_ENTRY. . .  C ADDR   1800H   A 
JMP_WAIT_FOR_POWE~  C ADDR   1646H   A 
DIRECT_START_CHEC~  C ADDR   1563H   A 
RUN4 . . . . . . .  C ADDR   1505H   A 
COMM61_FETS_DONE .  C ADDR   0F24H   A 
COMM23_NONDAMP_REV  C ADDR   0E1AH   A 
COMP_READ_OK_JMP .  C ADDR   0D03H   A 
STORE_TIMES_UP_OR~  C ADDR   0B7CH   A 
STORE_TIMES_DECRE~  C ADDR   0B90H   A 
CALC_NEXT_COMM_NE~  C ADDR   0A60H   A 
TEMP_AVERAGE_INC .  C ADDR   0932H   A 
GOVERNOR_CORR_INT~  C ADDR   08A7H   A 
MULT_S16_BY_U8_DI~  C ADDR   06ACH   A 
BEEP_START . . . .  C ADDR   062FH   A 
PCA_INT_PPM_NEG_C~  C ADDR   0543H   A 
T2_INT_EXIT. . . .  C ADDR   02D5H   A 
_EEP_PGM_DAMPING_~  C ADDR   1A16H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
PGM_BRAKE_ON_STOP.  I ADDR   00A4H   A 
PWM_DITHER_EXCESS~  D ADDR   0067H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
SKYWALKER_20A_MUL~  N NUMB   005Ah            
TURNIGY_AE_45A_TA~  N NUMB   004Ah            
TURNIGY_PLUSH_80A~  N NUMB   0034h            
TURNIGY_PLUSH_30A~  N NUMB   002Ch            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
XP_7A_MULTI. . . .  N NUMB   0006h            
PUT1 . . . . . . .  C ADDR   1D59H   A 
READ_TAGS. . . . .  C ADDR   170FH   A 
RUN5 . . . . . . .  C ADDR   1517H   A 
COMP_SCALE_SAMPLES  C ADDR   0C78H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0AD2H   A 
SET_PWM_LIMIT_HIG~  C ADDR   08DCH   A 
GOVERNOR_CORR_NEG~  C ADDR   089BH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0784H   A 
GOVERNOR_TARGET_C~  C ADDR   070BH   A 
CALC_GOVERNOR_TAR~  C ADDR   0703H   A 
PCA_INT_PWM_DIVID~  C ADDR   058AH   A 
PCA_INT_CHECK_12K~  C ADDR   03F7H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   0073H   A 
RCP_PREV_PERIOD_H.  D ADDR   005AH   A 
WT_COMM_START_H. .  D ADDR   0054H   A 
WT_ZC_TOUT_START_L  D ADDR   0051H   A 
TIMER2_X . . . . .  D ADDR   003AH   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ANFET_ON . . . . .  ? ADDR   0000H   A 
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
F85_3A_MAIN. . . .  N NUMB   00E8h            
SKYWALKER_40A_TAIL  N NUMB   005Ch            
TURNIGY_AE_45A_MU~  N NUMB   004Bh            
TURNIGY_PLUSH_40A~  N NUMB   002Fh            
TURNIGY_PLUSH_30A~  N NUMB   002Dh            
TURNIGY_PLUSH_18A~  N NUMB   0025h            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
SUPERMICRO_3P5A_T~  N NUMB   001Ah            
PUT2 . . . . . . .  C ADDR   1D6CH   A 
MAI4 . . . . . . .  C ADDR   1CDFH   A 
BAUDTIME . . . . .  N NUMB   0198h            
RUN6_CHECK_DIR_CH~  C ADDR   15BCH   A 
RUN6 . . . . . . .  C ADDR   1529H   A 
ARMING_START . . .  C ADDR   1281H   A 
MEASURE_PWM_FREQ_~  C ADDR   1200H   A 
COMM61_NONDAMP_REV  C ADDR   0F66H   A 
COMM45_FETS_DONE .  C ADDR   0E7EH   A 
COMP_CHECK_TIMEOU~  C ADDR   0C93H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0BEFH   A 
GOVERNOR_DEACTIVA~  C ADDR   0715H   A 
PCA_INT_CHECK_LEG~  C ADDR   059BH   A 
PCA_INT_FALL_NOT_~  C ADDR   04A1H   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
PREV_PREV_COMM_H .  D ADDR   003FH   A 
RCP_UPDATED. . . .  N NUMB   0000h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
BNFET_ON . . . . .  ? ADDR   0000H   A 
DEFAULT_PGM_MAIN_~  N NUMB   000Ah            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
HTIRC_HUMMINGBIRD~  N NUMB   011Ch            
SERVOKING_MONSTER~  N NUMB   0112h            
SERVOKING_MONSTER~  N NUMB   010Dh            
FLYCOLOR_FAIRY_30~  N NUMB   00CDh            
ROTORGEEKS_20A_MA~  N NUMB   00C4h            
ALIGN_RCE_BL15P_M~  N NUMB   006Dh            
SKYWALKER_40A_MUL~  N NUMB   005Dh            
TURNIGY_KFORCE_12~  N NUMB   0056h            
TURNIGY_PLUSH_40A~  N NUMB   0030h            
SUPERMICRO_3P5A_M~  N NUMB   001Bh            
DP_3A_MAIN . . . .  N NUMB   0016h            
PUT3 . . . . . . .  C ADDR   1D78H   A 
MAI5 . . . . . . .  C ADDR   1D38H   A 
WAIT_FOR_LOW . . .  C ADDR   1C45H   A 
PARAH. . . . . . .    REG    R3             
PROGRAM_BY_TX_ENT~  C ADDR   1354H   A 
ARM_TARGET_UPDATED  C ADDR   1384H   A 
COMM12_NFET_DONE_~  C ADDR   0DB2H   A 
EVALUATE_COMPARAT~  C ADDR   0D25H   A 
TEMP_CHECK_EXIT. .  C ADDR   095CH   A 
GOVERNOR_APPLY_PR~  C ADDR   0826H   A 
PWM_AFET_EXIT. . .  C ADDR   013EH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_PWM_IN~  I ADDR   00A2H   A 
_PGM_STARTUP_ACCEL  I ADDR   0090H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0046H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0025h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CNFET_ON . . . . .  ? ADDR   0000H   A 
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
HTIRC_HUMMINGBIRD~  N NUMB   011Dh            
SERVOKING_MONSTER~  N NUMB   010Eh            
OVERSKY_MR_20A_PR~  N NUMB   00FEh            
FLYCOLOR_RAPTOR_2~  N NUMB   00D4h            
TURNIGY_KFORCE_12~  N NUMB   0057h            
TURNIGY_PLUSH_60A~  N NUMB   0032h            
PUT4 . . . . . . .  C ADDR   1D8AH   A 
MAI6 . . . . . . .  C ADDR   1D49H   A 
CNTH . . . . . . .    REG    R7             
WRITE_EEPROM_BLOC~  C ADDR   16ADH   A 
NORMAL_RUN_CHECKS.  C ADDR   1570H   A 
INIT_NO_SIGNAL . .  C ADDR   117AH   A 
COMM45_NONDAMP_REV  C ADDR   0EC0H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0C51H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0B20H   A 
CALC_NEW_WAIT_PER~  C ADDR   0A8AH   A 
CALC_GOVERNOR_PRO~  C ADDR   075FH   A 
PCA_INT_PPM_UNIDI~  C ADDR   053DH   A 
T2_INT_PPM_TIMEOU~  C ADDR   01F4H   A 
PWM_BFET_EXIT. . .  C ADDR   0148H   A 
T0_INT_PWM_OFF_EX~  C ADDR   00FDH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_BRAKE~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_COM . . . . .  N NUMB   0003h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
OVERSKY_MR_20A_PR~  N NUMB   00FFh            
FLYCOLOR_RAPTOR_2~  N NUMB   00D5h            
POLARIS_THUNDER_1~  N NUMB   0098h            
ALIGN_RCE_BL35P_M~  N NUMB   0073h            
TURNIGY_PLUSH_60A~  N NUMB   0033h            
TURNIGY_PLUSH_25A~  N NUMB   0029h            
POLYNOM. . . . . .  N NUMB   A001h            
WRITE_EEPROM_BLOC~  C ADDR   16BBH   A 
PROGRAM_BY_TX_ENT~  C ADDR   1363H   A 
READ_ALL_EEPROM_P~  C ADDR   1648H   A 
COMM23_NFET_DONE_~  C ADDR   0E29H   A 
SETUP_ZC_SCAN_TIM~  C ADDR   0C16H   A 
CALC_NEXT_COMM_NE~  C ADDR   0A69H   A 
CALC_NEXT_COMM_ST~  C ADDR   09F0H   A 
CHECK_VOLTAGE_LOW~  C ADDR   097BH   A 
PWM_CFET_EXIT. . .  C ADDR   0152H   A 
T0_INT . . . . . .  C ADDR   00AAH   A 
_EEP_PGM_STARTUP_~  C ADDR   1A18H   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
SKIP_T2H_INT . . .  D ADDR   0078H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006BH   A 
RCP_STOP_CNT . . .  D ADDR   005FH   A 
NEW_RCP. . . . . .  D ADDR   005CH   A 
RCP_PREV_PERIOD_L.  D ADDR   0059H   A 
WT_COMM_START_L. .  D ADDR   0053H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
INITIAL_RUN_PHASE.  N NUMB   0002h            
HIGH_RPM . . . . .  N NUMB   0006h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00D0h            
DEBUGPIN . . . . .  N NUMB   0000h            
ANFET. . . . . . .  N NUMB   0005h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
TBS_CUBE_12A_MAIN.  N NUMB   0100h            
ROTORGEEKS_20A_PL~  N NUMB   00C7h            
POLARIS_THUNDER_1~  N NUMB   0099h            
TURNIGY_PLUSH_80A~  N NUMB   0035h            
TURNIGY_PLUSH_25A~  N NUMB   002Ah            
INIT_START_BIDIR_~  C ADDR   14AAH   A 
EVAL_COMP_EXIT . .  C ADDR   0D43H   A 
PCA_INT_SET_TIMEO~  C ADDR   05BEH   A 
PWM_NOFET. . . . .  C ADDR   0134H   A 
EEP_PGM_PWM_DITHER  C ADDR   1A26H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
PREV_PREV_COMM_L .  D ADDR   003EH   A 
PREV_COMM_H. . . .  D ADDR   003CH   A 
RCP_DIR_REV. . . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0007h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
F85_3A_TAIL. . . .  N NUMB   00E9h            
FVT_LITTLEBEE_20A~  N NUMB   00DCh            
MDRX62H_MAIN . . .  N NUMB   00C1h            
TURNIGY_PLUSH_80A~  N NUMB   0036h            
TURNIGY_PLUSH_18A~  N NUMB   0026h            
XP_12A_MAIN. . . .  N NUMB   000Ah            
PUTW . . . . . . .  C ADDR   1D4BH   A 
PARAL. . . . . . .    REG    R2             
BOOTLOADER_DONE. .  C ADDR   1190H   A 
AVERAGE_THROTTLE .  C ADDR   10BDH   A 
DECODE_PARAMS_DIR~  C ADDR   1019H   A 
COMM61_NFET_DONE_~  C ADDR   0F75H   A 
COMM34_NFET_DONE_~  C ADDR   0E58H   A 
SETUP_COMM_WAIT. .  C ADDR   0D07H   A 
CALC_NEXT_COMM_TI~  C ADDR   0AD4H   A 
CALC_GOVERNOR_INT~  C ADDR   07F1H   A 
T2_INT . . . . . .  C ADDR   0187H   A 
_PGM_DAMPING_FORCE  I ADDR   0093H   A 
AUTO_BAILOUT_ARMED  D ADDR   0060H   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0004h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
SERVOKING_MONSTER~  N NUMB   0113h            
F85_3A_MULTI . . .  N NUMB   00EAh            
FVT_LITTLEBEE_30A~  N NUMB   00E2h            
FVT_LITTLEBEE_12A~  N NUMB   00D9h            
FLYCOLOR_FAIRY_30~  N NUMB   00CEh            
ROTORGEEKS_20A_TA~  N NUMB   00C5h            
ALIGN_RCE_BL15P_T~  N NUMB   006Eh            
RCTIMER_6A_MAIN. .  N NUMB   0067h            
TURNIGY_PLUSH_NFE~  N NUMB   003Dh            
TURNIGY_PLUSH_18A~  N NUMB   0027h            
DP_3A_TAIL . . . .  N NUMB   0017h            
XP_7A_FAST_MAIN. .  N NUMB   0007h            
GET1 . . . . . . .  C ADDR   1D97H   A 
BYTE_REG . . . . .  D ADDR   0021H   A 
CNTL . . . . . . .    REG    R6             
ARM_END_BEEP . . .  C ADDR   1399H   A 
THROTTLE_HIGH_CAL~  C ADDR   12DFH   A 
PGM_START. . . . .  C ADDR   10EBH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0C32H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0B30H   A 
LOAD_MIN_TIME. . .  C ADDR   0ACEH   A 
SET_STARTUP_PWM. .  C ADDR   0990H   A 
GOVERNOR_STORE_IN~  C ADDR   07EBH   A 
GOVERNOR_ACTIVATE~  C ADDR   0751H   A 
T2H_INT_EXIT . . .  C ADDR   031EH   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   0328H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0075H   A 
ADC_CONVERSION_CNT  D ADDR   0070H   A 
GOV_ARM_TARGET . .  D ADDR   004CH   A 
RCP_PPM. . . . . .  N NUMB   0004h            
RCP_OUTSIDE_RANGE~  D ADDR   0029H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0006h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
SERVOKING_MONSTER~  N NUMB   0114h            
GRAUPNER_ULTRA_20~  N NUMB   00E5h            
FLYCOLOR_FAIRY_30~  N NUMB   00CFh            
ROTORGEEKS_20A_MU~  N NUMB   00C6h            
EMAX_20A_MAIN. . .  N NUMB   00ACh            
TAROT_30A_MAIN . .  N NUMB   00A6h            
ALIGN_RCE_BL15P_M~  N NUMB   006Fh            
DP_3A_MULTI. . . .  N NUMB   0018h            
GET2 . . . . . . .  C ADDR   1DACH   A 
FUNC_PARAVAL . . .  C ADDR   1803H   A 
WAIT1S_LOOP. . . .  C ADDR   1771H   A 
STORE_MULTI_FUNC_1  C ADDR   1735H   A 
RUN6_CHECK_DIR_REV  C ADDR   15B7H   A 
AVERAGE_THROTTLE_~  C ADDR   10DCH   A 
COMP_CHECK_TIMEOUT  C ADDR   0C80H   A 
CALC_GOVERNOR_PRO~  C ADDR   084FH   A 
GOVERNOR_INT_MIN_~  C ADDR   07E6H   A 
GOVERNOR_LIMIT_PR~  C ADDR   078BH   A 
BEEP_F1. . . . . .  C ADDR   060DH   A 
PCA_INT_PPM_OUTSI~  C ADDR   04D7H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   0071H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0064H   A 
PWM_LIMIT. . . . .  D ADDR   0061H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
FLYCOLOR_FAIRY_V2~  N NUMB   00D0h            
ALIGN_RCE_BL35P_T~  N NUMB   0074h            
GET3 . . . . . . .  C ADDR   1DD0H   A 
BL_FLASH_KEY_1 . .  D ADDR   0029H   A 
STORE_MULTI_FUNC_2  C ADDR   173AH   A 
INITIAL_RUN_PHASE~  C ADDR   1590H   A 
TEST_THROTTLE_GAIN  C ADDR   10AEH   A 
COMM23_FETS_DONE_~  C ADDR   0DF8H   A 
GOVERNOR_STORE_PR~  C ADDR   084DH   A 
GOVERNOR_CHECK_PR~  C ADDR   0811H   A 
MULT_S16_BY_U8_PO~  C ADDR   06C6H   A 
DIV_U16_BY_U16 . .  C ADDR   0674H   A 
BEEP_ONOFF . . . .  C ADDR   0631H   A 
BEEP_F2. . . . . .  C ADDR   0614H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0524H   A 
PCA_INT_CHECK_DIFF  C ADDR   046BH   A 
T2_INT_SKIP_START.  C ADDR   01F8H   A 
PWM_AFET . . . . .  C ADDR   0136H   A 
T0_INT_PWM_OFF_FU~  C ADDR   0126H   A 
EEP_PGM_ENABLE_PO~  C ADDR   1A24H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0015h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
PREV_COMM_L. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNTD .  D ADDR   002AH   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
TBS_CUBE_12A_TAIL.  N NUMB   0101h            
ROTORGEEKS_20A_PL~  N NUMB   00C8h            
XROTOR_10A_MAIN. .  N NUMB   00B8h            
EMAX_40A_MAIN. . .  N NUMB   00AFh            
ALIGN_RCE_BL35P_M~  N NUMB   0075h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ah            
TURNIGY_KFORCE_70~  N NUMB   004Fh            
TURNIGY_KFORCE_40~  N NUMB   004Ch            
XP_25A_MAIN. . . .  N NUMB   0010h            
INIT . . . . . . .  C ADDR   1C00H   A 
BL_FLASH_KEY_2 . .  D ADDR   002AH   A 
PARAVAL_NO_ENTRY .  C ADDR   17FDH   A 
STORE_MULTI_FUNC_3  C ADDR   173FH   A 
RUN6_BRAKE_DONE. .  C ADDR   15D0H   A 
SUCCESS_BEEP_INVE~  C ADDR   17A6H   A 
SUCCESS_BEEP . . .  C ADDR   1777H   A 
FIND_THROTTLE_GAIN  C ADDR   1086H   A 
DECODE_SETTINGS. .  C ADDR   1037H   A 
COMM56_NFET_DONE_~  C ADDR   0EFEH   A 
RUN_TO_WAIT_FOR_P~  C ADDR   15EEH   A 
TEMP_AVERAGE_INC_~  C ADDR   0922H   A 
GOVERNOR_INT_MAX_~  C ADDR   07DEH   A 
GOVERNOR_LIMIT_IN~  C ADDR   07BEH   A 
BEEP_F3. . . . . .  C ADDR   061BH   A 
PCA_INT_FAIL_MINI~  C ADDR   0384H   A 
PWM_BFET . . . . .  C ADDR   0140H   A 
T0_INT_PWM_OFF_EX~  C ADDR   011FH   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0069H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
SKIP_DAMP_ON . . .  N NUMB   0007h            
P1_INIT. . . . . .  N NUMB   0001h            
RTX_SKIP . . . . .  N NUMB   00D4h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
TBS_CUBE_12A_MULTI  N NUMB   0102h            
FVT_LITTLEBEE_20A~  N NUMB   00DDh            
ROTORGEEKS_20A_PL~  N NUMB   00C9h            
MDRX62H_TAIL . . .  N NUMB   00C2h            
XROTOR_20A_MAIN. .  N NUMB   00BBh            
EMAX_LIGHTNING_20~  N NUMB   00B5h            
PLATINUM_PRO_150A~  N NUMB   009Dh            
TURNIGY_PLUSH_NFE~  N NUMB   003Ah            
XP_12A_TAIL. . . .  N NUMB   000Bh            
UART_LOOP. . . . .  N NUMB   001Ah            
STORE_MULTI_FUNC_4  C ADDR   1744H   A 
BEEP_DELAY_SET . .  C ADDR   13CEH   A 
PROGRAM_BY_TX_ENT~  C ADDR   12C5H   A 
LOCK_BYTE_OK . . .  C ADDR   1110H   A 
AVERAGE_THROTTLE_~  C ADDR   10CDH   A 
DECODE_PWM_FREQ_L~  C ADDR   1031H   A 
COMM61_FETS_DONE_~  C ADDR   0F44H   A 
COMP_READ_WRONG_L~  C ADDR   0CD6H   A 
SET_PWM_LIMIT_LOW~  C ADDR   08D9H   A 
BEEP_F4. . . . . .  C ADDR   0622H   A 
PCA_INT_PPM_MAX_C~  C ADDR   056AH   A 
PCA_INT_RESTORE_E~  C ADDR   0455H   A 
T2_INT_CURRENT_PW~  C ADDR   02C6H   A 
PWM_CFET . . . . .  C ADDR   014AH   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A7H   A 
_PGM_STARTUP_METH~  I ADDR   0095H   A 
_PGM_VOLT_COMP . .  I ADDR   0091H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0005h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
HTIRC_HUMMINGBIRD~  N NUMB   0118h            
FVT_LITTLEBEE_30A~  N NUMB   00E3h            
FVT_LITTLEBEE_20A~  N NUMB   00DEh            
FVT_LITTLEBEE_12A~  N NUMB   00DAh            
MDRX62H_MULTI. . .  N NUMB   00C3h            
H_KING_10A_MAIN. .  N NUMB   0079h            
ALIGN_RCE_BL35X_M~  N NUMB   0070h            
RCTIMER_6A_TAIL. .  N NUMB   0068h            
TURNIGY_PLUSH_NFE~  N NUMB   003Eh            
XP_18A_MAIN. . . .  N NUMB   000Dh            
XP_12A_MULTI . . .  N NUMB   000Ch            
XP_7A_FAST_TAIL. .  N NUMB   0008h            
PROGRAM_BY_TX_EXIT  C ADDR   1869H   A 
STORE_MULTI_FUNC_5  C ADDR   1749H   A 
READ_EEPROM_BYTE .  C ADDR   16CCH   A 
THROTTLE_LOW_CAL .  C ADDR   1316H   A 
COMP_READ_WRONG. .  C ADDR   0C9EH   A 
STORE_TIMES_UP_OR~  C ADDR   0BD3H   A 
STORE_TIMES_DECRE~  C ADDR   0BE1H   A 
TEMP_AVERAGE_UPDA~  C ADDR   093AH   A 
SET_PWM_LIMIT_HIG~  C ADDR   08EDH   A 
GOVERNOR_APPLY_IN~  C ADDR   0882H   A 
GOVERNOR_LIMIT_PR~  C ADDR   081CH   A 
BEEP_OFF . . . . .  C ADDR   066AH   A 
WAIT10MS . . . . .  C ADDR   05EEH   A 
T2_INT_CURRENT_PW~  C ADDR   02A4H   A 
PWM_AFET_DAMPED_E~  C ADDR   0163H   A 
T0_INT_PWM_ON_EXIT  C ADDR   00C4H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Eh            
PGM_PWM_DITHER . .  I ADDR   00A3H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0074H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   000Ah            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
HTIRC_HUMMINGBIRD~  N NUMB   0115h            
SERVOKING_MONSTER~  N NUMB   010Fh            
DALRC_XR20A_MAIN .  N NUMB   0103h            
GRAUPNER_ULTRA_20~  N NUMB   00E6h            
FVT_LITTLEBEE_30A~  N NUMB   00E4h            
FVT_LITTLEBEE_12A~  N NUMB   00DBh            
XROTOR_40A_MAIN. .  N NUMB   00BEh            
EMAX_20A_TAIL. . .  N NUMB   00ADh            
TAROT_30A_TAIL . .  N NUMB   00A7h            
H_KING_20A_MAIN. .  N NUMB   007Ch            
RCTIMER_6A_MULTI .  N NUMB   0069h            
HIMODEL_COOL_22A_~  N NUMB   005Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0037h            
XP_7A_FAST_MULTI .  N NUMB   0009h            
GETW . . . . . . .  C ADDR   1D8EH   A 
STORE_MULTI_FUNC_6  C ADDR   174EH   A 
READ_TAG . . . . .  C ADDR   1718H   A 
RESET_CAL_DONE . .  C ADDR   1139H   A 
DECODE_PARAMETERS.  C ADDR   0FFEH   A 
COMM45_FETS_DONE_~  C ADDR   0E9EH   A 
COMM23_NFET_OFF. .  C ADDR   0DD6H   A 
SETUP_ZC_SCAN_TIM~  C ADDR   0BF9H   A 
STORE_TIMES_INCRE~  C ADDR   0B82H   A 
MEASURE_LIPO_CELLS  C ADDR   08F2H   A 
CALC_GOVERNOR_INT~  C ADDR   0794H   A 
PCA_INT_PPM_CALCU~  C ADDR   0506H   A 
PCA_INT_EXIT . . .  C ADDR   05D2H   A 
T2_INT_RCP_UPDATE~  C ADDR   0225H   A 
PWM_BFET_DAMPED_E~  C ADDR   0174H   A 
RCP_PERIOD_DIFF_A~  D ADDR   005BH   A 
COMPARATOR_READ_C~  D ADDR   0043H   A 
STARTUP_CNT. . . .  D ADDR   0033H   A 
PWM_TIMER0_OVERFL~  N NUMB   0003h            
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0001h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
AIKON_BOLTLITE_30~  N NUMB   0106h            
OVERSKY_MR_20A_MA~  N NUMB   00FAh            
GRAUPNER_ULTRA_20~  N NUMB   00E7h            
FLYCOLOR_FAIRY_V2~  N NUMB   00D1h            
EMAX_20A_MULTI . .  N NUMB   00AEh            
TAROT_30A_MULTI. .  N NUMB   00A8h            
HIMODEL_COOL_41A_~  N NUMB   0064h            
TURNIGY_PLUSH_6A_~  N NUMB   001Ch            
GETX . . . . . . .  C ADDR   1D9CH   A 
STORE_MULTI_FUNC_7  C ADDR   1753H   A 
RUN6_CHECK_SPEED .  C ADDR   15C6H   A 
WAIT_FOR_POWER_ON~  C ADDR   13FDH   A 
SWITCH_POWER_OFF .  C ADDR   0F7DH   A 
COMP_READ_WRONG_N~  C ADDR   0CAAH   A 
CALC_NEW_WAIT_PER~  C ADDR   0AA6H   A 
WAIT30MS . . . . .  C ADDR   05F3H   A 
PCA_INT_PPM_BIDIR~  C ADDR   055BH   A 
PCA_INT_CHECK_1KHZ  C ADDR   0444H   A 
T2H_INT. . . . . .  C ADDR   02E2H   A 
PWM_CFET_DAMPED_E~  C ADDR   0185H   A 
GOV_INTEGRAL_X . .  D ADDR   0048H   A 
COMP_TIMED_OUT . .  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   0018h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
FLYCOLOR_FAIRY_V2~  N NUMB   00D2h            
XROTOR_10A_TAIL. .  N NUMB   00B9h            
EMAX_40A_TAIL. . .  N NUMB   00B0h            
EAZY_3AV2_MAIN . .  N NUMB   00A3h            
ALIGN_RCE_BL15X_T~  N NUMB   006Bh            
HIMODEL_COOL_33A_~  N NUMB   0061h            
TURNIGY_KFORCE_70~  N NUMB   0050h            
TURNIGY_KFORCE_40~  N NUMB   004Dh            
XP_25A_TAIL. . . .  N NUMB   0011h            
RST. . . . . . . .  C ADDR   1CC6H   A 
SUCCESS. . . . . .  N NUMB   0030h            
BOOT_VERSION . . .  N NUMB   0006h            
XTAL . . . . . . .  N NUMB   17D7840h            
FUNC_PARAVAL_CONT~  C ADDR   1835H   A 
WAIT1S . . . . . .  C ADDR   176FH   A 
STORE_MULTI_FUNC_8  C ADDR   1758H   A 
WRITE_TAGS . . . .  C ADDR   1722H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   15F6H   A 
COMM61_NFET_OFF. .  C ADDR   0F22H   A 
EVAL_COMP_CHECK_T~  C ADDR   0D33H   A 
ADJUST_TIMING_TWO~  C ADDR   0B69H   A 
INITIALIZE_TIMING.  C ADDR   09B0H   A 
CHECK_VOLTAGE_RET.  C ADDR   098FH   A 
GOVERNOR_ACTIVATE~  C ADDR   0758H   A 
WAITXMS_M. . . . .  C ADDR   0604H   A 
PCA_INT_CHECK_2KHZ  C ADDR   0433H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
WT_ADV_START_H . .  D ADDR   004EH   A 
GOV_TARGET_H . . .  D ADDR   0045H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
XROTOR_20A_TAIL. .  N NUMB   00BCh            
XROTOR_10A_MULTI .  N NUMB   00BAh            
EMAX_LIGHTNING_20~  N NUMB   00B6h            
EMAX_40A_MULTI . .  N NUMB   00B1h            
SKYIII_30A_MAIN. .  N NUMB   00A9h            
PLATINUM_PRO_150A~  N NUMB   009Eh            
POLARIS_THUNDER_2~  N NUMB   0088h            
H_KING_50A_MAIN. .  N NUMB   0082h            
GAUI_GE_183_18A_M~  N NUMB   0076h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ch            
TURNIGY_KFORCE_70~  N NUMB   0051h            
TURNIGY_KFORCE_40~  N NUMB   004Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Bh            
XP_25A_MULTI . . .  N NUMB   0012h            
EXIT . . . . . . .  C ADDR   1CB7H   A 
BOOT_MSG . . . . .  C ADDR   1DEFH   A 
STORE_MULTI_FUNC_9  C ADDR   175DH   A 
READ_INITIAL_TEMP.  C ADDR   1456H   A 
WAIT_FOR_POWER_ON~  C ADDR   13F1H   A 
PROGRAM_BY_TX_ENT~  C ADDR   135AH   A 
DECODE_PWM_FREQ_E~  C ADDR   1036H   A 
WAIT_FOR_COMM_WAIT  C ADDR   0D7AH   A 
START_ADC_CONVERS~  C ADDR   08F6H   A 
MULT_S16_BY_U8_EX~  C ADDR   06FAH   A 
PCA_INT_PPM_LIMIT~  C ADDR   057CH   A 
GET_RCP_END. . . .  C ADDR   035BH   A 
T2H_INT_RCP_GOV_P~  C ADDR   031EH   A 
T2_INT_PWM_MIN_RUN  C ADDR   024DH   A 
PWM_DITHER_TABLE .  C ADDR   009AH   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
PGM_ENABLE_POWER_~  I ADDR   00A1H   A 
PWM_DITHER_DECODED  D ADDR   0066H   A 
PWM_LIMIT_BY_RPM .  D ADDR   0063H   A 
LOW_RPM_PWR_SLOPE.  D ADDR   0039H   A 
INITIAL_RUN_ROT_C~  D ADDR   0035H   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
MUX_A. . . . . . .  N NUMB   0000h            
PFETON_DELAY . . .  N NUMB   0018h            
HIGH_BEC_VOLTAGE .  N NUMB   0000h            
PSW. . . . . . . .  D ADDR   00D0H   A 
HTIRC_HUMMINGBIRD~  N NUMB   0119h            
ALIGN_MR25_15A_MA~  N NUMB   0109h            
XROTOR_20A_MULTI .  N NUMB   00BDh            
EMAX_LIGHTNING_20~  N NUMB   00B7h            
PLATINUM_PRO_150A~  N NUMB   009Fh            
POLARIS_THUNDER_3~  N NUMB   008Bh            
POLARIS_THUNDER_1~  N NUMB   0085h            
H_KING_10A_TAIL. .  N NUMB   007Ah            
ALIGN_RCE_BL35X_T~  N NUMB   0071h            
TURNIGY_PLUSH_NFE~  N NUMB   003Ch            
XP_18A_TAIL. . . .  N NUMB   000Eh            
WAITF. . . . . . .  C ADDR   1DDCH   A 
BOOT_BAUDRATE. . .  N NUMB   4B00h            
STORE_IN_RAM_EXIT.  C ADDR   176CH   A 
VALIDATE_RCP_START  C ADDR   1261H   A 
LOCK_BYTE_TEST . .  C ADDR   1109H   A 
COMM45_NFET_OFF. .  C ADDR   0E7CH   A 
COMM12_REV . . . .  C ADDR   0DA4H   A 
COMM1COMM2 . . . .  C ADDR   0D8BH   A 
COMP_READ_WRONG_L~  C ADDR   0CE7H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0BF1H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0938H   A 
TEMP_AVERAGE_DEC .  C ADDR   092EH   A 
CALC_GOVERNOR_PRO~  C ADDR   07F2H   A 
WAITXMS_O. . . . .  C ADDR   0602H   A 
PCA_INT_PPM_TIMEO~  C ADDR   05C7H   A 
PCA_INT_CHECK_4KHZ  C ADDR   0422H   A 
T0_INT_PWM_OFF . .  C ADDR   00DFH   A 
T0_INT_START . . .  C ADDR   00B7H   A 
EEPROM_FW_SUB_REV~  N NUMB   004Bh            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   004AH   A 
DEFAULT_PGM_MULTI~  N NUMB   0028h            
MUX_B. . . . . . .  N NUMB   0002h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   000Ah            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
HTIRC_HUMMINGBIRD~  N NUMB   011Ah            
HTIRC_HUMMINGBIRD~  N NUMB   0116h            
SERVOKING_MONSTER~  N NUMB   0110h            
DALRC_XR20A_TAIL .  N NUMB   0104h            
DYS_XM20A_MAIN . .  N NUMB   00F7h            
XROTOR_40A_TAIL. .  N NUMB   00BFh            
POLARIS_THUNDER_4~  N NUMB   008Eh            
H_KING_20A_TAIL. .  N NUMB   007Dh            
H_KING_10A_MULTI .  N NUMB   007Bh            
ALIGN_RCE_BL35X_M~  N NUMB   0072h            
HIMODEL_COOL_22A_~  N NUMB   005Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0038h            
XP_18A_MULTI . . .  N NUMB   000Fh            
PUTC . . . . . . .  C ADDR   1D6FH   A 
BIT_REG. . . . . .  D ADDR   0020H   A 
CMDH . . . . . . .    REG    R5             
READ_EEPROM_EXIT .  C ADDR   1689H   A 
WAIT_FOR_POWER_ON~  C ADDR   13ABH   A 
INPUT_HIGH_CHECK_1  C ADDR   1184H   A 
CHECK_VOLTAGE_STA~  C ADDR   0960H   A 
SET_PWM_LIMIT_LOW~  C ADDR   08ACH   A 
CALC_GOVERNOR_INT~  C ADDR   08ABH   A 
GOVERNOR_LIMIT_IN~  C ADDR   07C7H   A 
MULT_S16_BY_U8_DI~  C ADDR   06DFH   A 
BEEP . . . . . . .  C ADDR   0629H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0529H   A 
PCA_INT_FALL . . .  C ADDR   0486H   A 
T2_INT_SKIP_END. .  C ADDR   0203H   A 
TX_PGM_PARAMS_MUL~  C ADDR   009FH   A 
EEP_PGM_TEMP_PROT~  C ADDR   1A23H   A 
_EEP_PGM_THROTTLE~  C ADDR   1A1EH   A 
_EEP_PGM_STARTUP_~  C ADDR   1A12H   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A6H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006CH   A 
COMM_PHASE . . . .  D ADDR   0042H   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
MUX_C. . . . . . .  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   000Ah            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
HTIRC_HUMMINGBIRD~  N NUMB   0117h            
SERVOKING_MONSTER~  N NUMB   0111h            
AIKON_BOLTLITE_30~  N NUMB   0107h            
DALRC_XR20A_MULTI.  N NUMB   0105h            
OVERSKY_MR_20A_TA~  N NUMB   00FBh            
XROTOR_40A_MULTI .  N NUMB   00C0h            
EMAX_NANO_20A_MAIN  N NUMB   00B2h            
PLATINUM_50AV3_MA~  N NUMB   00A0h            
H_KING_35A_MAIN. .  N NUMB   007Fh            
H_KING_20A_MULTI .  N NUMB   007Eh            
HIMODEL_COOL_41A_~  N NUMB   0065h            
HIMODEL_COOL_22A_~  N NUMB   0060h            
TURNIGY_PLUSH_NFE~  N NUMB   0039h            
TURNIGY_PLUSH_6A_~  N NUMB   001Dh            
WAITH. . . . . . .  C ADDR   1DE0H   A 
ERASE_FLASH. . . .  C ADDR   16ECH   A 
RUN_TO_WAIT_FOR_P~  C ADDR   15F9H   A 
PROGRAM_BY_TX. . .  C ADDR   17F4H   A 
INPUT_HIGH_CHECK_2  C ADDR   1186H   A 
COMM23_NONDAMP . .  C ADDR   0E00H   A 
COMM2COMM3 . . . .  C ADDR   0DBAH   A 
CALC_NEXT_COMM_AV~  C ADDR   0A4DH   A 
GOVERNOR_STORE_IN~  C ADDR   08A9H   A 
GOVERNOR_CHECK_IN~  C ADDR   086BH   A 
GOVERNOR_CORR_PRO~  C ADDR   083AH   A 
GOVERNOR_ACTIVATE~  C ADDR   0745H   A 
T2_INT_START . . .  C ADDR   01A3H   A 
PWM_AFET_DAMPED. .  C ADDR   0154H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_ADV_START_L . .  D ADDR   004DH   A 
GOV_TARGET_L . . .  D ADDR   0044H   A 
DEMAG_PWR_OFF_THR~  D ADDR   0038H   A 
STARTUP_ZC_TIMEOU~  D ADDR   0034H   A 
FLAGS0 . . . . . .  D ADDR   002CH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFB2h            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
AIKON_BOLTLITE_30~  N NUMB   0108h            
OVERSKY_MR_20A_MU~  N NUMB   00FCh            
EAZY_3AV2_TAIL . .  N NUMB   00A4h            
POLARIS_THUNDER_6~  N NUMB   0091h            
HIMODEL_COOL_41A_~  N NUMB   0066h            
HIMODEL_COOL_33A_~  N NUMB   0062h            
TURNIGY_AE_20A_MA~  N NUMB   0040h            
TURNIGY_PLUSH_6A_~  N NUMB   001Eh            
XP_35A_SW_MAIN . .  N NUMB   0013h            
ID1. . . . . . . .  C ADDR   1C4AH   A 
FUNC_PARAVAL_STORE  C ADDR   1824H   A 
WRITE_EEPROM_BYTE~  C ADDR   16D1H   A 
READ_EEPROM_BLOCK1  C ADDR   1671H   A 
READ_EEPROM_READ .  C ADDR   166AH   A 
COMM23_DAMP_REV. .  C ADDR   0DE0H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0BB3H   A 
LOAD_MIN_TIME_FAST  C ADDR   0B1AH   A 
MEASURE_LIPO_EXIT.  C ADDR   08F5H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0822H   A 
GOVERNOR_CHECK_PR~  C ADDR   0778H   A 
PCA_INT_SECOND_ME~  C ADDR   03ADH   A 
T2H_INT_RCP_STOP_~  C ADDR   0301H   A 
PWM_BFET_DAMPED. .  C ADDR   0165H   A 
PCA_INT. . . . . .  C ADDR   033BH   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
FLAGS1 . . . . . .  D ADDR   002DH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0001h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFEh            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
ZTW_SPIDER_PRO_20~  N NUMB   00F1h            
FLYCOLOR_FAIRY_6A~  N NUMB   00CAh            
SKYIII_30A_TAIL. .  N NUMB   00AAh            
EAZY_3AV2_MULTI. .  N NUMB   00A5h            
POLARIS_THUNDER_2~  N NUMB   0089h            
H_KING_50A_TAIL. .  N NUMB   0083h            
GAUI_GE_183_18A_T~  N NUMB   0077h            
HIMODEL_COOL_33A_~  N NUMB   0063h            
TURNIGY_AE_30A_MA~  N NUMB   0046h            
BOOT_INFO. . . . .  C ADDR   1DF3H   A 
ERRORVERIFY. . . .  N NUMB   00C0h            
READ_EEPROM_BLOCK2  C ADDR   167FH   A 
MEASURE_PWM_FREQ_~  C ADDR   11FEH   A 
COMM61_NONDAMP . .  C ADDR   0F4CH   A 
COMM6COMM1 . . . .  C ADDR   0F06H   A 
COMM34_REV . . . .  C ADDR   0E4AH   A 
COMM3COMM4 . . . .  C ADDR   0E31H   A 
COMP_CHECK_TIMEOU~  C ADDR   0C91H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0C43H   A 
GOVERNOR_CORR_PRO~  C ADDR   084BH   A 
PCA_INT_PPM_BIDIR~  C ADDR   051DH   A 
PCA_INT_CHECK_8KHZ  C ADDR   0411H   A 
T2_INT_CURRENT_PW~  C ADDR   02BDH   A 
PWM_CFET_DAMPED. .  C ADDR   0176H   A 
_EEP_PGM_MAIN_SPO~  C ADDR   1A22H   A 
_EEP_PGM_LOW_VOLT~  C ADDR   1A06H   A 
DAMPINGFET . . . .  D ADDR   007BH   A 
WT_ZC_SCAN_START_H  D ADDR   0050H   A 
GOV_PROP_PWM . . .  D ADDR   004BH   A 
GOV_PROPORTIONAL_L  D ADDR   0049H   A 
PREV_COMM_X. . . .  D ADDR   003DH   A 
FLAGS2 . . . . . .  D ADDR   002EH   A 
DEMAG_DETECTED . .  N NUMB   0004h            
CURRENT_PWM_LIM_D~  D ADDR   0026H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
MCU_48MHZ. . . . .  N NUMB   0001h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
ALIGN_MR25_15A_TA~  N NUMB   010Ah            
ZTW_SPIDER_PRO_30~  N NUMB   00F4h            
ZTW_SPIDER_PRO_20~  N NUMB   00EEh            
FVT_LITTLEBEE_20A~  N NUMB   00DFh            
SKYIII_30A_MULTI .  N NUMB   00ABh            
POLARIS_THUNDER_8~  N NUMB   0094h            
POLARIS_THUNDER_3~  N NUMB   008Ch            
POLARIS_THUNDER_2~  N NUMB   008Ah            
POLARIS_THUNDER_1~  N NUMB   0086h            
H_KING_50A_MULTI .  N NUMB   0084h            
GAUI_GE_183_18A_M~  N NUMB   0078h            
TURNIGY_KFORCE_12~  N NUMB   0052h            
XP_3A_MAIN . . . .  N NUMB   0001h            



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6745    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =    105    ----
   IDATA SIZE       =     88    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
